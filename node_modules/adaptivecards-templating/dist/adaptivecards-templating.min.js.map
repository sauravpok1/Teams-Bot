{"version":3,"file":"adaptivecards-templating.min.js","mappings":"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","sources":["webpack://ACData/webpack/universalModuleDefinition","webpack://ACData/./src/adaptivecards-templating.ts","webpack://ACData/./src/json-schema-card.ts","webpack://ACData/./src/template-engine.ts","webpack://ACData/external {\"commonjs2\":\"adaptive-expressions\",\"commonjs\":\"adaptive-expressions\",\"root\":\"AEL\"}","webpack://ACData/webpack/bootstrap","webpack://ACData/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"adaptive-expressions\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ACData\"] = factory(require(\"adaptive-expressions\"));\n\telse\n\t\troot[\"ACData\"] = factory(root[\"AEL\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__248__) {\nreturn ","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nexport * from \"./template-engine\";\nexport * from \"./json-schema-card\";","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { IAdaptiveCard, ICardElement, IChoiceSetInput, IContainer, INumberInput, ITextInput, ITimeInput, IToggleInput } from 'adaptivecards/src/schema';\nimport { JSONSchema7, JSONSchema7Definition, JSONSchema7Type } from 'json-schema';\n\n\n// JSON Schema Card\n// generates an Adaptive Card given a JSON schema\nexport function JSONSchemaCard(schema: JSONSchema7): IAdaptiveCard | undefined {\n\ttry {\n\t\treturn {\n\t\t\ttype: \"AdaptiveCard\",\n\t\t\tbody: [\n\t\t\t\tJSONSchemaCardObject(schema, '', 0),\n\t\t\t],\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(e);\n\t\treturn undefined;\n\t}\n}\n\n\n// JSON Schema Elements\n\nfunction JSONSchemaCardElement(schema: JSONSchema7Definition, path: string, depth: number): ICardElement {\n    if (typeof (schema) === \"boolean\") return null;\n    switch (schema.type) {\n        case \"array\":\n            if (Array.isArray(schema.items)) {\n                return JSONSchemaCardTuple(schema, path, depth);\n            } else {\n                return JSONSchemaCardList(schema, path, depth);\n            }\n        case \"object\":\n            return JSONSchemaCardObject(schema, path, depth);\n        case \"boolean\":\n            return JSONSchemaCardBoolean(schema, path)\n        case \"integer\":\n        case \"number\":\n            return JSONSchemaCardNumber(schema, path)\n        case \"string\":\n            if (schema.enum) {\n                return JSONSchemaCardChoiceSet(schema, path)\n            } else {\n                return JSONSchemaCardText(schema, path)\n            }\n        case \"date-time\":\n        case \"time\":\n        case \"date\":\n            return JSONSchemaCardTime(schema, path)\n        default:\n            return null;\n    }\n}\n\nfunction encodeProperty(property: string) {\n    return encodeURIComponent(property).replace('.', '%2e')\n}\n\nfunction textSizeAtDepth(depth: number) {\n    switch (depth) {\n        case 0:\n            \"large\"\n        case 1:\n            \"medium\"\n        default:\n            \"small\"\n    }\n}\n\nfunction JSONSchemaFieldTitle(schema: JSONSchema7, path: string, depth: number): ICardElement[] {\n    return [\n        schema.title ? {\n            type: \"TextBlock\",\n            size: textSizeAtDepth(depth),\n            text: schema.title,\n        } : null,\n        schema.description ? {\n            type: \"TextBlock\",\n            size: textSizeAtDepth(depth + 1),\n            isSubtle: true,\n            wrap: true,\n            text: schema.description,\n        } : null,\n    ]\n}\n\nfunction JSONSchemaCardTuple(schema: JSONSchema7, path: string, depth: number): IContainer {\n    if (!Array.isArray(schema.items)) return null;\n    return {\n        type: \"Container\",\n        items: [\n            ...JSONSchemaFieldTitle(schema, path, depth),\n            ...schema.items?.map((item: JSONSchema7Definition, idx: number) => {\n                return JSONSchemaCardElement(item, `${path}[${idx}]`, depth + 1)\n            }) ?? [],\n        ],\n    }\n}\n\nfunction JSONSchemaCardList(schema: JSONSchema7, path: string, depth: number): IContainer {\n    return {\n        type: \"Container\",\n        items: [\n            ...JSONSchemaFieldTitle(schema, path, depth),\n            // TODO not implemented\n        ],\n    }\n}\n\nfunction JSONSchemaCardObject(schema: JSONSchema7, path: string, depth: number): IContainer {\n    return {\n        type: \"Container\",\n        items: [\n            ...JSONSchemaFieldTitle(schema, path, depth),\n            ...schema.required?.map((property: string) => {\n                return JSONSchemaCardElement(schema.properties[property], `${path}.${encodeProperty(property)}`, depth + 1)\n            }) ?? [],\n        ],\n    }\n}\n\nfunction JSONSchemaCardBoolean(schema: JSONSchema7, path: string): IToggleInput {\n    return {\n        type: \"Input.Toggle\",\n        id: path,\n        title: schema.title,\n        label: schema.description,\n        value: schema.default as string,\n    }\n}\n\nfunction JSONSchemaCardNumber(schema: JSONSchema7, path: string): INumberInput {\n    return {\n        type: \"Input.Number\",\n        id: path,\n        title: schema.title,\n        placeholder: schema.description,\n        value: schema.default as string,\n        min: schema.exclusiveMinimum ?? schema.minimum,\n        max: schema.exclusiveMaximum ?? schema.maximum,\n    }\n}\n\nfunction JSONSchemaCardChoiceSet(schema: JSONSchema7, path: string): IChoiceSetInput {\n    return {\n        type: \"Input.ChoiceSet\",\n        id: path,\n        title: schema.title,\n        choices: schema.enum.map((item: JSONSchema7Type) => {\n            return {\n                title: item as string,\n                value: item as string,\n            }\n        }),\n        placeholder: schema.description,\n        value: schema.default as string,\n    }\n}\n\nfunction JSONSchemaCardText(schema: JSONSchema7, path: string): ITextInput {\n    return {\n        type: \"Input.Text\",\n        id: path,\n        title: schema.title,\n        placeholder: schema.description,\n        value: schema.default as string,\n        maxLength: schema.maxLength,\n        regex: schema.pattern,\n    }\n}\n\nfunction JSONSchemaCardTime(schema: JSONSchema7, path: string): ITimeInput {\n    return {\n        type: \"Input.Time\",\n        id: path,\n        title: schema.title,\n        placeholder: schema.description,\n        value: schema.default as string,\n    }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport * as AEL from \"adaptive-expressions\";\n\nclass EvaluationContext {\n    private static readonly _reservedFields = [\"$data\", \"$when\", \"$root\", \"$index\"];\n\n    private _stateStack: Array<{ $data: any, $index: any }> = [];\n    private _$data: any;\n\n    $root: any;\n    $index: number;\n\n    constructor(context?: IEvaluationContext) {\n        if (context !== undefined) {\n            this.$root = context.$root;\n        }\n    }\n\n    isReservedField(name: string): boolean {\n        return EvaluationContext._reservedFields.indexOf(name) >= 0;\n    }\n\n    saveState() {\n        this._stateStack.push(\n            {\n                $data: this.$data,\n                $index: this.$index\n            });\n    }\n\n    restoreLastState() {\n        if (this._stateStack.length === 0) {\n            throw new Error(\"There is no evaluation context state to restore.\");\n        }\n\n        let savedContext = this._stateStack.pop();\n\n        this.$data = savedContext.$data;\n        this.$index = savedContext.$index;\n    }\n\n    get $data(): any {\n        return this._$data !== undefined ? this._$data : this.$root;\n    }\n\n    set $data(value: any) {\n        this._$data = value;\n    }\n}\n\nclass TemplateObjectMemory implements AEL.MemoryInterface {\n    private _memory: AEL.MemoryInterface;\n\n    $root: any;\n    $data: any;\n    $index: any;\n\n    constructor() {\n        this._memory = new AEL.SimpleObjectMemory(this);\n    }\n\n    getValue(path: string): any {\n        let actualPath = (path.length > 0 && path[0] !== \"$\") ? \"$data.\" + path : path;\n\n        return this._memory.getValue(actualPath);\n    }\n\n    setValue(path: string, input: any) {\n        this._memory.setValue(path, input);\n    }\n\n    version(): string {\n        return this._memory.version();\n    }\n}\n\n/**\n * Holds global settings that can be used to customize the way templates are expanded.\n */\nexport class GlobalSettings {\n    /**\n     * Callback invoked when expression evaluation needs the value of a field in the source data object\n     * and that field is undefined or null. By default, expression evaluation will substitute an undefined\n     * field with its binding expression (e.g. `${field}`). This callback makes it possible to customize that\n     * behavior.\n     * \n     * **Example**\n     * Given this data object:\n     * \n     * ```json\n     * {\n     *     firstName: \"David\"\n     * }\n     * ```\n     * \n     * The expression `${firstName} ${lastName}` will evaluate to \"David ${lastName}\" because the `lastName`\n     * field is undefined.\n     * \n     * Now let's set the callback:\n     * ```typescript\n     * GlobalSettings.getUndefinedFieldValueSubstitutionString = (path: string) => { return \"<undefined value>\"; }\n     * ```\n     * \n     * With that, the above expression will evaluate to \"David &lt;undefined value&gt;\"\n     */\n    static getUndefinedFieldValueSubstitutionString?: (path: string) => string | undefined = undefined;\n}\n\n/**\n * Holds the context used to expand a template.\n */\nexport interface IEvaluationContext {\n    /**\n     * The root data object the template will bind to. Expressions that refer to $root in the template payload\n     * map to this field. Initially, $data also maps to $root.\n     */\n    $root: any\n}\n\n/**\n * Represents a template that can be bound to data.\n */\nexport class Template {\n    private static prepare(node: any): any {\n        if (typeof node === \"string\") {\n            return Template.parseInterpolatedString(node);\n        }\n        else if (typeof node === \"object\" && node !== null) {\n            if (Array.isArray(node)) {\n                let result: any[] = [];\n\n                for (let item of node) {\n                    result.push(Template.prepare(item));\n                }\n\n                return result;\n            }\n            else {\n                let keys = Object.keys(node);\n                let result = {};\n\n                for (let key of keys) {\n                    result[key] = Template.prepare(node[key]);\n                }\n\n                return result;\n            }\n        }\n        else {\n            return node;\n        }\n    }\n\n    private static internalTryEvaluateExpression(expression: AEL.Expression, context: EvaluationContext, allowSubstitutions: boolean): { value: any; error: string } {\n        let memory = new TemplateObjectMemory();\n        memory.$root = context.$root;\n        memory.$data = context.$data;\n        memory.$index = context.$index;\n\n        let options: AEL.Options | undefined = undefined;\n\n        if (allowSubstitutions) {\n            options = new AEL.Options();\n            options.nullSubstitution = (path: string) => {\n                let substitutionValue: string | undefined = undefined;\n\n                if (GlobalSettings.getUndefinedFieldValueSubstitutionString) {\n                    substitutionValue = GlobalSettings.getUndefinedFieldValueSubstitutionString(path);    \n                }\n        \n                return substitutionValue ? substitutionValue : \"${\" + path + \"}\";\n            }\n        }\n\n        // The root of an expression coming from an interpolated string is of type Concat.\n        // In that case, and if the caller allows it, we're doing our own concatenation\n        // in order to catch each individual expression evaluation error and substitute in\n        // the final string\n        if (expression.type === AEL.ExpressionType.Concat && allowSubstitutions) {\n            let result = \"\";\n\n            for (let childExpression of expression.children) {\n                let evaluationResult: { value: any; error: string };\n                \n                try {\n                    evaluationResult = childExpression.tryEvaluate(memory, options);\n                }\n                catch (ex) {\n                    // We'll swallow all exceptions here\n                    evaluationResult = {\n                        value: undefined,\n                        error: ex\n                    };\n                }\n\n                if (evaluationResult.error) {\n                    evaluationResult.value = \"${\" + childExpression.toString() + \"}\";\n                }\n\n                result += evaluationResult.value.toString();\n            }\n\n            return { value: result, error: undefined };\n        }\n        \n        return expression.tryEvaluate(memory, options);\n    }\n\n    /**\n     * Parses an interpolated string into an Expression object ready to evaluate.\n     * \n     * @param interpolatedString The interpolated string to parse. Example: \"Hello ${name}\"\n     * @returns An Expression object if the provided interpolated string contained at least one expression (e.g. \"${expression}\"); the original string otherwise.\n     */\n    public static parseInterpolatedString(interpolatedString: string): AEL.Expression | string {\n        let lookup: AEL.EvaluatorLookup = (type: string) => {\n            let standardFunction = AEL.ExpressionFunctions.standardFunctions.get(type);\n\n            if (standardFunction) {\n                return standardFunction;\n            }\n            else {\n                return new AEL.ExpressionEvaluator(\n                    type,\n                    (expression: AEL.Expression, state: AEL.MemoryInterface, options: AEL.Options) => { throw new Error(\"Unknown function \" + type); },\n                    AEL.ReturnType.String);\n            }\n        }\n\n        // If there is at least one expression start marker, let's attempt to convert into an expression\n        if (interpolatedString.indexOf(\"${\") >= 0) {\n            let parsedExpression = AEL.Expression.parse(\"`\" + interpolatedString + \"`\", lookup);\n\n            if (parsedExpression.type === \"concat\") {\n                if (parsedExpression.children.length === 1 && !(parsedExpression.children[0] instanceof AEL.Constant)) {\n                    // The concat contains a single child that isn't a constant, thus the original\n                    // string was a single expression. When evaluated, we want it to produce the type\n                    // of that single expression\n                    return parsedExpression.children[0];\n                }\n                else if (parsedExpression.children.length === 2) {\n                    let firstChild = parsedExpression.children[0];\n\n                    if (firstChild instanceof AEL.Constant && firstChild.value === \"\" && !(parsedExpression.children[1] instanceof AEL.Constant)) {\n                        // The concat contains 2 children, and the first one is an empty string constant and the second isn't a constant.\n                        // From version 4.10.3, AEL always inserts an empty string constant in all concat expression. Thus the original\n                        // string was a single expression in this case as well. When evaluated, we want it to produce the type\n                        // of that single expression.\n                        return parsedExpression.children[1];\n                    }\n                }\n\n                // Otherwise, we want the expression to produce a string\n                return parsedExpression;\n            }\n        }\n\n        // If the original string didn't contain any expression, return i as is\n        return interpolatedString;\n    }\n\n    /**\n     * Tries to evaluate the provided expression using the provided context.\n     * \n     * @param expression The expression to evaluate.\n     * @param context The context (data) used to evaluate the expression.\n     * @param allowSubstitutions Indicates if the expression evaluator should substitute undefined value with a default\n     *   string or the value returned by the GlobalSettings.getUndefinedFieldValueSubstitutionString callback.\n     * @returns An object representing the result of the evaluation. If the evaluation succeeded, the value property\n     *   contains the actual evaluation result, and the error property is undefined. If the evaluation fails, the error\n     *   property contains a message detailing the error that occurred.\n     */\n    public static tryEvaluateExpression(expression: AEL.Expression, context: IEvaluationContext, allowSubstitutions: boolean): { value: any; error: string } {\n        return Template.internalTryEvaluateExpression(expression, new EvaluationContext(context), allowSubstitutions);\n    }\n\n    private _context: EvaluationContext;\n    private _preparedPayload: any;\n\n    private expandSingleObject(node: object): any {\n        let result = {};\n        let keys = Object.keys(node);\n\n        for (let key of keys) {\n            if (!this._context.isReservedField(key)) {\n                let value = this.internalExpand(node[key]);\n\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private internalExpand(node: any): any {\n        let result: any;\n\n        this._context.saveState();\n\n        if (Array.isArray(node)) {\n            let itemArray: any[] = [];\n\n            for (let item of node) {\n                let expandedItem = this.internalExpand(item);\n\n                if (expandedItem !== null) {\n                    if (Array.isArray(expandedItem)) {\n                        itemArray = itemArray.concat(expandedItem);\n                    }\n                    else {\n                        itemArray.push(expandedItem);\n                    }\n                }\n            }\n\n            result = itemArray;\n        }\n        else if (node instanceof AEL.Expression) {\n            let evaluationResult = Template.internalTryEvaluateExpression(node, this._context, true);\n\n            if (!evaluationResult.error) {\n                result = evaluationResult.value;\n            }\n            else {\n                throw new Error(evaluationResult.error);\n            }\n        }\n        else if (typeof node === \"object\" && node !== null) {\n            let when = node[\"$when\"];\n            let dataContext = node[\"$data\"];\n            let dataContextIsArray: boolean = false;\n            let dataContexts: any[];\n\n            if (dataContext === undefined) {\n                dataContexts = [ undefined ];\n            }\n            else {\n                if (dataContext instanceof AEL.Expression) {\n                    let evaluationResult = Template.internalTryEvaluateExpression(dataContext, this._context, true);\n\n                    if (!evaluationResult.error) {\n                        dataContext = evaluationResult.value;\n                    }\n                    else {\n                        throw new Error(evaluationResult.error);\n                    }\n                }\n\n                if (Array.isArray(dataContext)) {\n                    dataContexts = dataContext;\n                    dataContextIsArray = true;\n                }\n                else {\n                    dataContexts = [ dataContext ];\n                }\n            }\n\n            result = [];\n\n            for (let i = 0; i < dataContexts.length; i++) {\n                if (dataContextIsArray) {\n                    this._context.$index = i;\n                }\n\n                if (dataContexts[i] !== undefined) {\n                    this._context.$data = dataContexts[i];\n                }\n\n                let dropObject = false;\n\n                if (when instanceof AEL.Expression) {\n                    let evaluationResult = Template.internalTryEvaluateExpression(when, this._context, false);\n                    let whenValue: boolean = false;\n                    \n                    // If $when fails to evaluate or evaluates to anything but a boolean, consider it is false\n                    if (!evaluationResult.error) {\n                        whenValue = typeof evaluationResult.value === \"boolean\" && evaluationResult.value;\n                    }\n\n                    dropObject = !whenValue;\n                }\n\n                if (!dropObject) {\n                    let expandedObject = this.expandSingleObject(node);\n\n                    if (expandedObject !== null) {\n                        result.push(expandedObject);\n                    }\n                }\n            }\n\n            if (result.length === 0) {\n                result = null;\n            }\n            else if (result.length === 1) {\n                result = result[0];\n            }\n        }\n        else {\n            result = node;\n        }\n\n        this._context.restoreLastState();\n\n        return result;\n    }\n\n    /**\n     * Initializes a new Template instance based on the provided payload.\n     * Once created, the instance can be bound to different data objects\n     * in a loop.\n     * \n     * @param payload The template payload.  \n     */\n    constructor(payload: any) {\n        this._preparedPayload = Template.prepare(payload);\n    }\n\n    /**\n     * Expands the template using the provided context. Template expansion involves\n     * evaluating the expressions used in the original template payload, as well as\n     * repeating (expanding) parts of that payload that are bound to arrays.\n     * \n     * Example:\n     * \n     * ```typescript\n     * let context = {\n     *     $root: {\n     *         firstName: \"John\",\n     *         lastName: \"Doe\",\n     *         children: [\n     *             { fullName: \"Jane Doe\", age: 9 },\n     *             { fullName: \"Alex Doe\", age: 12 }\n     *         ]\n     *     }\n     * }\n     * \n     * let templatePayload = {\n     *     type: \"AdaptiveCard\",\n     *     version: \"1.2\",\n     *     body: [\n     *         {\n     *             type: \"TextBlock\",\n     *             text: \"${firstName} ${lastName}\"\n     *         },\n     *         {\n     *             type: \"TextBlock\",\n     *             $data: \"${children}\",\n     *             text: \"${fullName} (${age})\"\n     *         }\n     *     ]\n     * }\n     * \n     * let template = new Template(templatePayload);\n     * \n     * let expandedTemplate = template.expand(context);\n     * ```\n     * \n     * With the above code, the value of `expandedTemplate` will be\n     * \n     * ```json\n     * {\n     *     type: \"AdaptiveCard\",\n     *     version: \"1.2\",\n     *     body: [\n     *         {\n     *             type: \"TextBlock\",\n     *             text: \"John Doe\"\n     *         },\n     *         {\n     *             type: \"TextBlock\",\n     *             text: \"Jane Doe (9)\"\n     *         },\n     *         {\n     *             type: \"TextBlock\",\n     *             text: \"Alex Doe (12)\"\n     *         }\n     *     ]\n     * }\n     * ```\n     * \n     * @param context The context to bind the template to.\n     * @returns A value representing the expanded template. The type of that value\n     *   is dependent on the type of the original template payload passed to the constructor.\n     */\n    expand(context: IEvaluationContext): any {\n        this._context = new EvaluationContext(context);\n\n        return this.internalExpand(this._preparedPayload);\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__248__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(716);\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__248__","JSONSchemaCardElement","schema","path","depth","type","Array","isArray","items","JSONSchemaFieldTitle","map","item","idx","JSONSchemaCardTuple","JSONSchemaCardList","JSONSchemaCardObject","id","title","label","description","value","default","JSONSchemaCardBoolean","placeholder","min","exclusiveMinimum","minimum","max","exclusiveMaximum","maximum","JSONSchemaCardNumber","enum","choices","JSONSchemaCardChoiceSet","maxLength","regex","pattern","JSONSchemaCardText","JSONSchemaCardTime","size","textSizeAtDepth","text","isSubtle","wrap","required","property","properties","encodeURIComponent","replace","encodeProperty","body","e","console","error","context","_stateStack","undefined","$root","isReservedField","name","EvaluationContext","_reservedFields","indexOf","saveState","push","$data","$index","restoreLastState","length","Error","savedContext","pop","_$data","_memory","AEL","SimpleObjectMemory","getValue","actualPath","setValue","input","version","getUndefinedFieldValueSubstitutionString","GlobalSettings","payload","_preparedPayload","Template","prepare","node","parseInterpolatedString","result","Object","keys","key","internalTryEvaluateExpression","expression","allowSubstitutions","memory","TemplateObjectMemory","options","Options","nullSubstitution","substitutionValue","ExpressionType","Concat","children","childExpression","evaluationResult","tryEvaluate","ex","toString","interpolatedString","parsedExpression","Expression","parse","ExpressionFunctions","standardFunctions","get","ExpressionEvaluator","state","ReturnType","String","Constant","firstChild","tryEvaluateExpression","expandSingleObject","_context","internalExpand","itemArray","expandedItem","concat","when","dataContext","dataContextIsArray","dataContexts","i","dropObject","whenValue","expandedObject","expand","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}