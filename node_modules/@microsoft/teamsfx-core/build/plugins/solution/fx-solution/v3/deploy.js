"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = exports.getQuestionsForDeploy = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const executor_1 = require("../v2/executor");
const questions_1 = require("../../utils/questions");
const utils_1 = require("./utils");
async function getQuestionsForDeploy(ctx, inputs, envInfo, tokenProvider) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const root = questions_1.createSelectModulesToDeployQuestionNode(solutionSetting.modules);
    let i = 0;
    for (const module of solutionSetting.modules) {
        const pluginName = module.hostingPlugin;
        if (pluginName) {
            const plugin = typedi_1.Container.get(pluginName);
            if (plugin.deploy && plugin.getQuestionsForDeploy) {
                const res = await plugin.getQuestionsForDeploy(ctx, inputs, envInfo, tokenProvider);
                if (res.isErr()) {
                    return res;
                }
                if (res.value) {
                    const node = res.value;
                    if (node && node.data) {
                        node.condition = { contains: i + "" };
                        root.addChild(node);
                    }
                }
            }
        }
        ++i;
    }
    return teamsfx_api_1.ok(root);
}
exports.getQuestionsForDeploy = getQuestionsForDeploy;
async function deploy(ctx, inputs, envInfo, tokenProvider) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const plugins = [];
    for (const moduleIndex of inputs.modules) {
        const module = utils_1.getModule(solutionSetting, moduleIndex);
        if (module && module.hostingPlugin) {
            const plugin = typedi_1.Container.get(module.hostingPlugin);
            plugins.push(plugin);
        }
    }
    const thunks = plugins.map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "deploy",
            thunk: () => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return plugin.deploy(ctx, inputs, envInfo, tokenProvider.azureAccountProvider);
            },
        };
    });
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.SelectedPluginsToDeployNotice, constants_1.PluginDisplayName.Solution, JSON.stringify(thunks.map((p) => p.pluginName))));
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.DeployStartNotice, constants_1.PluginDisplayName.Solution));
    const result = await executor_1.executeConcurrently(thunks, ctx.logProvider);
    if (result.kind === "success") {
        const msg = util.format(`Success: ${tools_1.getStrings().solution.DeploySuccessNotice}`, ctx.projectSetting.appName);
        ctx.logProvider.info(msg);
        ctx.userInteraction.showMessage("info", msg, false);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    else {
        const msg = util.format(tools_1.getStrings().solution.DeployFailNotice, ctx.projectSetting.appName);
        ctx.logProvider.info(msg);
        return teamsfx_api_1.err(result.error);
    }
}
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map