"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionResources = exports.getQuestionsForProvision = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const arm_1 = tslib_1.__importDefault(require("../arm"));
const executor_1 = require("../v2/executor");
const utils_1 = require("../v2/utils");
async function getQuestionsForProvision(ctx, inputs, tokenProvider, envInfo) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const root = new teamsfx_api_1.QTreeNode({ type: "group" });
    for (const pluginName of solutionSetting.activeResourcePlugins) {
        const plugin = typedi_1.Container.get(pluginName);
        if (plugin.getQuestionsForProvision) {
            const res = await plugin.getQuestionsForProvision(ctx, inputs, tokenProvider, envInfo);
            if (res.isErr()) {
                return res;
            }
            if (res.value) {
                const node = res.value;
                if (node && node.data) {
                    root.addChild(node);
                }
            }
        }
    }
    return teamsfx_api_1.ok(root);
}
exports.getQuestionsForProvision = getQuestionsForProvision;
async function provisionResources(ctx, inputs, envInfo, tokenProvider) {
    // Just to trigger M365 login before the concurrent execution of provision.
    // await tokenProvider.appStudioToken.getAccessToken();
    // 1. check AAD permission request
    // 2. ask common question and fill in solution config
    // 3. ask for provision consent
    // 4. collect plugins
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const plugins = solutionSetting.activeResourcePlugins.map((p) => typedi_1.Container.get(p));
    const provisionThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.provisionResource))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "provisionResource",
            thunk: () => {
                if (!envInfo.state[plugin.name]) {
                    envInfo.state[plugin.name] = {};
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return plugin.provisionResource(ctx, inputs, envInfo, tokenProvider);
            },
        };
    });
    // call provisionResources and collect outputs
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.ProvisionStartNotice, constants_1.PluginDisplayName.Solution));
    const provisionResult = await executor_1.executeConcurrently(provisionThunks, ctx.logProvider);
    if (provisionResult.kind === "failure" || provisionResult.kind === "partialSuccess") {
        return teamsfx_api_1.err(provisionResult.error);
    }
    else {
        const update = utils_1.combineRecords(provisionResult.output);
        lodash_1.assign(envInfo.state, update);
    }
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.ProvisionFinishNotice, constants_1.PluginDisplayName.Solution));
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.DeployArmTemplates.StartNotice, constants_1.PluginDisplayName.Solution));
    //uncomment the following lines when resource plugin is ready.
    const armRes = await arm_1.default.deployArmTemplates(ctx, inputs, envInfo, tokenProvider.azureAccountProvider);
    if (armRes.isErr()) {
        return teamsfx_api_1.err(armRes.error);
    }
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.DeployArmTemplates.SuccessNotice, constants_1.PluginDisplayName.Solution));
    // call aad.setApplicationInContext
    ctx.logProvider.info(util.format("AAD.setApplicationInContext", constants_1.PluginDisplayName.Solution));
    const configureResourceThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.configureResource))
        .map((plugin) => {
        if (!envInfo.state[plugin.name]) {
            envInfo.state[plugin.name] = {};
        }
        return {
            pluginName: `${plugin.name}`,
            taskName: "configureResource",
            thunk: () => 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            plugin.configureResource(ctx, inputs, envInfo, tokenProvider),
        };
    });
    //call configResource
    const configureResourceResult = await executor_1.executeConcurrently(configureResourceThunks, ctx.logProvider);
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.ConfigurationFinishNotice, constants_1.PluginDisplayName.Solution));
    const envStates = envInfo.state;
    if (configureResourceResult.kind === "failure" ||
        configureResourceResult.kind === "partialSuccess") {
        const msg = util.format(tools_1.getStrings().solution.ProvisionFailNotice, ctx.projectSetting.appName);
        ctx.logProvider.error(msg);
        envStates.solution.provisionSucceeded = false;
        return teamsfx_api_1.err(configureResourceResult.error);
    }
    const url = tools_1.getResourceGroupInPortal(envStates.solution.subscriptionId, envStates.solution.tenantId, envStates.solution.resourceGroupName);
    const msg = util.format(`Success: ${tools_1.getStrings().solution.ProvisionSuccessNotice}`, ctx.projectSetting.appName);
    ctx.logProvider.info(msg);
    if (url) {
        const title = "View Provisioned Resources";
        ctx.userInteraction.showMessage("info", msg, false, title).then((result) => {
            const userSelected = result.isOk() ? result.value : undefined;
            if (userSelected === title) {
                ctx.userInteraction.openUrl(url);
            }
        });
    }
    else {
        ctx.userInteraction.showMessage("info", msg, false);
    }
    return teamsfx_api_1.ok(envInfo);
}
exports.provisionResources = provisionResources;
//# sourceMappingURL=provision.js.map