// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalCertificateManager = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const node_forge_1 = require("node-forge");
const os = tslib_1.__importStar(require("os"));
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const ps = tslib_1.__importStar(require("./process"));
const installText = "Install";
const learnMoreText = "Learn More";
const learnMoreUrl = "https://aka.ms/teamsfx-ca-certificate";
const warningMessage = 'To debug applications in Teams, your localhost server must be on HTTPS.\
 For Teams to trust the self-signed SSL certificate used by the toolkit, a self-signed certificate must be added to your certificate store.\
 You may skip this step, but you\'ll have to manually trust the secure connection in a new browser window when debugging your apps in Teams.\
 For more information "https://aka.ms/teamsfx-ca-certificate".';
const confirmMessage = warningMessage +
    " You may be asked for your account credentials when installing the certificate.";
class LocalCertificateManager {
    constructor(ctx, inputs) {
        this.ui = ctx === null || ctx === void 0 ? void 0 : ctx.userInteraction;
        this.logger = ctx === null || ctx === void 0 ? void 0 : ctx.logProvider;
        this.platform = inputs.platform;
        this.certFolder = `${os.homedir()}/.${teamsfx_api_1.ConfigFolderName}/certificate`;
    }
    /**
     * Local certificates are located at {home}/.fx/certificate/
     * Public certificate should be trusted into user"s certificate store.
     *
     * - Check and generate cert and key files (subject, usage, expiration, ...)
     * - Check cert store if trusted (thumbprint, expiration)
     * - Add to cert store if not trusted (friendly name as well)
     */
    async setupCertificate(needTrust) {
        var _a;
        const certFilePath = `${this.certFolder}/${constants_1.LocalDebugCertificate.CertFileName}`;
        const keyFilePath = `${this.certFolder}/${constants_1.LocalDebugCertificate.KeyFileName}`;
        const localCert = {
            certPath: certFilePath,
            keyPath: keyFilePath,
            isTrusted: false,
        };
        let certThumbprint = undefined;
        await fs.ensureDir(this.certFolder);
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info("Detecting/Verifying local certificate.");
        if ((await fs.pathExists(certFilePath)) && (await fs.pathExists(keyFilePath))) {
            const certContent = await fs.readFile(certFilePath, { encoding: "utf8" });
            const keyContent = await fs.readFile(keyFilePath, { encoding: "utf8" });
            const verifyRes = this.verifyCertificateContent(certContent, keyContent);
            if (verifyRes[1]) {
                certThumbprint = verifyRes[0];
            }
        }
        if (!certThumbprint) {
            // generate cert and key
            certThumbprint = await this.generateCertificate(certFilePath, keyFilePath);
        }
        if (needTrust) {
            if (certThumbprint && (await this.verifyCertificateInStore(certThumbprint))) {
                // already trusted
                localCert.isTrusted = true;
            }
            else {
                localCert.isTrusted = await this.trustCertificate(certFilePath, certThumbprint, constants_1.LocalDebugCertificate.FriendlyName);
            }
        }
        return localCert;
    }
    async generateCertificate(certFile, keyFile) {
        var _a;
        // prepare attributes and extensions
        const now = new Date();
        const expiry = new Date();
        expiry.setFullYear(expiry.getFullYear() + 1);
        const serialNumber = uuid_1.v4().replace(/-/g, "");
        const attrs = [
            {
                name: "commonName",
                value: "localhost",
            },
        ];
        const exts = [
            {
                name: "basicConstraints",
                cA: false,
            },
            {
                name: "extKeyUsage",
                serverAuth: true,
            },
            {
                name: "subjectAltName",
                altNames: [
                    {
                        type: 2,
                        value: "localhost",
                    },
                ],
            },
        ];
        // generate key and cert
        const keys = node_forge_1.pki.rsa.generateKeyPair({
            bits: 4096,
            algorithm: "sha256",
        });
        const cert = node_forge_1.pki.createCertificate();
        cert.publicKey = keys.publicKey;
        cert.serialNumber = serialNumber;
        cert.validity.notBefore = now;
        cert.validity.notAfter = expiry;
        cert.setSubject(attrs);
        cert.setIssuer(attrs);
        cert.setExtensions(exts);
        cert.sign(keys.privateKey, node_forge_1.md.sha256.create());
        // get thumbprint
        const der = node_forge_1.asn1.toDer(node_forge_1.pki.certificateToAsn1(cert)).getBytes();
        const m = node_forge_1.md.sha1.create();
        m.update(der);
        const thumbprint = m.digest().toHex();
        // output
        const certContent = node_forge_1.pki.certificateToPem(cert);
        const keyContent = node_forge_1.pki.privateKeyToPem(keys.privateKey);
        await fs.writeFile(certFile, certContent, { encoding: "utf8" });
        await fs.writeFile(keyFile, keyContent, { encoding: "utf8" });
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`Local certificate generated to ${certFile}`);
        return thumbprint;
    }
    verifyCertificateContent(certContent, keyContent) {
        const thumbprint = undefined;
        try {
            const cert = node_forge_1.pki.certificateFromPem(certContent);
            const privateKey = node_forge_1.pki.privateKeyFromPem(keyContent);
            // get thumbprint
            const der = node_forge_1.asn1.toDer(node_forge_1.pki.certificateToAsn1(cert)).getBytes();
            const m = node_forge_1.md.sha1.create();
            m.update(der);
            const thumbprint = m.digest().toHex();
            // verify key pair
            const expectedPublicKey = node_forge_1.pki.rsa.setPublicKey(privateKey.n, privateKey.e);
            if (node_forge_1.pki.publicKeyToPem(expectedPublicKey) !== node_forge_1.pki.publicKeyToPem(cert.publicKey)) {
                return [thumbprint, false];
            }
            // verify subject and issuer
            const subject = cert.subject.getField("CN");
            if ("localhost" !== subject.value) {
                return [thumbprint, false];
            }
            const issuer = cert.issuer.getField("CN");
            if ("localhost" !== issuer.value) {
                return [thumbprint, false];
            }
            // verify date, add one day buffer
            const now = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const notBefore = cert.validity.notBefore;
            const notAfter = cert.validity.notAfter;
            if (notBefore > now || notAfter < tomorrow) {
                return [thumbprint, false];
            }
            // verify extension
            const basicConstraints = cert.getExtension("basicConstraints");
            if (basicConstraints === undefined ||
                basicConstraints.cA === undefined ||
                basicConstraints.cA) {
                return [thumbprint, false];
            }
            const extKeyUsage = cert.getExtension("extKeyUsage");
            if (extKeyUsage === undefined ||
                extKeyUsage.serverAuth === undefined ||
                !extKeyUsage.serverAuth) {
                return [thumbprint, false];
            }
            const subjectAltName = cert.getExtension("subjectAltName");
            if (subjectAltName === undefined ||
                subjectAltName.altNames === undefined ||
                !subjectAltName.altNames.some((a) => a.type === 2 && a.value === "localhost")) {
                return [thumbprint, false];
            }
            return [thumbprint, true];
        }
        catch (error) {
            // treat any error as not verified, to not block the main progress
            return [thumbprint, false];
        }
    }
    async verifyCertificateInStore(thumbprint) {
        var _a;
        try {
            if (os.type() === "Windows_NT") {
                const getCertCommand = `(Get-ChildItem -Path Cert:\\CurrentUser\\Root | Where-Object { $_.Thumbprint -match '${thumbprint}' }).Thumbprint`;
                const existingThumbprint = (await ps.execPowerShell(getCertCommand)).trim();
                return existingThumbprint.toUpperCase() === thumbprint.toUpperCase();
            }
            else if (os.type() === "Darwin") {
                const listCertCommand = `security find-certificate -c localhost -a -Z -p "${os.homedir()}/Library/Keychains/login.keychain-db"`;
                const existingCertificates = await ps.execShell(listCertCommand);
                if (existingCertificates) {
                    const thumbprintRegex = /SHA-1 hash: ([0-9A-Z]+)/g;
                    let match = undefined;
                    while ((match = thumbprintRegex.exec(existingCertificates))) {
                        const existingThumbprint = match[1];
                        if (existingThumbprint.toUpperCase() === thumbprint.toUpperCase()) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else {
                // TODO: Linux
                return false;
            }
        }
        catch (error) {
            // treat any error as not verified, to not block the main progress
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Certificate unverified. Details: ${error}`);
            return false;
        }
    }
    async trustCertificate(certPath, thumbprint, friendlyName) {
        var _a;
        try {
            if (os.type() === "Windows_NT") {
                if (!(await this.waitForUserConfirm())) {
                    return false;
                }
                const installCertCommand = `(Import-Certificate -FilePath '${certPath}' -CertStoreLocation Cert:\\CurrentUser\\Root)[0].Thumbprint`;
                const thumbprint = (await ps.execPowerShell(installCertCommand)).trim();
                const friendlyNameCommand = `(Get-ChildItem -Path Cert:\\CurrentUser\\Root\\${thumbprint}).FriendlyName='${friendlyName}'`;
                await ps.execPowerShell(friendlyNameCommand);
                return true;
            }
            else if (os.type() === "Darwin") {
                if (!(await this.waitForUserConfirm())) {
                    return false;
                }
                await ps.execShell(`security add-trusted-cert -p ssl -k "${os.homedir()}/Library/Keychains/login.keychain-db" "${certPath}"`);
                return true;
            }
            else {
                // TODO: Linux
                return false;
            }
        }
        catch (error) {
            // treat any error as install failure, to not block the main progress
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warning(`Failed to install certificate. Error: ${error}`);
            return false;
        }
    }
    showWarningMessage() {
        if (this.ui) {
            if (this.platform === teamsfx_api_1.Platform.CLI) {
                // no user interaction for CLI
                this.ui.showMessage("warn", warningMessage, false);
            }
            else {
                this.ui.showMessage("warn", warningMessage, false, learnMoreText).then((result) => {
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === learnMoreText) {
                        this.ui.openUrl(learnMoreUrl);
                    }
                });
            }
        }
    }
    async waitForUserConfirm() {
        if (this.ui) {
            let userSelected;
            do {
                const res = await this.ui.showMessage("info", confirmMessage, true, learnMoreText, installText);
                userSelected = res.isOk() ? res.value : undefined;
                if (userSelected === learnMoreText) {
                    this.ui.openUrl(learnMoreUrl);
                }
            } while (userSelected === learnMoreText);
            return userSelected === installText;
        }
        // No dialog, always return true;
        return true;
    }
}
exports.LocalCertificateManager = LocalCertificateManager;
//# sourceMappingURL=certificate.js.map