"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsAppSolution = exports.SolutionRunningState = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../../common/constants");
const localSettingsConstants_1 = require("../../../common/localSettingsConstants");
const tools_1 = require("../../../common/tools");
const core_1 = require("../../../core");
const errorHandler_1 = require("../../../core/middleware/errorHandler");
const permissionRequest_1 = require("../../../core/permissionRequest");
const SolutionPluginContainer_1 = require("../../../core/SolutionPluginContainer");
const resource_1 = require("../../resource");
const arm_1 = require("./arm");
const commonQuestions_1 = require("./commonQuestions");
const constants_2 = require("./constants");
const executor_1 = require("./executor");
const question_1 = require("./question");
const ResourcePluginContainer_1 = require("./ResourcePluginContainer");
const util_1 = require("./utils/util");
const executeUserTask_1 = require("./v2/executeUserTask");
const utils_1 = require("./v2/utils");
const provision_1 = require("./v2/provision");
const grantPermission_1 = require("./v2/grantPermission");
const checkPermission_1 = require("./v2/checkPermission");
const listAllCollaborators_1 = require("./v2/listAllCollaborators");
const listCollaborator_1 = require("./v2/listCollaborator");
const scaffolding_1 = require("./v2/scaffolding");
const telemetry_1 = require("../../../common/telemetry");
const _1 = require(".");
const scaffolding_2 = require("./debug/scaffolding");
// Maybe we need a state machine to track state transition.
var SolutionRunningState;
(function (SolutionRunningState) {
    SolutionRunningState["Idle"] = "idle";
    SolutionRunningState["ProvisionInProgress"] = "ProvisionInProgress";
    SolutionRunningState["DeployInProgress"] = "DeployInProgress";
    SolutionRunningState["PublishInProgress"] = "PublishInProgress";
})(SolutionRunningState = exports.SolutionRunningState || (exports.SolutionRunningState = {}));
let TeamsAppSolution = class TeamsAppSolution {
    constructor() {
        this.name = "fx-solution-azure";
        this.SpfxPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.SpfxPlugin);
        this.AppStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.AppStudioPlugin);
        this.BotPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.BotPlugin);
        this.AadPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.AadPlugin);
        this.FrontendPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.FrontendPlugin);
        this.FunctionPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.FunctionPlugin);
        this.SqlPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.SqlPlugin);
        this.ApimPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.ApimPlugin);
        this.KeyVaultPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.KeyVaultPlugin);
        this.LocalDebugPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.LocalDebugPlugin);
        this.runningState = SolutionRunningState.Idle;
    }
    getPluginAndContextArray(ctx, selectedPlugins) {
        // let pluginContextConstructor = getPluginContextConstructor(ctx);
        return selectedPlugins.map((plugin) => [plugin, util_1.getPluginContext(ctx, plugin.name)]);
    }
    async init(ctx) {
        return teamsfx_api_1.ok({});
    }
    assertSettingsNotEmpty(settings, key) {
        if (!settings) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`${key} is undefined`), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        }
        return teamsfx_api_1.ok(settings);
    }
    async fillInV1SolutionSettings(ctx) {
        var _a;
        const assertList = [
            this.assertSettingsNotEmpty(ctx.answers, "answers"),
            this.assertSettingsNotEmpty(ctx.projectSettings, "projectSettings"),
            this.assertSettingsNotEmpty((_a = ctx === null || ctx === void 0 ? void 0 : ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings, "solutionSettings"),
        ];
        const assertRes = teamsfx_api_1.combine(assertList);
        if (assertRes.isErr()) {
            return teamsfx_api_1.err(assertRes.error);
        }
        const [answers, projectSettings, solutionSettingsSource] = assertRes.value;
        const isTypescriptProject = await fs.pathExists(path_1.default.join(ctx.root, teamsfx_api_1.ArchiveFolderName, "tsconfig.json"));
        projectSettings.programmingLanguage = isTypescriptProject ? "typescript" : "javascript";
        const capability = answers[question_1.AzureSolutionQuestionNames.V1Capability];
        if (!capability) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("capabilities is empty"), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        }
        const solutionSettings = {
            name: solutionSettingsSource.name,
            version: solutionSettingsSource.version,
            hostType: question_1.HostTypeOptionAzure.id,
            capabilities: [capability],
            azureResources: [],
            activeResourcePlugins: [],
            migrateFromV1: solutionSettingsSource === null || solutionSettingsSource === void 0 ? void 0 : solutionSettingsSource.migrateFromV1,
        };
        projectSettings.solutionSettings = solutionSettings;
        return teamsfx_api_1.ok(solutionSettings);
    }
    /**
     * create
     */
    async create(ctx) {
        var _a, _b, _c, _d;
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.CreateStart, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        });
        if (!ctx.projectSettings)
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionError.InternelError, "projectSettings undefined", constants_2.SolutionSource));
        // ensure that global namespace is present
        if (!ctx.envInfo.state.has(constants_2.GLOBAL_CONFIG)) {
            ctx.envInfo.state.set(constants_2.GLOBAL_CONFIG, new teamsfx_api_1.ConfigMap());
        }
        // Only non-SPFx project will ask this question.
        const lang = ctx.answers[question_1.AzureSolutionQuestionNames.ProgrammingLanguage];
        if (lang) {
            ctx.projectSettings.programmingLanguage = lang;
        }
        const solutionSettings = ctx.projectSettings.solutionSettings;
        const settingsRes = utils_1.fillInSolutionSettings(solutionSettings, ctx.answers);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.Create, settingsRes.error, ctx.telemetryReporter));
        }
        //Reload plugins according to user answers
        await this.reloadPlugins(solutionSettings);
        if (this.isAzureProject(ctx)) {
            await fs.writeJSON(`${ctx.root}/permissions.json`, constants_2.DEFAULT_PERMISSION_REQUEST, { spaces: 4 });
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.Create, {
                [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
                [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
                [constants_2.SolutionTelemetryProperty.Resources]: solutionSettings.azureResources.join(";"),
                [constants_2.SolutionTelemetryProperty.Capabilities]: solutionSettings.capabilities.join(";"),
                [constants_2.SolutionTelemetryProperty.ProgrammingLanguage]: (_d = (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.programmingLanguage) !== null && _d !== void 0 ? _d : "",
            });
        }
        return teamsfx_api_1.ok(constants_2.Void);
    }
    // Migrate
    async migrate(ctx) {
        var _a, _b, _c, _d;
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.MigrateStart, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        });
        // ensure that global namespace is present
        if (!ctx.envInfo.state.has(constants_2.GLOBAL_CONFIG)) {
            ctx.envInfo.state.set(constants_2.GLOBAL_CONFIG, new teamsfx_api_1.ConfigMap());
        }
        const settingsRes = await this.fillInV1SolutionSettings(ctx);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.Migrate, settingsRes.error, ctx.telemetryReporter));
        }
        const solutionSettings = settingsRes.value;
        const selectedPlugins = await this.reloadPlugins(solutionSettings);
        const scaffoldLocalDebugSettingResult = await scaffolding_2.scaffoldLocalDebugSettingsV1(ctx);
        if (scaffoldLocalDebugSettingResult.isErr()) {
            return scaffoldLocalDebugSettingResult;
        }
        const results = await Promise.all(selectedPlugins.map((migratePlugin) => {
            return this.executeUserTask({
                namespace: `${constants_2.PluginNames.SOLUTION}/${migratePlugin.name}`,
                method: "migrateV1Project",
                params: {},
            }, ctx);
        }));
        const errorResult = results.find((result) => {
            return result.isErr();
        });
        if (errorResult) {
            return errorResult;
        }
        const capabilities = ((_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.solutionSettings)
            .capabilities;
        const azureResources = ((_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.solutionSettings)
            .azureResources;
        await scaffolding_1.scaffoldReadme(capabilities, azureResources, ctx.root, true);
        (_d = ctx.telemetryReporter) === null || _d === void 0 ? void 0 : _d.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.Migrate, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
        });
        return teamsfx_api_1.ok(constants_2.Void);
    }
    reloadPlugins(solutionSettings) {
        const res = ResourcePluginContainer_1.getActivatedResourcePlugins(solutionSettings);
        solutionSettings.activeResourcePlugins = res.map((p) => p.name);
        return res;
    }
    spfxSelected(ctx) {
        // Generally, if SPFx is selected, there should be no other plugins. But we don't check this invariant here.
        const spfxExists = this.getAzureSolutionSettings(ctx).activeResourcePlugins.some((pluginName) => pluginName === this.SpfxPlugin.name);
        return spfxExists === undefined ? false : spfxExists;
    }
    isAzureProject(ctx) {
        if (!ctx)
            return true;
        const settings = this.getAzureSolutionSettings(ctx);
        return question_1.HostTypeOptionAzure.id === settings.hostType;
    }
    async update(ctx) {
        return await this.executeAddResource(ctx);
    }
    getSelectedPlugins(ctx) {
        const settings = this.getAzureSolutionSettings(ctx);
        const plugins = ResourcePluginContainer_1.getActivatedResourcePlugins(settings);
        settings.activeResourcePlugins = plugins.map((p) => p.name);
        return teamsfx_api_1.ok(plugins);
    }
    /**
     * scaffold
     */
    async scaffold(ctx) {
        var _a;
        const maybeSelectedPlugins = this.getSelectedPlugins(ctx);
        if (maybeSelectedPlugins.isErr()) {
            return maybeSelectedPlugins;
        }
        const selectedPlugins = maybeSelectedPlugins.value;
        const result = await this.doScaffold(ctx, selectedPlugins, true);
        if (result.isOk()) {
            (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", `Success: ${tools_1.getStrings().solution.ScaffoldSuccessNotice}`, false);
        }
        return result;
    }
    async doScaffold(ctx, pluginsToScaffold, generateResourceTemplate, pluginsToDoArm) {
        var _a, _b;
        const pluginsWithCtx = this.getPluginAndContextArray(ctx, pluginsToScaffold);
        const preScaffoldWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.preScaffold) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const scaffoldWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.scaffold) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const postScaffoldWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.postScaffold) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const res = await executor_1.executeLifecycles(preScaffoldWithCtx, scaffoldWithCtx, postScaffoldWithCtx);
        if (res.isOk()) {
            const capabilities = ((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings)
                .capabilities;
            const azureResources = ((_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.solutionSettings)
                .azureResources;
            await scaffolding_1.scaffoldReadme(capabilities, azureResources, ctx.root);
        }
        if (tools_1.isArmSupportEnabled() && generateResourceTemplate && this.isAzureProject(ctx)) {
            return await arm_1.generateArmTemplate(ctx, pluginsToDoArm ? pluginsToDoArm : pluginsToScaffold);
        }
        else {
            return res;
        }
    }
    async createEnv(ctx) {
        var _a;
        if (tools_1.isArmSupportEnabled() &&
            utils_1.isAzureProject(ctx.projectSettings.solutionSettings)) {
            try {
                if (ctx.answers.copy === true) {
                    await arm_1.copyParameterJson(ctx.root, ctx.projectSettings.appName, ctx.answers.targetEnvName, ctx.answers.sourceEnvName);
                }
                else {
                    await arm_1.getParameterJson(ctx);
                }
            }
            catch (e) {
                return teamsfx_api_1.err(core_1.CopyFileError(e));
            }
            return teamsfx_api_1.ok(ctx.answers.copy ? ctx.answers.targetEnvName : (_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.envName);
        }
        return teamsfx_api_1.ok(constants_2.Void);
    }
    /**
     * Checks whether solution's state is idle
     */
    checkWhetherSolutionIsIdle() {
        switch (this.runningState) {
            case SolutionRunningState.Idle:
                return teamsfx_api_1.ok(constants_2.Void);
            case SolutionRunningState.ProvisionInProgress:
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Provision in progress. Please wait for its completion."), constants_2.SolutionSource, constants_2.SolutionError.ProvisionInProgress));
            case SolutionRunningState.DeployInProgress:
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Deployment in progress. Please wait for its completion."), constants_2.SolutionSource, constants_2.SolutionError.DeploymentInProgress));
            case SolutionRunningState.PublishInProgress:
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Publish in progress. Please wait for its completion."), constants_2.SolutionSource, constants_2.SolutionError.PublishInProgress));
        }
    }
    checkWetherProvisionSucceeded(solutionConfig) {
        var _a;
        return !!((_a = solutionConfig.get(constants_2.GLOBAL_CONFIG)) === null || _a === void 0 ? void 0 : _a.getBoolean(constants_2.SOLUTION_PROVISION_SUCCEEDED));
    }
    /**
     * Provision resources. It can only run in a non-SPFx project when solution's running state is Idle.
     * Solution's provisionSucceeded config value will be set to true if provision succeeds, to false otherwise.
     *
     */
    async provision(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const canProvision = this.checkWhetherSolutionIsIdle();
        if (canProvision.isErr()) {
            return canProvision;
        }
        try {
            // Just to trigger M365 login before the concurrent execution of provision.
            // Because concurrent exectution of provision may getAccessToken() concurrently, which
            // causes 2 M365 logins before the token caching in common lib takes effect.
            await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
            this.runningState = SolutionRunningState.ProvisionInProgress;
            if (this.isAzureProject(ctx)) {
                if (ctx.permissionRequestProvider === undefined) {
                    ctx.permissionRequestProvider = new permissionRequest_1.PermissionRequestFileProvider(ctx.root);
                }
                const result = await utils_1.ensurePermissionRequest((_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.solutionSettings, ctx.permissionRequestProvider);
                if (result.isErr()) {
                    return result;
                }
            }
            const provisionResult = await this.doProvision(ctx);
            if (provisionResult.isOk()) {
                const url = tools_1.getResourceGroupInPortal((_c = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.getString(constants_2.SUBSCRIPTION_ID), (_d = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _d === void 0 ? void 0 : _d.getString("tenantId"), (_e = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _e === void 0 ? void 0 : _e.getString(constants_2.RESOURCE_GROUP_NAME));
                const msg = util.format(`Success: ${tools_1.getStrings().solution.ProvisionSuccessNotice}`, (_f = ctx.projectSettings) === null || _f === void 0 ? void 0 : _f.appName);
                (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(msg);
                if (url) {
                    const title = "View Provisioned Resources";
                    (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", msg, false, title).then((result) => {
                        const userSelected = result.isOk() ? result.value : undefined;
                        if (userSelected === title) {
                            ctx.ui.openUrl(url);
                        }
                    });
                }
                else {
                    (_j = ctx.ui) === null || _j === void 0 ? void 0 : _j.showMessage("info", msg, false);
                }
                (_k = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _k === void 0 ? void 0 : _k.set(constants_2.SOLUTION_PROVISION_SUCCEEDED, true);
                if (!this.isAzureProject(ctx) && tools_1.isMultiEnvEnabled()) {
                    const appStudioTokenJson = await ((_l = ctx.appStudioToken) === null || _l === void 0 ? void 0 : _l.getJsonObject());
                    (_m = ctx.envInfo.state
                        .get(constants_2.GLOBAL_CONFIG)) === null || _m === void 0 ? void 0 : _m.set(_1.REMOTE_TEAMS_APP_TENANT_ID, appStudioTokenJson.tid);
                }
            }
            else {
                if (!tools_1.isUserCancelError(provisionResult.error) &&
                    !tools_1.isCheckAccountError(provisionResult.error)) {
                    const msg = util.format(tools_1.getStrings().solution.ProvisionFailNotice, (_o = ctx.projectSettings) === null || _o === void 0 ? void 0 : _o.appName);
                    (_p = ctx.logProvider) === null || _p === void 0 ? void 0 : _p.error(msg);
                    (_q = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _q === void 0 ? void 0 : _q.set(constants_2.SOLUTION_PROVISION_SUCCEEDED, false);
                }
            }
            return provisionResult;
        }
        finally {
            this.runningState = SolutionRunningState.Idle;
        }
    }
    /**
     * provision
     */
    async doProvision(ctx) {
        var _a, _b;
        const maybeSelectedPlugins = this.getSelectedPlugins(ctx);
        if (maybeSelectedPlugins.isErr()) {
            return maybeSelectedPlugins;
        }
        const selectedPlugins = maybeSelectedPlugins.value;
        // Send config telemetry before actually doing anything.
        // If something fails, we can know whether it is related to the config.
        const redactedEnvConfig = tools_1.redactObject(ctx.envInfo.config, teamsfx_api_1.EnvConfigSchema);
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.EnvConfig, {
            [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(ctx.envInfo.envName),
            [telemetry_1.TelemetryProperty.EnvConfig]: JSON.stringify(redactedEnvConfig),
        });
        if (this.isAzureProject(ctx)) {
            //1. ask common questions for azure resources.
            const appName = ctx.projectSettings.appName;
            const res = await commonQuestions_1.fillInCommonQuestions(ctx, appName, ctx.envInfo.state, ctx.azureAccountProvider, await ((_b = ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getJsonObject()));
            if (res.isErr()) {
                return res;
            }
            const consentResult = await provision_1.askForProvisionConsent(ctx);
            if (consentResult.isErr()) {
                return consentResult;
            }
            // create resource group if needed
            const commonQuestionResult = res.value;
            if (commonQuestionResult.needCreateResourceGroup) {
                const maybeRgName = await commonQuestions_1.createNewResourceGroup(ctx.azureAccountProvider, commonQuestionResult.subscriptionId, commonQuestionResult.subscriptionName, commonQuestionResult.resourceGroupName, commonQuestionResult.location, ctx.logProvider);
                if (maybeRgName.isErr()) {
                    return teamsfx_api_1.err(maybeRgName.error);
                }
            }
        }
        const pluginsWithCtx = this.getPluginAndContextArray(ctx, selectedPlugins);
        const preProvisionWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.preProvision) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const provisionWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.provision) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const postProvisionWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.postProvision) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        return executor_1.executeLifecycles(preProvisionWithCtx, provisionWithCtx, postProvisionWithCtx, async () => {
            var _a;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util.format(tools_1.getStrings().solution.ProvisionStartNotice, constants_1.PluginDisplayName.Solution));
            return teamsfx_api_1.ok(undefined);
        }, async (provisionResults) => {
            var _a;
            if (!tools_1.isMultiEnvEnabled()) {
                if (provisionWithCtx.length === (provisionResults === null || provisionResults === void 0 ? void 0 : provisionResults.length)) {
                    provisionWithCtx.map(function (plugin, index) {
                        var _a;
                        if (plugin[2] === constants_2.PluginNames.APPST) {
                            const teamsAppResult = provisionResults[index];
                            if (teamsAppResult.isOk()) {
                                (_a = ctx.envInfo.state
                                    .get(constants_2.GLOBAL_CONFIG)) === null || _a === void 0 ? void 0 : _a.set(constants_2.REMOTE_TEAMS_APP_ID, teamsAppResult.value);
                            }
                        }
                    });
                }
            }
            if (provisionResults) {
                for (const result of provisionResults) {
                    if (result.isErr()) {
                        return result;
                    }
                }
            }
            if (tools_1.isArmSupportEnabled() && this.isAzureProject(ctx)) {
                const armDeploymentResult = await arm_1.deployArmTemplates(ctx);
                if (armDeploymentResult.isErr()) {
                    return armDeploymentResult;
                }
            }
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util.format(tools_1.getStrings().solution.ProvisionFinishNotice, constants_1.PluginDisplayName.Solution));
            const aadPlugin = this.AadPlugin;
            if (selectedPlugins.some((plugin) => plugin.name === aadPlugin.name)) {
                return await aadPlugin.executeUserTask({
                    namespace: `${constants_2.PluginNames.SOLUTION}/${constants_2.PluginNames.AAD}`,
                    method: "setApplicationInContext",
                    params: { isLocal: false },
                }, util_1.getPluginContext(ctx, aadPlugin.name));
            }
            return teamsfx_api_1.ok(undefined);
        }, async () => {
            var _a;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util.format(tools_1.getStrings().solution.ConfigurationFinishNotice, constants_1.PluginDisplayName.Solution));
            return teamsfx_api_1.ok(undefined);
        });
    }
    async deploy(ctx) {
        var _a, _b, _c, _d, _e, _f, _g;
        const isAzureProject = this.isAzureProject(ctx);
        const provisioned = this.checkWetherProvisionSucceeded(ctx.envInfo.state);
        if (isAzureProject && !provisioned) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(util.format(tools_1.getStrings().solution.NotProvisionedNotice, (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.appName)), constants_2.SolutionSource, constants_2.SolutionError.CannotDeployBeforeProvision));
        }
        try {
            if (this.isAzureProject(ctx)) {
                // Just to trigger M365 login before the concurrent execution of deploy.
                // Because concurrent exectution of deploy may getAccessToken() concurrently, which
                // causes 2 M365 logins before the token caching in common lib takes effect.
                const appStudioTokenJson = await ((_b = ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getJsonObject());
                const checkM365 = await commonQuestions_1.checkM365Tenant(ctx.envInfo, appStudioTokenJson);
                if (checkM365.isErr()) {
                    return checkM365;
                }
                const checkAzure = await commonQuestions_1.checkSubscription(ctx.envInfo, ctx.azureAccountProvider);
                if (checkAzure.isErr()) {
                    return checkAzure;
                }
            }
            this.runningState = SolutionRunningState.DeployInProgress;
            const result = await this.doDeploy(ctx);
            if (result.isOk()) {
                if (this.isAzureProject(ctx)) {
                    const msg = util.format(`Success: ${tools_1.getStrings().solution.DeploySuccessNotice}`, (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.appName);
                    (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(msg);
                    (_e = ctx.ui) === null || _e === void 0 ? void 0 : _e.showMessage("info", msg, false);
                }
            }
            else {
                const msg = util.format(tools_1.getStrings().solution.DeployFailNotice, (_f = ctx.projectSettings) === null || _f === void 0 ? void 0 : _f.appName);
                (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(msg);
            }
            return result;
        }
        finally {
            this.runningState = SolutionRunningState.Idle;
        }
    }
    /**
     * deploy
     */
    async doDeploy(ctx) {
        var _a, _b, _c;
        const res = this.getSelectedPlugins(ctx);
        if (res.isErr()) {
            return res;
        }
        const optionsToDeploy = ctx.answers[question_1.AzureSolutionQuestionNames.PluginSelectionDeploy];
        if (optionsToDeploy === undefined || optionsToDeploy.length === 0) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`No plugin selected`), constants_2.SolutionSource, constants_2.SolutionError.NoResourcePluginSelected));
        }
        const pluginMap = ResourcePluginContainer_1.getAllResourcePluginMap();
        const pluginsToDeploy = [];
        for (const optionId of optionsToDeploy) {
            const filtered = pluginMap.get(optionId);
            if (filtered && res.value.find((p) => p.name === filtered.name)) {
                pluginsToDeploy.push(filtered);
            }
        }
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util.format(tools_1.getStrings().solution.SelectedPluginsToDeployNotice, constants_1.PluginDisplayName.Solution, JSON.stringify(pluginsToDeploy.map((p) => p.name))));
        if (this.isAzureProject(ctx)) {
            //make sure sub is selected
            await ((_b = ctx.azureAccountProvider) === null || _b === void 0 ? void 0 : _b.getSelectedSubscription(true));
        }
        const pluginsWithCtx = this.getPluginAndContextArray(ctx, pluginsToDeploy);
        const preDeployWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.preDeploy) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const deployWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.deploy) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        const postDeployWithCtx = pluginsWithCtx.map(([plugin, context]) => {
            var _a;
            return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.postDeploy) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
        });
        (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(util.format(tools_1.getStrings().solution.DeployStartNotice, constants_1.PluginDisplayName.Solution));
        return executor_1.executeLifecycles(preDeployWithCtx, deployWithCtx, postDeployWithCtx);
    }
    async publish(ctx) {
        var _a, _b, _c, _d, _e;
        const checkRes = this.checkWhetherSolutionIsIdle();
        if (checkRes.isErr())
            return teamsfx_api_1.err(checkRes.error);
        const isAzureProject = this.isAzureProject(ctx);
        const provisioned = this.checkWetherProvisionSucceeded(ctx.envInfo.state);
        if (!provisioned) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(util.format(tools_1.getStrings().solution.NotProvisionedNotice, (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.appName)), constants_2.SolutionSource, constants_2.SolutionError.CannotPublishBeforeProvision));
        }
        try {
            const appStudioTokenJson = await ((_b = ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getJsonObject());
            const checkM365 = await commonQuestions_1.checkM365Tenant(ctx.envInfo, appStudioTokenJson);
            if (checkM365.isErr()) {
                return checkM365;
            }
            this.runningState = SolutionRunningState.PublishInProgress;
            const pluginsWithCtx = this.getPluginAndContextArray(ctx, [
                this.AppStudioPlugin,
            ]);
            const publishWithCtx = pluginsWithCtx.map(([plugin, context]) => {
                var _a;
                return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.publish) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
            });
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(util.format(tools_1.getStrings().solution.PublishStartNotice, constants_1.PluginDisplayName.Solution));
            const results = await executor_1.executeConcurrently("", publishWithCtx);
            for (const result of results) {
                if (result.isErr()) {
                    const msg = util.format(tools_1.getStrings().solution.PublishFailNotice, (_d = ctx.projectSettings) === null || _d === void 0 ? void 0 : _d.appName);
                    (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(msg);
                    return result;
                }
            }
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            this.runningState = SolutionRunningState.Idle;
        }
    }
    async getTabScaffoldQuestions(ctx, addAzureResource) {
        const tabNode = new teamsfx_api_1.QTreeNode({ type: "group" });
        //Frontend plugin
        const fehostPlugin = this.FrontendPlugin;
        if (fehostPlugin.getQuestions) {
            const pluginCtx = util_1.getPluginContext(ctx, fehostPlugin.name);
            const res = await fehostPlugin.getQuestions(teamsfx_api_1.Stage.create, pluginCtx);
            if (res.isErr())
                return res;
            if (res.value) {
                const frontendNode = res.value;
                if (frontendNode.data)
                    tabNode.addChild(frontendNode);
            }
        }
        if (addAzureResource) {
            const azureResourceNode = new teamsfx_api_1.QTreeNode(question_1.AzureResourcesQuestion);
            tabNode.addChild(azureResourceNode);
            const functionPlugin = this.FunctionPlugin;
            //Azure Function
            if (functionPlugin.getQuestions) {
                const pluginCtx = util_1.getPluginContext(ctx, functionPlugin.name);
                const res = await functionPlugin.getQuestions(teamsfx_api_1.Stage.create, pluginCtx);
                if (res.isErr())
                    return res;
                if (res.value) {
                    const azure_function = res.value;
                    azure_function.condition = { minItems: 1 };
                    if (azure_function.data)
                        azureResourceNode.addChild(azure_function);
                }
            }
            const sqlPlugin = this.SqlPlugin;
            //Azure SQL
            if (sqlPlugin.getQuestions) {
                const pluginCtx = util_1.getPluginContext(ctx, sqlPlugin.name);
                const res = await sqlPlugin.getQuestions(teamsfx_api_1.Stage.create, pluginCtx);
                if (res.isErr())
                    return res;
                if (res.value) {
                    const azure_sql = res.value;
                    azure_sql.condition = { contains: question_1.AzureResourceSQL.id };
                    if (azure_sql.data)
                        azureResourceNode.addChild(azure_sql);
                }
            }
        }
        return teamsfx_api_1.ok(tabNode);
    }
    /**
     * collect solution level question
     * @param ctx
     */
    async getQuestions(stage, ctx) {
        var _a;
        const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(ctx.answers.platform);
        const node = new teamsfx_api_1.QTreeNode({ type: "group" });
        if (stage !== teamsfx_api_1.Stage.create && isDynamicQuestion) {
            const checkRes = this.checkWhetherSolutionIsIdle();
            if (checkRes.isErr())
                return teamsfx_api_1.err(checkRes.error);
        }
        if (stage === teamsfx_api_1.Stage.create) {
            // 1. capabilities
            const capQuestion = question_1.createCapabilityQuestion();
            const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
            node.addChild(capNode);
            // 1.1 hostType
            //const hostTypeNode = new QTreeNode(FrontendHostTypeQuestion);
            //hostTypeNode.condition = { contains: TabOptionItem.id };
            //capNode.addChild(hostTypeNode);
            // 1.1.1 SPFX Tab
            const spfxPlugin = new resource_1.SpfxPlugin();
            if (spfxPlugin.getQuestions) {
                const pluginCtx = util_1.getPluginContext(ctx, spfxPlugin.name);
                const res = await spfxPlugin.getQuestions(teamsfx_api_1.Stage.create, pluginCtx);
                if (res.isErr())
                    return res;
                if (res.value) {
                    const spfxNode = res.value;
                    spfxNode.condition = { contains: question_1.TabSPFxItem.id };
                    if (spfxNode.data)
                        capNode.addChild(spfxNode);
                }
            }
            // 1.1.2 Azure Tab
            const tabRes = await this.getTabScaffoldQuestions(ctx, ((_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.platform) === teamsfx_api_1.Platform.VSCode ? false : true);
            if (tabRes.isErr())
                return tabRes;
            if (tabRes.value) {
                const tabNode = tabRes.value;
                tabNode.condition = { contains: question_1.TabOptionItem.id };
                capNode.addChild(tabNode);
            }
            // 1.2 Bot
            const botPlugin = this.BotPlugin;
            if (botPlugin.getQuestions) {
                const pluginCtx = util_1.getPluginContext(ctx, botPlugin.name);
                const res = await botPlugin.getQuestions(stage, pluginCtx);
                if (res.isErr())
                    return res;
                if (res.value) {
                    const botGroup = res.value;
                    botGroup.condition = { containsAny: [question_1.BotOptionItem.id, question_1.MessageExtensionItem.id] };
                    capNode.addChild(botGroup);
                }
            }
        }
        else if (stage == teamsfx_api_1.Stage.migrateV1) {
            const capQuestion = question_1.createV1CapabilityQuestion();
            const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
            node.addChild(capNode);
        }
        else if (stage === teamsfx_api_1.Stage.provision) {
            if (isDynamicQuestion) {
                const provisioned = this.checkWetherProvisionSucceeded(ctx.envInfo.state);
                if (provisioned)
                    return teamsfx_api_1.ok(undefined);
            }
            let pluginsToProvision;
            if (isDynamicQuestion) {
                const res = this.getSelectedPlugins(ctx);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
                pluginsToProvision = res.value;
            }
            else {
                pluginsToProvision = ResourcePluginContainer_1.getAllResourcePlugins();
            }
            if (!isDynamicQuestion) {
                node.addChild(new teamsfx_api_1.QTreeNode(question_1.AskSubscriptionQuestion));
            }
            for (const plugin of pluginsToProvision) {
                if (plugin.getQuestions) {
                    const pluginCtx = util_1.getPluginContext(ctx, plugin.name);
                    const getQuestionRes = await plugin.getQuestions(stage, pluginCtx);
                    if (getQuestionRes.isErr())
                        return getQuestionRes;
                    if (getQuestionRes.value) {
                        const subnode = getQuestionRes.value;
                        node.addChild(subnode);
                    }
                }
            }
        }
        else if (stage === teamsfx_api_1.Stage.deploy) {
            if (isDynamicQuestion) {
                const isAzureProject = this.isAzureProject(ctx);
                const provisioned = this.checkWetherProvisionSucceeded(ctx.envInfo.state);
                if (isAzureProject && !provisioned) {
                    return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(tools_1.getStrings().solution.FailedToDeployBeforeProvision), constants_2.SolutionSource, constants_2.SolutionError.CannotDeployBeforeProvision, constants_1.HelpLinks.WhyNeedProvision));
                }
            }
            let pluginsToDeploy;
            if (isDynamicQuestion) {
                const res = this.getSelectedPlugins(ctx);
                if (res.isErr()) {
                    return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("No resource to deploy"), constants_2.SolutionSource, constants_2.SolutionError.NoResourceToDeploy));
                }
                pluginsToDeploy = res.value.filter((plugin) => !!plugin.deploy);
            }
            else {
                const allPlugins = ResourcePluginContainer_1.getAllResourcePlugins();
                pluginsToDeploy = allPlugins.filter((plugin) => !!plugin.deploy);
            }
            if (pluginsToDeploy.length === 0) {
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("No resource to deploy"), constants_2.SolutionSource, constants_2.SolutionError.NoResourceToDeploy));
            }
            const pluginPrefix = "fx-resource-";
            const options = pluginsToDeploy.map((plugin) => {
                const item = {
                    id: plugin.name,
                    label: plugin.displayName,
                    cliName: plugin.name.replace(pluginPrefix, ""),
                };
                return item;
            });
            const selectQuestion = question_1.DeployPluginSelectQuestion;
            selectQuestion.staticOptions = options;
            selectQuestion.default = options.map((i) => i.id);
            const pluginSelection = new teamsfx_api_1.QTreeNode(selectQuestion);
            node.addChild(pluginSelection);
            for (const plugin of pluginsToDeploy) {
                if (plugin.getQuestions) {
                    const pluginCtx = util_1.getPluginContext(ctx, plugin.name);
                    const getQuestionRes = await plugin.getQuestions(stage, pluginCtx);
                    if (getQuestionRes.isErr())
                        return getQuestionRes;
                    if (getQuestionRes.value) {
                        const subnode = getQuestionRes.value;
                        subnode.condition = { contains: plugin.name };
                        if (subnode.data)
                            pluginSelection.addChild(subnode);
                    }
                }
            }
        }
        else if (stage === teamsfx_api_1.Stage.publish) {
            if (isDynamicQuestion) {
                const isAzureProject = this.isAzureProject(ctx);
                const provisioned = this.checkWetherProvisionSucceeded(ctx.envInfo.state);
                if (!provisioned) {
                    const errorMsg = isAzureProject
                        ? tools_1.getStrings().solution.FailedToPublishBeforeProvision
                        : tools_1.getStrings().solution.SPFxAskProvisionBeforePublish;
                    return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(errorMsg), constants_2.SolutionSource, constants_2.SolutionError.CannotPublishBeforeProvision, constants_1.HelpLinks.WhyNeedProvision));
                }
            }
            const pluginsToPublish = [this.AppStudioPlugin];
            for (const plugin of pluginsToPublish) {
                const pluginCtx = util_1.getPluginContext(ctx, plugin.name);
                if (plugin.getQuestions) {
                    const getQuestionRes = await plugin.getQuestions(stage, pluginCtx);
                    if (getQuestionRes.isErr())
                        return getQuestionRes;
                    if (getQuestionRes.value) {
                        const subnode = getQuestionRes.value;
                        node.addChild(subnode);
                    }
                }
            }
        }
        else if (stage === teamsfx_api_1.Stage.grantPermission) {
            node.addChild(new teamsfx_api_1.QTreeNode(question_1.GetUserEmailQuestion));
        }
        return teamsfx_api_1.ok(node);
    }
    async localDebug(ctx) {
        var _a;
        try {
            if (!this.spfxSelected(ctx)) {
                if (ctx.permissionRequestProvider === undefined) {
                    ctx.permissionRequestProvider = new permissionRequest_1.PermissionRequestFileProvider(ctx.root);
                }
                const result = await utils_1.ensurePermissionRequest((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings, ctx.permissionRequestProvider);
                if (result.isErr()) {
                    return result;
                }
            }
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                return teamsfx_api_1.err(e);
            }
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError("UnknownError", "check point 1 - " + JSON.stringify(e), constants_2.SolutionSource));
        }
        return await this.doLocalDebug(ctx);
    }
    async doLocalDebug(ctx) {
        var _a, _b, _c, _d, _e;
        let checkPoint = 1;
        try {
            //check point 2
            const maybeSelectedPlugins = this.getSelectedPlugins(ctx);
            if (maybeSelectedPlugins.isErr()) {
                return maybeSelectedPlugins;
            }
            const selectedPlugins = maybeSelectedPlugins.value;
            checkPoint = 2;
            //check point 3
            // Just to trigger M365 login before the concurrent execution of localDebug.
            // Because concurrent exectution of localDebug may getAccessToken() concurrently, which
            // causes 2 M365 logins before the token caching in common lib takes effect.
            await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
            // Pop-up window to confirm if local debug in another tenant
            const localDebugTenantId = tools_1.isMultiEnvEnabled()
                ? (_c = (_b = ctx.localSettings) === null || _b === void 0 ? void 0 : _b.teamsApp) === null || _c === void 0 ? void 0 : _c.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TenantId)
                : (_d = ctx.envInfo.state.get(constants_2.PluginNames.AAD)) === null || _d === void 0 ? void 0 : _d.get(_1.LOCAL_TENANT_ID);
            const m365TenantMatches = await utils_1.checkWhetherLocalDebugM365TenantMatches(localDebugTenantId, ctx.appStudioToken);
            if (m365TenantMatches.isErr()) {
                return m365TenantMatches;
            }
            checkPoint = 3;
            //check point 4
            const pluginsWithCtx = this.getPluginAndContextArray(ctx, selectedPlugins);
            const localDebugWithCtx = pluginsWithCtx.map(([plugin, context]) => {
                var _a;
                return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.localDebug) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
            });
            const postLocalDebugWithCtx = pluginsWithCtx.map(([plugin, context]) => {
                var _a;
                return [(_a = plugin === null || plugin === void 0 ? void 0 : plugin.postLocalDebug) === null || _a === void 0 ? void 0 : _a.bind(plugin), context, plugin.name];
            });
            const localDebugResults = await executor_1.executeConcurrently("", localDebugWithCtx);
            for (const localDebugResult of localDebugResults) {
                if (localDebugResult.isErr()) {
                    return localDebugResult;
                }
            }
            checkPoint = 4;
            //check point 5
            if (!this.spfxSelected(ctx)) {
                const aadPlugin = this.AadPlugin;
                if (selectedPlugins.some((plugin) => plugin.name === aadPlugin.name)) {
                    const result = await aadPlugin.executeUserTask({
                        namespace: `${constants_2.PluginNames.SOLUTION}/${constants_2.PluginNames.AAD}`,
                        method: "setApplicationInContext",
                        params: { isLocal: true },
                    }, util_1.getPluginContext(ctx, aadPlugin.name));
                    if (result.isErr()) {
                        return result;
                    }
                }
            }
            checkPoint = 5;
            // check point 6
            // set local debug Teams app tenant id in context.
            const result = this.loadTeamsAppTenantId(ctx, true, await ((_e = ctx.appStudioToken) === null || _e === void 0 ? void 0 : _e.getJsonObject()));
            if (result.isErr()) {
                return result;
            }
            checkPoint = 6;
            //check point 7
            const postLocalDebugResults = await executor_1.executeConcurrently("post", postLocalDebugWithCtx);
            const combinedPostLocalDebugResults = teamsfx_api_1.combine(postLocalDebugResults);
            if (combinedPostLocalDebugResults.isErr()) {
                return combinedPostLocalDebugResults;
            }
            checkPoint = 7;
            //check point 8
            // set local debug Teams app id in context.
            if (postLocalDebugWithCtx.length === combinedPostLocalDebugResults.value.length) {
                postLocalDebugWithCtx.map(function (plugin, index) {
                    var _a, _b, _c;
                    if (plugin[2] === constants_2.PluginNames.APPST) {
                        if (tools_1.isMultiEnvEnabled()) {
                            (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.set(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId, combinedPostLocalDebugResults.value[index]);
                        }
                        else {
                            (_c = ctx.envInfo.state
                                .get(constants_2.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.set(constants_2.LOCAL_DEBUG_TEAMS_APP_ID, combinedPostLocalDebugResults.value[index]);
                        }
                    }
                });
            }
            checkPoint = 8;
            return teamsfx_api_1.ok(constants_2.Void);
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                return teamsfx_api_1.err(e);
            }
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError("UnknownError", `check point ${checkPoint} - ${JSON.stringify(e)}`, constants_2.SolutionSource));
        }
    }
    async grantPermission(ctx) {
        return grantPermission_1.grantPermission({ apiVersion: 1, ctx });
    }
    async checkPermission(ctx) {
        return checkPermission_1.checkPermission({ apiVersion: 1, ctx });
    }
    async listAllCollaborators(ctx) {
        return listAllCollaborators_1.listAllCollaborators({ apiVersion: 1, ctx });
    }
    async listCollaborator(ctx) {
        return listCollaborator_1.listCollaborator({ apiVersion: 1, ctx });
    }
    loadTeamsAppTenantId(ctx, isLocalDebug, appStudioToken) {
        return utils_1.parseTeamsAppTenantId(appStudioToken).andThen((teamsAppTenantId) => {
            var _a, _b, _c;
            if (isLocalDebug && tools_1.isMultiEnvEnabled()) {
                (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.set(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TenantId, teamsAppTenantId);
            }
            else {
                (_c = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.set("teamsAppTenantId", teamsAppTenantId);
            }
            return teamsfx_api_1.ok(ctx);
        });
    }
    getAzureSolutionSettings(ctx) {
        var _a;
        return (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
    }
    async getQuestionsForAddResource(func, ctx) {
        const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(ctx.answers.platform);
        const settings = this.getAzureSolutionSettings(ctx);
        if (isDynamicQuestion &&
            !(settings.hostType === question_1.HostTypeOptionAzure.id &&
                settings.capabilities &&
                settings.capabilities.includes(question_1.TabOptionItem.id))) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Add resource is only supported for Tab app hosted in Azure."), constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport));
        }
        const selectedPlugins = settings.activeResourcePlugins || [];
        if (!selectedPlugins) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("selectedPlugins is empty"), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        }
        const functionPlugin = this.FunctionPlugin;
        const sqlPlugin = this.SqlPlugin;
        const apimPlugin = this.ApimPlugin;
        const keyVaultPlugin = this.KeyVaultPlugin;
        const alreadyHaveFunction = selectedPlugins.includes(functionPlugin.name);
        const alreadyHaveSQL = selectedPlugins.includes(sqlPlugin.name);
        const alreadyHaveAPIM = selectedPlugins.includes(apimPlugin.name);
        const alreadyHavekeyVault = selectedPlugins.includes(keyVaultPlugin.name);
        const addQuestion = question_1.createAddAzureResourceQuestion(alreadyHaveFunction, alreadyHaveSQL, alreadyHaveAPIM, alreadyHavekeyVault);
        const addAzureResourceNode = new teamsfx_api_1.QTreeNode(addQuestion);
        // there two cases to add function re-scaffold: 1. select add function   2. select add sql and function is not selected when creating
        if (functionPlugin.getQuestionsForUserTask) {
            const pluginCtx = util_1.getPluginContext(ctx, functionPlugin.name);
            const res = await functionPlugin.getQuestionsForUserTask(func, pluginCtx);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_function = res.value;
                if (alreadyHaveFunction) {
                    // if already has function, the question will appear depends on whether user select function, otherwise, the question will always show
                    azure_function.condition = { contains: question_1.AzureResourceFunction.id };
                }
                else {
                    // if not function activated, select any option will trigger function question
                    azure_function.condition = {
                        containsAny: [question_1.AzureResourceApim.id, question_1.AzureResourceFunction.id, question_1.AzureResourceSQL.id],
                    };
                }
                if (azure_function.data)
                    addAzureResourceNode.addChild(azure_function);
            }
        }
        //Azure SQL
        if (sqlPlugin.getQuestionsForUserTask && !alreadyHaveSQL) {
            const pluginCtx = util_1.getPluginContext(ctx, sqlPlugin.name);
            const res = await sqlPlugin.getQuestionsForUserTask(func, pluginCtx);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_sql = res.value;
                azure_sql.condition = { contains: question_1.AzureResourceSQL.id };
                if (azure_sql.data)
                    addAzureResourceNode.addChild(azure_sql);
            }
        }
        //APIM
        if (apimPlugin.getQuestionsForUserTask && (!alreadyHaveAPIM || !isDynamicQuestion)) {
            const pluginCtx = util_1.getPluginContext(ctx, apimPlugin.name);
            const res = await apimPlugin.getQuestionsForUserTask(func, pluginCtx);
            if (res.isErr())
                return res;
            if (res.value) {
                const apim = res.value;
                if (apim.data.type !== "group" || (apim.children && apim.children.length > 0)) {
                    const groupNode = new teamsfx_api_1.QTreeNode({ type: "group" });
                    groupNode.condition = { contains: question_1.AzureResourceApim.id };
                    addAzureResourceNode.addChild(groupNode);
                    const funcNode = new teamsfx_api_1.QTreeNode(question_1.AskSubscriptionQuestion);
                    question_1.AskSubscriptionQuestion.func = async (inputs) => {
                        if (!ctx.azureAccountProvider) {
                            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("azureAccountProvider is undefined"), "Solution", constants_2.SolutionError.InternelError));
                        }
                        const res = await commonQuestions_1.checkSubscription(ctx.envInfo, ctx.azureAccountProvider);
                        if (res.isOk()) {
                            const sub = res.value;
                            inputs.subscriptionId = sub.subscriptionId;
                            inputs.tenantId = sub.tenantId;
                        }
                        return res;
                    };
                    groupNode.addChild(funcNode);
                    groupNode.addChild(apim);
                }
            }
        }
        return teamsfx_api_1.ok(addAzureResourceNode);
    }
    async getQuestionsForAddCapability(ctx) {
        var _a;
        const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(ctx.answers.platform);
        const settings = this.getAzureSolutionSettings(ctx);
        if (!(settings.hostType === question_1.HostTypeOptionAzure.id) && isDynamicQuestion) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Add capability is not supported for SPFx project"), constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport));
        }
        const capabilities = settings.capabilities || [];
        const alreadyHaveTab = capabilities.includes(question_1.TabOptionItem.id);
        const alreadyHaveBotOrMe = capabilities.includes(question_1.BotOptionItem.id) || capabilities.includes(question_1.MessageExtensionItem.id);
        if (alreadyHaveBotOrMe && alreadyHaveTab) {
            const cannotAddCapWarnMsg = "Your App already has both Tab and Bot/Messaging extension, can not Add Capability.";
            (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("error", cannotAddCapWarnMsg, false);
            return teamsfx_api_1.ok(undefined);
        }
        const addCapQuestion = question_1.addCapabilityQuestion(alreadyHaveTab, alreadyHaveBotOrMe);
        const addCapNode = new teamsfx_api_1.QTreeNode(addCapQuestion);
        //Tab sub tree
        if (!alreadyHaveTab || !isDynamicQuestion) {
            const tabRes = await this.getTabScaffoldQuestions(ctx, false);
            if (tabRes.isErr())
                return tabRes;
            if (tabRes.value) {
                const tabNode = tabRes.value;
                tabNode.condition = { contains: question_1.TabOptionItem.id };
                addCapNode.addChild(tabNode);
            }
        }
        //Bot sub tree
        const botPlugin = this.BotPlugin;
        if ((!alreadyHaveBotOrMe || !isDynamicQuestion) && botPlugin.getQuestions) {
            const pluginCtx = util_1.getPluginContext(ctx, botPlugin.name);
            const res = await botPlugin.getQuestions(teamsfx_api_1.Stage.create, pluginCtx);
            if (res.isErr())
                return res;
            if (res.value) {
                const child = res.value;
                child.condition = { containsAny: [question_1.BotOptionItem.id, question_1.MessageExtensionItem.id] };
                if (child.data)
                    addCapNode.addChild(child);
            }
        }
        return teamsfx_api_1.ok(addCapNode);
    }
    /**
     * user questions for customized task
     */
    async getQuestionsForUserTask(func, ctx) {
        const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(ctx.answers.platform);
        const namespace = func.namespace;
        const array = namespace.split("/");
        if (func.method === "addCapability") {
            return await this.getQuestionsForAddCapability(ctx);
        }
        if (func.method === "addResource") {
            return await this.getQuestionsForAddResource(func, ctx);
        }
        if (array.length == 2) {
            const pluginName = array[1];
            const pluginMap = ResourcePluginContainer_1.getAllResourcePluginMap();
            const plugin = pluginMap.get(pluginName);
            if (plugin) {
                if (plugin.getQuestionsForUserTask) {
                    const pctx = util_1.getPluginContext(ctx, plugin.name);
                    return await plugin.getQuestionsForUserTask(func, pctx);
                }
                else {
                    return teamsfx_api_1.ok(undefined);
                }
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async executeAddResource(ctx) {
        var _a, _b, _c, _d, _e, _f, _g;
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddResourceStart, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        });
        if (!ctx.answers) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`answer is empty!`), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        }
        const settings = this.getAzureSolutionSettings(ctx);
        const originalSettings = tools_1.deepCopy(settings);
        const canProceed = executeUserTask_1.canAddResource(settings, ctx.telemetryReporter);
        if (canProceed.isErr()) {
            return canProceed;
        }
        const selectedPlugins = settings.activeResourcePlugins;
        const functionPlugin = this.FunctionPlugin;
        const sqlPlugin = this.SqlPlugin;
        const apimPlugin = this.ApimPlugin;
        const keyVaultPlugin = this.KeyVaultPlugin;
        const alreadyHaveFunction = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(functionPlugin.name);
        const alreadyHaveSql = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(sqlPlugin.name);
        const alreadyHaveApim = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(apimPlugin.name);
        const alreadyHaveKeyVault = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(keyVaultPlugin.name);
        const addResourcesAnswer = ctx.answers[question_1.AzureSolutionQuestionNames.AddResources];
        if (!addResourcesAnswer) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`answer of ${question_1.AzureSolutionQuestionNames.AddResources} is empty!`), constants_2.SolutionSource, constants_2.SolutionError.InvalidInput));
        }
        const addSQL = addResourcesAnswer.includes(question_1.AzureResourceSQL.id);
        const addFunc = addResourcesAnswer.includes(question_1.AzureResourceFunction.id);
        const addApim = addResourcesAnswer.includes(question_1.AzureResourceApim.id);
        const addKeyVault = addResourcesAnswer.includes(question_1.AzureResourceKeyVault.id);
        if ((alreadyHaveSql && addSQL) ||
            (alreadyHaveApim && addApim) ||
            (alreadyHaveKeyVault && addKeyVault)) {
            const e = teamsfx_api_1.returnUserError(new Error("SQL/APIM/KeyVault is already added."), constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport);
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, e, ctx.telemetryReporter));
        }
        let addNewResourceToProvision = false;
        const notifications = [];
        const pluginsToScaffold = [this.LocalDebugPlugin];
        const pluginsToDoArm = [];
        const azureResource = Array.from(settings.azureResources || []);
        if (addFunc || ((addSQL || addApim) && !alreadyHaveFunction)) {
            pluginsToScaffold.push(functionPlugin);
            if (!azureResource.includes(question_1.AzureResourceFunction.id)) {
                azureResource.push(question_1.AzureResourceFunction.id);
                addNewResourceToProvision = true;
                pluginsToDoArm.push(functionPlugin);
            }
            notifications.push(question_1.AzureResourceFunction.label);
        }
        if (addSQL && !alreadyHaveSql) {
            pluginsToScaffold.push(sqlPlugin);
            pluginsToDoArm.push(sqlPlugin);
            azureResource.push(question_1.AzureResourceSQL.id);
            notifications.push(question_1.AzureResourceSQL.label);
            addNewResourceToProvision = true;
        }
        if (addApim && !alreadyHaveApim) {
            pluginsToScaffold.push(apimPlugin);
            pluginsToDoArm.push(apimPlugin);
            azureResource.push(question_1.AzureResourceApim.id);
            notifications.push(question_1.AzureResourceApim.label);
            addNewResourceToProvision = true;
        }
        if (addKeyVault && !alreadyHaveKeyVault) {
            pluginsToScaffold.push(keyVaultPlugin);
            pluginsToDoArm.push(keyVaultPlugin);
            azureResource.push(question_1.AzureResourceKeyVault.id);
            notifications.push(question_1.AzureResourceKeyVault.label);
            addNewResourceToProvision = true;
        }
        if (notifications.length > 0) {
            if (tools_1.isArmSupportEnabled() && addNewResourceToProvision) {
                executeUserTask_1.showUpdateArmTemplateNotice(ctx.ui);
            }
            settings.azureResources = azureResource;
            await this.reloadPlugins(settings);
            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`start scaffolding ${notifications.join(",")}.....`);
            const scaffoldRes = await this.doScaffold(ctx, pluginsToScaffold, addNewResourceToProvision, pluginsToDoArm);
            if (scaffoldRes.isErr()) {
                (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`failed to scaffold ${notifications.join(",")}!`);
                ctx.projectSettings.solutionSettings = originalSettings;
                return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, scaffoldRes.error, ctx.telemetryReporter));
            }
            (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(`finish scaffolding ${notifications.join(",")}!`);
            if (addNewResourceToProvision)
                (_e = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _e === void 0 ? void 0 : _e.set(constants_2.SOLUTION_PROVISION_SUCCEEDED, false); //if selected plugin changed, we need to re-do provision
            (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.showMessage("info", util.format(ctx.answers.platform === teamsfx_api_1.Platform.CLI
                ? tools_1.getStrings().solution.AddResourceNoticeForCli
                : tools_1.getStrings().solution.AddResourceNotice, notifications.join(",")), false);
        }
        (_g = ctx.telemetryReporter) === null || _g === void 0 ? void 0 : _g.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddResource, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
            [constants_2.SolutionTelemetryProperty.Resources]: addResourcesAnswer.join(";"),
        });
        return teamsfx_api_1.ok(constants_2.Void);
    }
    async executeAddCapability(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapabilityStart, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        });
        if (!ctx.answers) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`answer is empty!`), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        }
        const settings = this.getAzureSolutionSettings(ctx);
        const originalSettings = tools_1.deepCopy(settings);
        const canProceed = executeUserTask_1.canAddCapability(settings, ctx.telemetryReporter);
        if (canProceed.isErr()) {
            return canProceed;
        }
        const capabilitiesAnswer = ctx.answers[question_1.AzureSolutionQuestionNames.Capabilities];
        if (!capabilitiesAnswer || capabilitiesAnswer.length === 0) {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapability, {
                [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
                [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
                [constants_2.SolutionTelemetryProperty.Capabilities]: [].join(";"),
            });
            return teamsfx_api_1.ok(constants_2.Void);
        }
        const alreadyHaveBotAndAddBot = (((_c = settings.capabilities) === null || _c === void 0 ? void 0 : _c.includes(question_1.BotOptionItem.id)) ||
            ((_d = settings.capabilities) === null || _d === void 0 ? void 0 : _d.includes(question_1.MessageExtensionItem.id))) &&
            (capabilitiesAnswer.includes(question_1.BotOptionItem.id) ||
                capabilitiesAnswer.includes(question_1.MessageExtensionItem.id));
        const alreadyHaveTabAndAddTab = ((_e = settings.capabilities) === null || _e === void 0 ? void 0 : _e.includes(question_1.TabOptionItem.id)) &&
            capabilitiesAnswer.includes(question_1.TabOptionItem.id);
        if (alreadyHaveBotAndAddBot || alreadyHaveTabAndAddTab) {
            const e = teamsfx_api_1.returnUserError(new Error("There are no additional capabilities you can add to your project."), constants_2.SolutionSource, constants_2.SolutionError.FailedToAddCapability);
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddCapability, e, ctx.telemetryReporter));
        }
        let change = false;
        const pluginsToScaffold = [this.LocalDebugPlugin, this.AppStudioPlugin];
        const capabilities = Array.from(settings.capabilities);
        for (const cap of capabilitiesAnswer) {
            if (!capabilities.includes(cap)) {
                capabilities.push(cap);
                change = true;
                if (cap === question_1.TabOptionItem.id) {
                    pluginsToScaffold.push(this.FrontendPlugin);
                    pluginsToScaffold.push(typedi_1.Container.get(ResourcePluginContainer_1.ResourcePlugins.SimpleAuthPlugin));
                }
                else if ((cap === question_1.BotOptionItem.id || cap === question_1.MessageExtensionItem.id) &&
                    !pluginsToScaffold.includes(this.BotPlugin)) {
                    pluginsToScaffold.push(this.BotPlugin);
                }
            }
        }
        if (change) {
            if (tools_1.isArmSupportEnabled()) {
                executeUserTask_1.showUpdateArmTemplateNotice(ctx.ui);
            }
            settings.capabilities = capabilities;
            await this.reloadPlugins(settings);
            const pluginNames = pluginsToScaffold.map((p) => p.name).join(",");
            (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.info(`start scaffolding ${pluginNames}.....`);
            const scaffoldRes = await this.doScaffold(ctx, pluginsToScaffold, true);
            if (scaffoldRes.isErr()) {
                (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(`failed to scaffold ${pluginNames}!`);
                ctx.projectSettings.solutionSettings = originalSettings;
                return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddCapability, scaffoldRes.error, ctx.telemetryReporter));
            }
            (_h = ctx.logProvider) === null || _h === void 0 ? void 0 : _h.info(`finish scaffolding ${pluginNames}!`);
            (_j = ctx.envInfo.state.get(constants_2.GLOBAL_CONFIG)) === null || _j === void 0 ? void 0 : _j.set(constants_2.SOLUTION_PROVISION_SUCCEEDED, false);
            const addNames = capabilitiesAnswer.map((c) => `'${c}'`).join(" and ");
            const single = capabilitiesAnswer.length === 1;
            const template = ctx.answers.platform === teamsfx_api_1.Platform.CLI
                ? single
                    ? tools_1.getStrings().solution.AddCapabilityNoticeForCli
                    : tools_1.getStrings().solution.AddCapabilitiesNoticeForCli
                : single
                    ? tools_1.getStrings().solution.AddCapabilityNotice
                    : tools_1.getStrings().solution.AddCapabilitiesNotice;
            const msg = util.format(template, addNames);
            (_k = ctx.ui) === null || _k === void 0 ? void 0 : _k.showMessage("info", msg, false);
            (_l = ctx.telemetryReporter) === null || _l === void 0 ? void 0 : _l.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapability, {
                [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
                [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
                [constants_2.SolutionTelemetryProperty.Capabilities]: capabilitiesAnswer.join(";"),
            });
            return teamsfx_api_1.ok({});
        }
        const cannotAddCapWarnMsg = "Add nothing";
        (_m = ctx.ui) === null || _m === void 0 ? void 0 : _m.showMessage("warn", cannotAddCapWarnMsg, false);
        (_o = ctx.telemetryReporter) === null || _o === void 0 ? void 0 : _o.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapability, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
            [constants_2.SolutionTelemetryProperty.Capabilities]: [].join(";"),
        });
        return teamsfx_api_1.ok({});
    }
    /**
     * execute user task
     */
    async executeUserTask(func, ctx) {
        var _a, _b;
        if (!ctx.answers)
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`answer is empty!`), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
        const namespace = func.namespace;
        const method = func.method;
        const array = namespace.split("/");
        if (method === "addCapability") {
            return this.executeAddCapability(ctx);
        }
        if (method === "addResource") {
            return this.executeAddResource(ctx);
        }
        if (namespace.includes("solution")) {
            if (method === "registerTeamsAppAndAad") {
                const maybeParams = executeUserTask_1.extractParamForRegisterTeamsAppAndAad(ctx.answers);
                if (maybeParams.isErr()) {
                    return maybeParams;
                }
                return this.registerTeamsAppAndAad(ctx, maybeParams.value);
            }
            else if (method === "VSpublish") {
                // VSpublish means VS calling cli to do publish. It is different than normal cli work flow
                // It's teamsfx init followed by teamsfx  publish without running provision.
                // Using executeUserTask here could bypass the fx project check.
                if (((_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.platform) !== "vs") {
                    return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`VS publish is not supposed to run on platform ${(_b = ctx.answers) === null || _b === void 0 ? void 0 : _b.platform}`), constants_2.SolutionSource, constants_2.SolutionError.UnsupportedPlatform));
                }
                const appStudioPlugin = this.AppStudioPlugin;
                const pluginCtx = util_1.getPluginContext(ctx, appStudioPlugin.name);
                return appStudioPlugin.publish(pluginCtx);
            }
            else if (method === "validateManifest") {
                const appStudioPlugin = this.AppStudioPlugin;
                const pluginCtx = util_1.getPluginContext(ctx, appStudioPlugin.name);
                return await appStudioPlugin.executeUserTask(func, pluginCtx);
            }
            else if (method === "buildPackage") {
                const appStudioPlugin = this.AppStudioPlugin;
                const pluginCtx = util_1.getPluginContext(ctx, appStudioPlugin.name);
                return await appStudioPlugin.executeUserTask(func, pluginCtx);
            }
            else if (array.length == 2) {
                const pluginName = array[1];
                const pluginMap = ResourcePluginContainer_1.getAllResourcePluginMap();
                const plugin = pluginMap.get(pluginName);
                if (plugin && plugin.executeUserTask) {
                    const pctx = util_1.getPluginContext(ctx, plugin.name);
                    return plugin.executeUserTask(func, pctx);
                }
            }
        }
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`executeUserTaskRouteFailed:${JSON.stringify(func)}`), constants_2.SolutionSource, `executeUserTaskRouteFailed`));
    }
    prepareConfigForRegisterTeamsAppAndAad(config, params) {
        const endpoint = params.endpoint;
        const domain = new URL(endpoint).hostname;
        if (config.get(constants_2.GLOBAL_CONFIG) == undefined) {
            config.set(constants_2.GLOBAL_CONFIG, new teamsfx_api_1.ConfigMap());
        }
        const aadPlugin = this.AadPlugin;
        if (config.get(aadPlugin.name) == undefined) {
            config.set(aadPlugin.name, new teamsfx_api_1.ConfigMap());
        }
        config.get(aadPlugin.name).set("domain", domain);
        config.get(aadPlugin.name).set("endpoint", endpoint);
        return domain;
    }
    extractConfigForRegisterTeamsAppAndAad(config, isLocal) {
        var _a, _b, _c;
        const aadPlugin = this.AadPlugin;
        const aadId = (_a = config.get(aadPlugin.name)) === null || _a === void 0 ? void 0 : _a.get(isLocal ? constants_2.LOCAL_DEBUG_AAD_ID : constants_2.REMOTE_AAD_ID);
        if (aadId === undefined || typeof aadId !== "string") {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`config ${constants_2.LOCAL_DEBUG_AAD_ID} is missing`), constants_2.SolutionSource, constants_2.SolutionError.RegisterTeamsAppAndAadError));
        }
        const applicationIdUri = (_b = config
            .get(aadPlugin.name)) === null || _b === void 0 ? void 0 : _b.get(isLocal ? constants_2.LOCAL_APPLICATION_ID_URIS : constants_2.REMOTE_APPLICATION_ID_URIS);
        if (applicationIdUri === undefined || typeof applicationIdUri !== "string") {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`config ${constants_2.LOCAL_APPLICATION_ID_URIS} is missing`), constants_2.SolutionSource, constants_2.SolutionError.RegisterTeamsAppAndAadError));
        }
        const clientSecret = (_c = config
            .get(aadPlugin.name)) === null || _c === void 0 ? void 0 : _c.get(isLocal ? constants_2.LOCAL_CLIENT_SECRET : constants_2.REMOTE_CLIENT_SECRET);
        if (clientSecret === undefined || typeof clientSecret !== "string") {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`config ${constants_2.LOCAL_CLIENT_SECRET} is missing`), constants_2.SolutionSource, constants_2.SolutionError.RegisterTeamsAppAndAadError));
        }
        return teamsfx_api_1.ok({
            aadId,
            applicationIdUri,
            clientSecret,
        });
    }
    /**
     * This function is only called by cli: teamsfx init. The context may be different from that of vsc: no .${ConfigFolderName} folder, no permissions.json
     * In order to reuse aad plugin, we need to pretend we are still in vsc context. Currently, we don't support icons, because icons are not included in the
     * current contract.
     */
    async registerTeamsAppAndAad(ctx, params) {
        var _a;
        const rootPath = params["root-path"];
        const isLocal = params.environment === "local";
        const mockedManifest = new teamsfx_api_1.TeamsAppManifest();
        mockedManifest.name.short = params["app-name"];
        const domain = this.prepareConfigForRegisterTeamsAppAndAad(ctx.envInfo.state, params);
        const aadPlugin = this.AadPlugin;
        const aadPluginCtx = util_1.getPluginContext(ctx, aadPlugin.name);
        if (ctx.permissionRequestProvider === undefined) {
            ctx.permissionRequestProvider = {
                async checkPermissionRequest() {
                    return teamsfx_api_1.ok(undefined);
                },
                async getPermissionRequest() {
                    return teamsfx_api_1.ok(JSON.stringify(constants_2.DEFAULT_PERMISSION_REQUEST));
                },
            };
        }
        const provisionResult = isLocal
            ? await aadPlugin.localDebug(aadPluginCtx)
            : await aadPlugin.provision(aadPluginCtx);
        if (provisionResult.isErr()) {
            return provisionResult;
        }
        await aadPlugin.executeUserTask({
            namespace: `${constants_2.PluginNames.SOLUTION}/${constants_2.PluginNames.AAD}`,
            method: "setApplicationInContext",
            params: { isLocal: isLocal },
        }, aadPluginCtx);
        const postProvisionResult = isLocal
            ? await aadPlugin.postLocalDebug(aadPluginCtx)
            : await aadPlugin.postProvision(aadPluginCtx);
        if (postProvisionResult.isErr()) {
            return postProvisionResult;
        }
        const configResult = this.extractConfigForRegisterTeamsAppAndAad(ctx.envInfo.state, isLocal);
        if (configResult.isErr()) {
            return teamsfx_api_1.err(configResult.error);
        }
        const manifestPath = path_1.default.join(rootPath, "manifest", isLocal ? "local" : "remote", "manifest.json");
        const appSettingsJSONPath = path_1.default.join(rootPath, isLocal ? "appsettings.Development.json" : "appsettings.json");
        const manifestTpl = (await fs.readFile(manifestPath)).toString();
        const manifestStr = mustache_1.default.render(manifestTpl, {
            "client-id": configResult.value.aadId,
            "app-name": params["app-name"],
            endpoint: params.endpoint,
            domain: domain,
            "application-id-uri": configResult.value.applicationIdUri,
        });
        const manifest = JSON.parse(manifestStr);
        await fs.writeFile(manifestPath, manifestStr);
        const appStudioPlugin = this.AppStudioPlugin;
        const func = {
            namespace: `${constants_2.PluginNames.SOLUTION}/${constants_2.PluginNames.APPST}`,
            method: "getAppDefinitionAndUpdate",
            params: {
                type: "remote",
                manifest: manifest,
            },
        };
        const maybeTeamsAppId = await appStudioPlugin.executeUserTask(func, util_1.getPluginContext(ctx, this.AppStudioPlugin.name));
        if (maybeTeamsAppId.isErr()) {
            return teamsfx_api_1.err(maybeTeamsAppId.error);
        }
        const teamsAppId = maybeTeamsAppId.value;
        const appSettingsJSONTpl = (await fs.readFile(appSettingsJSONPath)).toString();
        const maybeTenantId = utils_1.parseTeamsAppTenantId(await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getJsonObject()));
        if (maybeTenantId.isErr()) {
            return teamsfx_api_1.err(maybeTenantId.error);
        }
        const appSettingsJSON = mustache_1.default.render(appSettingsJSONTpl, {
            "client-id": configResult.value.aadId,
            "client-secret": configResult.value.clientSecret,
            "application-id-uri": configResult.value.applicationIdUri,
            endpoint: params.endpoint,
            "tenant-id": maybeTenantId.value,
        });
        await fs.writeFile(appSettingsJSONPath, appSettingsJSON);
        if (isLocal) {
            const launchSettingsJSONPath = path_1.default.join(rootPath, "Properties", "launchSettings.json");
            const launchSettingsJSONTpl = (await fs.readFile(launchSettingsJSONPath)).toString();
            const launchSettingsJSON = mustache_1.default.render(launchSettingsJSONTpl, {
                "teams-app-id": teamsAppId,
            });
            await fs.writeFile(launchSettingsJSONPath, launchSettingsJSON);
        }
        return teamsfx_api_1.ok({
            teamsAppId: teamsAppId,
            clientId: configResult.value.aadId,
            clientSecret: configResult.value.clientSecret,
            tenantId: maybeTenantId.value,
            applicationIdUri: configResult.value.applicationIdUri,
        });
    }
};
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "scaffold", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "deploy", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "publish", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "grantPermission", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "checkPermission", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "listAllCollaborators", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "listCollaborator", null);
tslib_1.__decorate([
    lib_1.hooks([errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsAppSolution.prototype, "executeUserTask", null);
TeamsAppSolution = tslib_1.__decorate([
    typedi_1.Service(SolutionPluginContainer_1.SolutionPlugins.AzureTeamsSolution),
    tslib_1.__metadata("design:paramtypes", [])
], TeamsAppSolution);
exports.TeamsAppSolution = TeamsAppSolution;
//# sourceMappingURL=solution.js.map