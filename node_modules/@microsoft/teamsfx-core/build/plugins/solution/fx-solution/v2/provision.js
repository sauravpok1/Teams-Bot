"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.askForProvisionConsent = exports.provisionResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../../../common/tools");
const executor_1 = require("./executor");
const utils_1 = require("./utils");
const constants_1 = require("../constants");
const util = tslib_1.__importStar(require("util"));
const lodash_1 = tslib_1.__importStar(require("lodash"));
const constants_2 = require("../../../../common/constants");
const adaptor_1 = require("./adaptor");
const commonQuestions_1 = require("../commonQuestions");
const arm_1 = require("../arm");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const permissionRequest_1 = require("../../../../core/permissionRequest");
const core_1 = require("../../../../core");
const constants_3 = require("../../../resource/appstudio/constants");
async function provisionResource(ctx, inputs, envInfo, tokenProvider) {
    var _a, _b, _c, _d;
    if (inputs.projectPath === undefined) {
        return new teamsfx_api_1.v2.FxFailure(teamsfx_api_1.returnSystemError(new Error("projectPath is undefined"), constants_1.SolutionSource, constants_1.SolutionError.InternelError));
    }
    const projectPath = inputs.projectPath;
    const azureSolutionSettings = utils_1.getAzureSolutionSettings(ctx);
    // Just to trigger M365 login before the concurrent execution of provision.
    // Because concurrent exectution of provision may getAccessToken() concurrently, which
    // causes 2 M365 logins before the token caching in common lib takes effect.
    await tokenProvider.appStudioToken.getAccessToken();
    if (utils_1.isAzureProject(azureSolutionSettings)) {
        if (ctx.permissionRequestProvider === undefined) {
            ctx.permissionRequestProvider = new permissionRequest_1.PermissionRequestFileProvider(inputs.projectPath);
        }
        const result = await utils_1.ensurePermissionRequest(azureSolutionSettings, ctx.permissionRequestProvider);
        if (result.isErr()) {
            return new teamsfx_api_1.v2.FxFailure(result.error);
        }
    }
    const newEnvInfo = lodash_1.default.cloneDeep(envInfo);
    if (!newEnvInfo.state[constants_1.GLOBAL_CONFIG]) {
        newEnvInfo.state[constants_1.GLOBAL_CONFIG] = { output: {}, secrets: {} };
    }
    newEnvInfo.state[constants_1.GLOBAL_CONFIG]["output"][constants_1.SOLUTION_PROVISION_SUCCEEDED] = false;
    if (utils_1.isAzureProject(azureSolutionSettings)) {
        //fill in common questions for solution
        const appName = ctx.projectSetting.appName;
        const contextAdaptor = new adaptor_1.ProvisionContextAdapter([ctx, inputs, newEnvInfo, tokenProvider]);
        const res = inputs.isForUT
            ? teamsfx_api_1.ok({})
            : await commonQuestions_1.fillInCommonQuestions(contextAdaptor, appName, contextAdaptor.envInfo.state, tokenProvider.azureAccountProvider, await tokenProvider.appStudioToken.getJsonObject());
        if (res.isErr()) {
            return new teamsfx_api_1.v2.FxFailure(res.error);
        }
        // contextAdaptor deep-copies original JSON into a map. We need to convert it back.
        const update = contextAdaptor.getEnvStateJson();
        lodash_1.default.assign(newEnvInfo.state, update);
        const consentResult = await askForProvisionConsent(contextAdaptor);
        if (consentResult.isErr()) {
            return new teamsfx_api_1.v2.FxFailure(consentResult.error);
        }
        // create resource group if needed
        const commonQuestionResult = res.value;
        if (commonQuestionResult.needCreateResourceGroup) {
            const maybeRgName = await commonQuestions_1.createNewResourceGroup(tokenProvider.azureAccountProvider, commonQuestionResult.subscriptionId, commonQuestionResult.subscriptionName, commonQuestionResult.resourceGroupName, commonQuestionResult.location, ctx.logProvider);
            if (maybeRgName.isErr()) {
                return new teamsfx_api_1.v2.FxFailure(maybeRgName.error);
            }
        }
    }
    const solutionInputs = utils_1.extractSolutionInputs(newEnvInfo.state[constants_1.GLOBAL_CONFIG]["output"]);
    const plugins = utils_1.getSelectedPlugins(azureSolutionSettings);
    const provisionThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.provisionResource))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "provisionResource",
            thunk: () => {
                if (!newEnvInfo.state[plugin.name]) {
                    newEnvInfo.state[plugin.name] = {};
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return plugin.provisionResource(ctx, Object.assign(Object.assign(Object.assign({}, inputs), solutionInputs), { projectPath: projectPath }), Object.assign(Object.assign({}, newEnvInfo), { state: newEnvInfo.state }), tokenProvider);
            },
        };
    });
    // call provisionResources
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util.format(tools_1.getStrings().solution.ProvisionStartNotice, constants_2.PluginDisplayName.Solution));
    const provisionResult = await executor_1.executeConcurrently(provisionThunks, ctx.logProvider);
    if (provisionResult.kind === "failure") {
        return provisionResult;
    }
    else {
        const update = utils_1.combineRecords(provisionResult.output);
        lodash_1.default.assign(newEnvInfo.state, update);
        if (provisionResult.kind === "partialSuccess") {
            return new teamsfx_api_1.v2.FxPartialSuccess(newEnvInfo.state, provisionResult.error);
        }
    }
    (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(util.format(tools_1.getStrings().solution.ProvisionFinishNotice, constants_2.PluginDisplayName.Solution));
    // call deployArmTemplates
    if (utils_1.isAzureProject(azureSolutionSettings) && !inputs.isForUT) {
        const contextAdaptor = new adaptor_1.ProvisionContextAdapter([ctx, inputs, newEnvInfo, tokenProvider]);
        const armDeploymentResult = await arm_1.deployArmTemplates(contextAdaptor);
        if (armDeploymentResult.isErr()) {
            return new teamsfx_api_1.v2.FxPartialSuccess(newEnvInfo.state, armDeploymentResult.error);
        }
        // contextAdaptor deep-copies original JSON into a map. We need to convert it back.
        const update = contextAdaptor.getEnvStateJson();
        lodash_1.default.assign(newEnvInfo.state, update);
    }
    // call aad.setApplicationInContext
    const aadPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
    if (plugins.some((plugin) => plugin.name === aadPlugin.name) && aadPlugin.executeUserTask) {
        const result = await aadPlugin.executeUserTask(ctx, inputs, {
            namespace: `${constants_1.PluginNames.SOLUTION}/${constants_1.PluginNames.AAD}`,
            method: "setApplicationInContext",
            params: { isLocal: false },
        }, {}, newEnvInfo, tokenProvider);
        if (result.isErr()) {
            return new teamsfx_api_1.v2.FxPartialSuccess(newEnvInfo.state, result.error);
        }
    }
    if (utils_1.isAzureProject(azureSolutionSettings)) {
        solutionInputs.remoteTeamsAppId =
            newEnvInfo.state[constants_1.PluginNames.APPST]["output"][constants_3.Constants.TEAMS_APP_ID];
    }
    const configureResourceThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.configureResource))
        .map((plugin) => {
        if (!newEnvInfo.state[plugin.name]) {
            newEnvInfo.state[plugin.name] = {};
        }
        return {
            pluginName: `${plugin.name}`,
            taskName: "configureResource",
            thunk: () => 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            plugin.configureResource(ctx, Object.assign(Object.assign(Object.assign({}, inputs), solutionInputs), { projectPath: projectPath }), Object.assign(Object.assign({}, newEnvInfo), { state: newEnvInfo.state }), tokenProvider),
        };
    });
    //call configResource
    const configureResourceResult = await executor_1.executeConcurrently(configureResourceThunks, ctx.logProvider);
    (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(util.format(tools_1.getStrings().solution.ConfigurationFinishNotice, constants_2.PluginDisplayName.Solution));
    if (configureResourceResult.kind === "failure" ||
        configureResourceResult.kind === "partialSuccess") {
        const msg = util.format(tools_1.getStrings().solution.ProvisionFailNotice, ctx.projectSetting.appName);
        ctx.logProvider.error(msg);
        solutionInputs[constants_1.SOLUTION_PROVISION_SUCCEEDED] = false;
        if (configureResourceResult.kind === "failure") {
            return configureResourceResult;
        }
        else {
            return new teamsfx_api_1.v2.FxPartialSuccess(newEnvInfo.state, configureResourceResult.error);
        }
    }
    else {
        if (newEnvInfo.state[constants_1.GLOBAL_CONFIG] && newEnvInfo.state[constants_1.GLOBAL_CONFIG][constants_1.ARM_TEMPLATE_OUTPUT]) {
            delete newEnvInfo.state[constants_1.GLOBAL_CONFIG][constants_1.ARM_TEMPLATE_OUTPUT];
        }
        const url = tools_1.getResourceGroupInPortal(solutionInputs.subscriptionId, solutionInputs.tenantId, solutionInputs.resourceGroupName);
        const msg = util.format(`Success: ${tools_1.getStrings().solution.ProvisionSuccessNotice}`, ctx.projectSetting.appName);
        (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(msg);
        if (url) {
            const title = "View Provisioned Resources";
            ctx.userInteraction.showMessage("info", msg, false, title).then((result) => {
                const userSelected = result.isOk() ? result.value : undefined;
                if (userSelected === title) {
                    ctx.userInteraction.openUrl(url);
                }
            });
        }
        else {
            ctx.userInteraction.showMessage("info", msg, false);
        }
        const update = utils_1.combineRecords(configureResourceResult.output);
        lodash_1.default.assign(newEnvInfo.state, update);
        newEnvInfo.state[constants_1.GLOBAL_CONFIG]["output"][constants_1.SOLUTION_PROVISION_SUCCEEDED] = true;
        if (!utils_1.isAzureProject(azureSolutionSettings)) {
            const appStudioTokenJson = await tokenProvider.appStudioToken.getJsonObject();
            newEnvInfo.state[constants_1.GLOBAL_CONFIG]["output"][constants_1.REMOTE_TEAMS_APP_TENANT_ID] = appStudioTokenJson.tid;
        }
        return new teamsfx_api_1.v2.FxSuccess(newEnvInfo.state);
    }
}
exports.provisionResource = provisionResource;
async function askForProvisionConsent(ctx) {
    var _a, _b, _c, _d, _e, _f;
    if (core_1.isVsCallingCli()) {
        // Skip asking users for input on VS calling CLI to simplify user interaction.
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    const azureToken = await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync());
    // Only Azure project requires this confirm dialog
    const username = azureToken.username ? azureToken.username : "";
    const subscriptionId = (_b = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _b === void 0 ? void 0 : _b.get(constants_1.SUBSCRIPTION_ID);
    const subscriptionName = (_c = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.get(constants_1.SUBSCRIPTION_NAME);
    const msg = util.format(tools_1.getStrings().solution.ProvisionConfirmNotice, username, subscriptionName ? subscriptionName : subscriptionId);
    let confirmRes = undefined;
    if (tools_1.isMultiEnvEnabled()) {
        const msgNew = util.format(tools_1.getStrings().solution.ProvisionConfirmEnvNotice, ctx.envInfo.envName, username, subscriptionName ? subscriptionName : subscriptionId);
        confirmRes = await ((_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("warn", msgNew, true, "Provision"));
    }
    else {
        confirmRes = await ((_e = ctx.ui) === null || _e === void 0 ? void 0 : _e.showMessage("warn", msg, true, "Provision", "Pricing calculator"));
    }
    const confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
    if (confirm !== "Provision") {
        if (confirm === "Pricing calculator") {
            (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.openUrl("https://azure.microsoft.com/en-us/pricing/calculator/");
        }
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(tools_1.getStrings().solution.CancelProvision), constants_1.SolutionSource, tools_1.getStrings().solution.CancelProvision));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.askForProvisionConsent = askForProvisionConsent;
//# sourceMappingURL=provision.js.map