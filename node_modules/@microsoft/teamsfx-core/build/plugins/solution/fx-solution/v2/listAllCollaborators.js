"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listAllCollaborators = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const common_1 = require("../../../../common");
const constants_1 = require("../constants");
const util_1 = require("../utils/util");
const collaborationUtil_1 = require("./collaborationUtil");
const __1 = require("../../../..");
const listCollaborator_1 = require("./listCollaborator");
async function listAllCollaboratorsImpl(param, projectPath, cryptoProvider, telemetryReporter, ui, graphTokenProvider, platform) {
    var _a, _b;
    telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ListAllCollaboratorsStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    const collaboratorsResult = {};
    const envs = await __1.environmentManager.listEnvConfigs(projectPath);
    if (envs.isErr()) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ListAllCollaborators, envs.error, telemetryReporter));
    }
    const result = await collaborationUtil_1.CollaborationUtil.getCurrentUserInfo(graphTokenProvider);
    if (result.isErr()) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ListAllCollaborators, result.error, telemetryReporter));
    }
    const userInfo = result.value;
    for (const env of envs.value) {
        try {
            const envInfo = await __1.environmentManager.loadEnvInfo(projectPath, cryptoProvider, env);
            if (envInfo.isErr()) {
                throw envInfo.error;
            }
            const stateResult = collaborationUtil_1.CollaborationUtil.getCurrentCollaborationState(envInfo.value.state, result.value);
            if (stateResult.state != common_1.CollaborationState.OK) {
                if (platform === teamsfx_api_1.Platform.CLI) {
                    ui === null || ui === void 0 ? void 0 : ui.showMessage("warn", stateResult.message, false);
                }
                collaboratorsResult[env] = {
                    state: stateResult.state,
                    message: stateResult.message,
                };
                continue;
            }
            const [results, errors] = param.apiVersion === 1
                ? await listCollaborator_1.executeListCollaboratorV1(param.ctx, userInfo)
                : await listCollaborator_1.executeListCollaboratorV2(param.ctx, param.inputs, param.envInfo, param.tokenProvider, userInfo);
            let errorMsg = "";
            if (errors.length > 0) {
                errorMsg += `Failed to list collaborator for the project.\n Error details: \n`;
                for (const fxError of errors) {
                    errorMsg += fxError.error.message + "\n";
                }
            }
            if (errorMsg) {
                collaboratorsResult[env] = {
                    state: common_1.CollaborationState.ERROR,
                    error: teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ListAllCollaborators, teamsfx_api_1.returnUserError(new Error(errorMsg), constants_1.SolutionSource, constants_1.SolutionError.FailedToListCollaborator), telemetryReporter)),
                };
                continue;
            }
            const teamsAppOwners = results[0].isErr() ? [] : results[0].value;
            const aadOwners = results[1].isErr() ? [] : results[1].value;
            const collaborators = [];
            for (const teamsAppOwner of teamsAppOwners) {
                const aadOwner = aadOwners.find((owner) => owner.userObjectId === teamsAppOwner.userObjectId);
                collaborators.push({
                    // For guest account, aadOwner.userPrincipalName will be user's email, and is easy to read.
                    userPrincipalName: (_b = (_a = aadOwner === null || aadOwner === void 0 ? void 0 : aadOwner.userPrincipalName) !== null && _a !== void 0 ? _a : teamsAppOwner.userPrincipalName) !== null && _b !== void 0 ? _b : teamsAppOwner.userObjectId,
                    userObjectId: teamsAppOwner.userObjectId,
                    isAadOwner: aadOwner ? true : false,
                    aadResourceId: aadOwner ? aadOwner.resourceId : undefined,
                    teamsAppResourceId: teamsAppOwner.resourceId,
                });
            }
            const aadOwnerCount = collaborators.filter((collaborator) => collaborator.aadResourceId && collaborator.isAadOwner).length;
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ListAllCollaborators, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
                [constants_1.SolutionTelemetryProperty.CollaboratorCount]: collaborators.length.toString(),
                [constants_1.SolutionTelemetryProperty.AadOwnerCount]: aadOwnerCount.toString(),
                [constants_1.SolutionTelemetryProperty.Env]: common_1.getHashedEnv(env),
            });
            collaboratorsResult[env] = {
                collaborators: collaborators,
                state: common_1.CollaborationState.OK,
            };
        }
        catch (error) {
            collaboratorsResult[env] = {
                state: common_1.CollaborationState.ERROR,
                error: teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ListAllCollaborators, teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToListCollaborator), telemetryReporter)),
            };
        }
    }
    return teamsfx_api_1.ok(collaboratorsResult);
}
async function listAllCollaborators(param) {
    var _a, _b;
    if (param.apiVersion === 1) {
        const telemetryReporter = param.ctx.telemetryReporter;
        const ui = param.ctx.ui;
        const graphTokenProvider = param.ctx.graphTokenProvider;
        const platform = (_a = param.ctx.answers) === null || _a === void 0 ? void 0 : _a.platform;
        const projectPath = param.ctx.root;
        if (!projectPath) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`projectPath is undefined`), constants_1.PluginNames.SOLUTION, constants_1.SolutionError.InternelError));
        }
        return listAllCollaboratorsImpl(param, projectPath, param.ctx.cryptoProvider, telemetryReporter, ui, graphTokenProvider, platform);
    }
    else {
        const telemetryReporter = param.ctx.telemetryReporter;
        const ui = param.ctx.userInteraction;
        const graphTokenProvider = param.tokenProvider.graphTokenProvider;
        const platform = (_b = param.inputs) === null || _b === void 0 ? void 0 : _b.platform;
        return listAllCollaboratorsImpl(param, param.inputs.projectPath, param.ctx.cryptoProvider, telemetryReporter, ui, graphTokenProvider, platform);
    }
}
exports.listAllCollaborators = listAllCollaborators;
//# sourceMappingURL=listAllCollaborators.js.map