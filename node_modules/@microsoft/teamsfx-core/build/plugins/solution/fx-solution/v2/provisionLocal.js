"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionLocalResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const executor_1 = require("./executor");
const utils_1 = require("./utils");
const constants_1 = require("../constants");
const lodash_1 = require("lodash");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const environment_1 = require("../../../../core/environment");
const permissionRequest_1 = require("../../../../core/permissionRequest");
const localSettingsConstants_1 = require("../../../../common/localSettingsConstants");
const provisionLocal_1 = require("../debug/provisionLocal");
async function provisionLocalResource(ctx, inputs, localSettings, tokenProvider) {
    if (inputs.projectPath === undefined) {
        return new teamsfx_api_1.v2.FxFailure(teamsfx_api_1.returnSystemError(new Error("projectPath is undefined"), "Solution", constants_1.SolutionError.InternelError));
    }
    const azureSolutionSettings = utils_1.getAzureSolutionSettings(ctx);
    if (utils_1.isAzureProject(azureSolutionSettings)) {
        if (ctx.permissionRequestProvider === undefined) {
            ctx.permissionRequestProvider = new permissionRequest_1.PermissionRequestFileProvider(inputs.projectPath);
        }
        const result = await utils_1.ensurePermissionRequest(azureSolutionSettings, ctx.permissionRequestProvider);
        if (result.isErr()) {
            return new teamsfx_api_1.v2.FxFailure(result.error);
        }
    }
    // Just to trigger M365 login before the concurrent execution of localDebug.
    // Because concurrent execution of localDebug may getAccessToken() concurrently, which
    // causes 2 M365 logins before the token caching in common lib takes effect.
    await tokenProvider.appStudioToken.getAccessToken();
    // Pop-up window to confirm if local debug in another tenant
    const localDebugTenantId = localSettings.teamsApp[localSettingsConstants_1.LocalSettingsTeamsAppKeys.TenantId];
    const m365TenantMatches = await utils_1.checkWhetherLocalDebugM365TenantMatches(localDebugTenantId, tokenProvider.appStudioToken);
    if (m365TenantMatches.isErr()) {
        return new teamsfx_api_1.v2.FxFailure(m365TenantMatches.error);
    }
    const plugins = utils_1.getSelectedPlugins(azureSolutionSettings);
    const provisionLocalResourceThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.provisionLocalResource))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "provisionLocalResource",
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            thunk: () => plugin.provisionLocalResource(ctx, inputs, localSettings, tokenProvider),
        };
    });
    const provisionResult = await executor_1.executeConcurrently(provisionLocalResourceThunks, ctx.logProvider);
    if (provisionResult.kind !== "success") {
        return provisionResult;
    }
    const debugProvisionResult = await provisionLocal_1.setupLocalDebugSettings(ctx, inputs, localSettings);
    if (debugProvisionResult.isErr()) {
        return new teamsfx_api_1.v2.FxPartialSuccess(localSettings, debugProvisionResult.error);
    }
    const aadPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
    if (utils_1.isAzureProject(azureSolutionSettings)) {
        if (plugins.some((plugin) => plugin.name === aadPlugin.name) && aadPlugin.executeUserTask) {
            const result = await aadPlugin.executeUserTask(ctx, inputs, {
                namespace: `${constants_1.PluginNames.SOLUTION}/${constants_1.PluginNames.AAD}`,
                method: "setApplicationInContext",
                params: { isLocal: true },
            }, localSettings, { envName: environment_1.environmentManager.getDefaultEnvName(), config: {}, state: {} }, tokenProvider);
            if (result.isErr()) {
                return new teamsfx_api_1.v2.FxPartialSuccess(localSettings, result.error);
            }
        }
        else {
            if (!ctx.projectSetting.solutionSettings.migrateFromV1) {
                return new teamsfx_api_1.v2.FxFailure(teamsfx_api_1.returnSystemError(new Error("AAD plugin not selected or executeUserTask is undefined"), constants_1.SolutionSource, constants_1.SolutionError.InternelError));
            }
        }
    }
    const parseTenantIdresult = utils_1.loadTeamsAppTenantIdForLocal(localSettings, await tokenProvider.appStudioToken.getJsonObject());
    if (parseTenantIdresult.isErr()) {
        return new teamsfx_api_1.v2.FxFailure(parseTenantIdresult.error);
    }
    const configureLocalResourceThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.configureLocalResource))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "configureLocalResource",
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            thunk: () => plugin.configureLocalResource(ctx, inputs, localSettings, tokenProvider),
        };
    });
    const configureResourceResult = await executor_1.executeConcurrently(configureLocalResourceThunks, ctx.logProvider);
    if (configureResourceResult.kind !== "success") {
        if (configureResourceResult.kind === "partialSuccess") {
            return new teamsfx_api_1.v2.FxPartialSuccess(localSettings, configureResourceResult.error);
        }
        return new teamsfx_api_1.v2.FxFailure(configureResourceResult.error);
    }
    const debugConfigResult = await provisionLocal_1.configLocalDebugSettings(ctx, inputs, localSettings);
    if (debugConfigResult.isErr()) {
        return new teamsfx_api_1.v2.FxPartialSuccess(localSettings, debugConfigResult.error);
    }
    return new teamsfx_api_1.v2.FxSuccess(localSettings);
}
exports.provisionLocalResource = provisionLocalResource;
//# sourceMappingURL=provisionLocal.js.map