"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const constants_2 = require("../constants");
const question_1 = require("../question");
const executor_1 = require("./executor");
const utils_1 = require("./utils");
async function deploy(ctx, inputs, envInfo, tokenProvider) {
    const provisionOutputs = envInfo.state;
    const inAzureProject = utils_1.isAzureProject(utils_1.getAzureSolutionSettings(ctx));
    const provisioned = provisionOutputs[constants_2.GLOBAL_CONFIG]["output"][constants_2.SOLUTION_PROVISION_SUCCEEDED];
    if (inAzureProject && !provisioned) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(util.format(tools_1.getStrings().solution.NotProvisionedNotice, ctx.projectSetting.appName)), constants_2.SolutionSource, constants_2.SolutionError.CannotDeployBeforeProvision));
    }
    const optionsToDeploy = inputs[question_1.AzureSolutionQuestionNames.PluginSelectionDeploy];
    if (optionsToDeploy === undefined || optionsToDeploy.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`No plugin selected`), constants_2.SolutionSource, constants_2.SolutionError.NoResourcePluginSelected));
    }
    const plugins = utils_1.getSelectedPlugins(utils_1.getAzureSolutionSettings(ctx));
    const thunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.deploy) && optionsToDeploy.includes(plugin.name))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "deploy",
            thunk: () => 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            plugin.deploy(ctx, Object.assign(Object.assign(Object.assign({}, inputs), utils_1.extractSolutionInputs(provisionOutputs[constants_2.GLOBAL_CONFIG]["output"])), { projectPath: inputs.projectPath }), envInfo, tokenProvider),
        };
    });
    if (thunks.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`invalid options: [${optionsToDeploy.join(", ")}]`), constants_2.SolutionSource, constants_2.SolutionError.NoResourcePluginSelected));
    }
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.SelectedPluginsToDeployNotice, constants_1.PluginDisplayName.Solution, JSON.stringify(thunks.map((p) => p.pluginName))));
    ctx.logProvider.info(util.format(tools_1.getStrings().solution.DeployStartNotice, constants_1.PluginDisplayName.Solution));
    const result = await executor_1.executeConcurrently(thunks, ctx.logProvider);
    if (result.kind === "success") {
        if (inAzureProject) {
            const msg = util.format(`Success: ${tools_1.getStrings().solution.DeploySuccessNotice}`, ctx.projectSetting.appName);
            ctx.logProvider.info(msg);
            ctx.userInteraction.showMessage("info", msg, false);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    else {
        const msg = util.format(tools_1.getStrings().solution.DeployFailNotice, ctx.projectSetting.appName);
        ctx.logProvider.info(msg);
        return teamsfx_api_1.err(result.error);
    }
}
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map