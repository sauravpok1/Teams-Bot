"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPluginAndContextArray = exports.checkWetherProvisionSucceeded = exports.fillInSolutionSettings = exports.loadTeamsAppTenantIdForLocal = exports.checkWhetherLocalDebugM365TenantMatches = exports.parseUserName = exports.parseTeamsAppTenantId = exports.ensurePermissionRequest = exports.reloadV2Plugins = exports.extractSolutionInputs = exports.combineRecords = exports.isAzureProject = exports.getAzureSolutionSettings = exports.getSelectedPlugins = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localSettingsConstants_1 = require("../../../../common/localSettingsConstants");
const tools_1 = require("../../../../common/tools");
const constants_1 = require("../constants");
const question_1 = require("../question");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const util_1 = require("../utils/util");
const util = tslib_1.__importStar(require("util"));
function getSelectedPlugins(azureSettings) {
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSettings);
    azureSettings.activeResourcePlugins = plugins.map((p) => p.name);
    return plugins;
}
exports.getSelectedPlugins = getSelectedPlugins;
function getAzureSolutionSettings(ctx) {
    return ctx.projectSetting.solutionSettings;
}
exports.getAzureSolutionSettings = getAzureSolutionSettings;
function isAzureProject(azureSettings) {
    return question_1.HostTypeOptionAzure.id === azureSettings.hostType;
}
exports.isAzureProject = isAzureProject;
function combineRecords(records) {
    const ret = {};
    for (const record of records) {
        ret[record.name] = record.result;
    }
    return ret;
}
exports.combineRecords = combineRecords;
function extractSolutionInputs(record) {
    return {
        resourceNameSuffix: record["resourceNameSuffix"],
        resourceGroupName: record["resourceGroupName"],
        location: record["location"],
        teamsAppTenantId: record["teamsAppTenantId"],
        remoteTeamsAppId: undefined,
        subscriptionId: record["subscriptionId"],
        provisionSucceeded: record[constants_1.SOLUTION_PROVISION_SUCCEEDED],
        tenantId: record["tenantId"],
    };
}
exports.extractSolutionInputs = extractSolutionInputs;
function reloadV2Plugins(solutionSettings) {
    const res = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(solutionSettings);
    solutionSettings.activeResourcePlugins = res.map((p) => p.name);
    return res;
}
exports.reloadV2Plugins = reloadV2Plugins;
async function ensurePermissionRequest(solutionSettings, permissionRequestProvider) {
    if (solutionSettings.migrateFromV1) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    if (!isAzureProject(solutionSettings)) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Cannot update permission for SPFx project"), constants_1.SolutionSource, constants_1.SolutionError.CannotUpdatePermissionForSPFx));
    }
    const result = await permissionRequestProvider.checkPermissionRequest();
    if (result && result.isErr()) {
        return result.map(teamsfx_api_1.err);
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.ensurePermissionRequest = ensurePermissionRequest;
function parseTeamsAppTenantId(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Graph token json is undefined"), constants_1.SolutionSource, constants_1.SolutionError.NoAppStudioToken));
    }
    const teamsAppTenantId = appStudioToken["tid"];
    if (teamsAppTenantId === undefined ||
        !(typeof teamsAppTenantId === "string") ||
        teamsAppTenantId.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Cannot find teams app tenant id"), constants_1.SolutionSource, constants_1.SolutionError.NoTeamsAppTenantId));
    }
    return teamsfx_api_1.ok(teamsAppTenantId);
}
exports.parseTeamsAppTenantId = parseTeamsAppTenantId;
function parseUserName(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Graph token json is undefined"), "Solution", constants_1.SolutionError.NoAppStudioToken));
    }
    const userName = appStudioToken["upn"];
    if (userName === undefined || !(typeof userName === "string") || userName.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Cannot find user name from App Studio token."), "Solution", constants_1.SolutionError.NoUserName));
    }
    return teamsfx_api_1.ok(userName);
}
exports.parseUserName = parseUserName;
async function checkWhetherLocalDebugM365TenantMatches(localDebugTenantId, appStudioTokenProvider) {
    if (localDebugTenantId) {
        const m365TenantId = parseTeamsAppTenantId(await (appStudioTokenProvider === null || appStudioTokenProvider === void 0 ? void 0 : appStudioTokenProvider.getJsonObject()));
        if (m365TenantId.isErr()) {
            throw teamsfx_api_1.err(m365TenantId.error);
        }
        const m365UserAccount = parseUserName(await (appStudioTokenProvider === null || appStudioTokenProvider === void 0 ? void 0 : appStudioTokenProvider.getJsonObject()));
        if (m365UserAccount.isErr()) {
            throw teamsfx_api_1.err(m365UserAccount.error);
        }
        if (m365TenantId.value !== localDebugTenantId) {
            const errorMessage = util.format(tools_1.getStrings().solution.LocalDebugTenantConfirmNotice, localDebugTenantId, m365UserAccount.value, tools_1.isMultiEnvEnabled() ? "localSettings.json" : "default.userdata");
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(errorMessage), "Solution", constants_1.SolutionError.CannotLocalDebugInDifferentTenant));
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.checkWhetherLocalDebugM365TenantMatches = checkWhetherLocalDebugM365TenantMatches;
// Loads teams app tenant id into local settings.
function loadTeamsAppTenantIdForLocal(localSettings, appStudioToken) {
    return parseTeamsAppTenantId(appStudioToken).andThen((teamsAppTenantId) => {
        localSettings.teamsApp[localSettingsConstants_1.LocalSettingsTeamsAppKeys.TenantId] = teamsAppTenantId;
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    });
}
exports.loadTeamsAppTenantIdForLocal = loadTeamsAppTenantIdForLocal;
function fillInSolutionSettings(solutionSettings, answers) {
    let capabilities = answers[question_1.AzureSolutionQuestionNames.Capabilities] || [];
    if (!capabilities || capabilities.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("capabilities is empty"), constants_1.SolutionSource, constants_1.SolutionError.InternelError));
    }
    let hostType = answers[question_1.AzureSolutionQuestionNames.HostType];
    if (capabilities.includes(question_1.BotOptionItem.id) ||
        capabilities.includes(question_1.MessageExtensionItem.id) ||
        capabilities.includes(question_1.TabOptionItem.id)) {
        hostType = question_1.HostTypeOptionAzure.id;
    }
    else if (capabilities.includes(question_1.TabSPFxItem.id)) {
        // set capabilities to TabOptionItem in case of TabSPFx item, so donot impact capabilities.includes() check overall
        capabilities = [question_1.TabOptionItem.id];
        hostType = question_1.HostTypeOptionSPFx.id;
    }
    if (!hostType) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("hostType is undefined"), constants_1.SolutionSource, constants_1.SolutionError.InternelError));
    }
    solutionSettings.hostType = hostType;
    let azureResources;
    if (hostType === question_1.HostTypeOptionAzure.id && capabilities.includes(question_1.TabOptionItem.id)) {
        azureResources = answers[question_1.AzureSolutionQuestionNames.AzureResources];
        if (azureResources) {
            if ((azureResources.includes(question_1.AzureResourceSQL.id) ||
                azureResources.includes(question_1.AzureResourceApim.id)) &&
                !azureResources.includes(question_1.AzureResourceFunction.id)) {
                azureResources.push(question_1.AzureResourceFunction.id);
            }
        }
        else
            azureResources = [];
    }
    solutionSettings.azureResources = azureResources || [];
    solutionSettings.capabilities = capabilities || [];
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.fillInSolutionSettings = fillInSolutionSettings;
function checkWetherProvisionSucceeded(config) {
    return (config[constants_1.GLOBAL_CONFIG] &&
        config[constants_1.GLOBAL_CONFIG]["output"] &&
        config[constants_1.GLOBAL_CONFIG]["output"][constants_1.SOLUTION_PROVISION_SUCCEEDED]);
}
exports.checkWetherProvisionSucceeded = checkWetherProvisionSucceeded;
function getPluginAndContextArray(ctx, selectedPlugins) {
    return selectedPlugins.map((plugin) => [plugin, util_1.getPluginContext(ctx, plugin.name)]);
}
exports.getPluginAndContextArray = getPluginAndContextArray;
//# sourceMappingURL=utils.js.map