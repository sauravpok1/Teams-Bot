"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractParamForRegisterTeamsAppAndAad = exports.addResource = exports.showUpdateArmTemplateNotice = exports.addCapability = exports.canAddResource = exports.canAddCapability = exports.executeUserTask = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../../../common/tools");
const utils_1 = require("./utils");
const constants_1 = require("../constants");
const util = tslib_1.__importStar(require("util"));
const question_1 = require("../question");
const lodash_1 = require("lodash");
const util_1 = require("../utils/util");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const typedi_1 = require("typedi");
const scaffolding_1 = require("./scaffolding");
const generateResourceTemplate_1 = require("./generateResourceTemplate");
const scaffolding_2 = require("../debug/scaffolding");
async function executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider) {
    const namespace = func.namespace;
    const method = func.method;
    const array = namespace.split("/");
    if (method === "addCapability") {
        return addCapability(ctx, inputs, localSettings);
    }
    if (method === "addResource") {
        return addResource(ctx, inputs, localSettings, func, envInfo, tokenProvider);
    }
    if (namespace.includes("solution")) {
        if (method === "registerTeamsAppAndAad") {
            // not implemented for now
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Not implemented"), constants_1.SolutionSource, constants_1.SolutionError.FeatureNotSupported));
        }
        else if (method === "VSpublish") {
            // VSpublish means VS calling cli to do publish. It is different than normal cli work flow
            // It's teamsfx init followed by teamsfx  publish without running provision.
            // Using executeUserTask here could bypass the fx project check.
            if (inputs.platform !== "vs") {
                return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`VS publish is not supposed to run on platform ${inputs.platform}`), constants_1.SolutionSource, constants_1.SolutionError.UnsupportedPlatform));
            }
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.publishApplication) {
                return appStudioPlugin.publishApplication(ctx, inputs, envInfo, tokenProvider.appStudioToken);
            }
        }
        else if (method === "validateManifest") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return await appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (method === "buildPackage") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return await appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (method === "validateManifest") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (array.length == 2) {
            const pluginName = array[1];
            const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
            const plugin = pluginMap.get(pluginName);
            if (plugin && plugin.executeUserTask) {
                return plugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
    }
    return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`executeUserTaskRouteFailed:${JSON.stringify(func)}`), constants_1.SolutionSource, `executeUserTaskRouteFailed`));
}
exports.executeUserTask = executeUserTask;
function canAddCapability(settings, telemetryReporter) {
    if (!(settings.hostType === question_1.HostTypeOptionAzure.id)) {
        const e = teamsfx_api_1.returnUserError(new Error("Add capability is not supported for SPFx project"), constants_1.SolutionSource, constants_1.SolutionError.FailedToAddCapability);
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddCapability, e, telemetryReporter));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.canAddCapability = canAddCapability;
function canAddResource(settings, telemetryReporter) {
    if (!(settings.hostType === question_1.HostTypeOptionAzure.id &&
        settings.capabilities &&
        settings.capabilities.includes(question_1.TabOptionItem.id))) {
        const e = teamsfx_api_1.returnUserError(new Error("Add resource is only supported for Tab app hosted in Azure."), constants_1.SolutionSource, constants_1.SolutionError.AddResourceNotSupport);
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddResource, e, telemetryReporter));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.canAddResource = canAddResource;
async function addCapability(ctx, inputs, localSettings) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    ctx.telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddCapabilityStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    const settings = utils_1.getAzureSolutionSettings(ctx);
    const originalSettings = lodash_1.cloneDeep(settings);
    const canProceed = canAddCapability(settings, ctx.telemetryReporter);
    if (canProceed.isErr()) {
        return teamsfx_api_1.err(canProceed.error);
    }
    const capabilitiesAnswer = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
    if (!capabilitiesAnswer || capabilitiesAnswer.length === 0) {
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddCapability, {
            [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
            [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            [constants_1.SolutionTelemetryProperty.Capabilities]: [].join(";"),
        });
        return teamsfx_api_1.ok({});
    }
    const alreadyHaveBotAndAddBot = (((_b = settings.capabilities) === null || _b === void 0 ? void 0 : _b.includes(question_1.BotOptionItem.id)) ||
        ((_c = settings.capabilities) === null || _c === void 0 ? void 0 : _c.includes(question_1.MessageExtensionItem.id))) &&
        (capabilitiesAnswer.includes(question_1.BotOptionItem.id) ||
            capabilitiesAnswer.includes(question_1.MessageExtensionItem.id));
    const alreadyHaveTabAndAddTab = ((_d = settings.capabilities) === null || _d === void 0 ? void 0 : _d.includes(question_1.TabOptionItem.id)) &&
        capabilitiesAnswer.includes(question_1.TabOptionItem.id);
    if (alreadyHaveBotAndAddBot || alreadyHaveTabAndAddTab) {
        const e = teamsfx_api_1.returnUserError(new Error("There are no additional capabilities you can add to your project."), constants_1.SolutionSource, constants_1.SolutionError.FailedToAddCapability);
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddCapability, e, ctx.telemetryReporter));
    }
    let change = false;
    const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
    const frontendPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
    const botPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
    const pluginsToScaffold = [appStudioPlugin];
    const capabilities = Array.from(settings.capabilities);
    for (const cap of capabilitiesAnswer) {
        if (!capabilities.includes(cap)) {
            capabilities.push(cap);
            change = true;
            if (cap === question_1.TabOptionItem.id) {
                pluginsToScaffold.push(frontendPlugin);
                pluginsToScaffold.push(typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.SimpleAuthPlugin));
            }
            else if ((cap === question_1.BotOptionItem.id || cap === question_1.MessageExtensionItem.id) &&
                !pluginsToScaffold.includes(botPlugin)) {
                pluginsToScaffold.push(botPlugin);
            }
        }
    }
    if (change) {
        if (tools_1.isArmSupportEnabled()) {
            showUpdateArmTemplateNotice(ctx.userInteraction);
        }
        settings.capabilities = capabilities;
        utils_1.reloadV2Plugins(settings);
        const pluginNames = pluginsToScaffold.map((p) => p.name).join(",");
        (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(`start scaffolding ${pluginNames}.....`);
        const scaffoldRes = await scaffoldCodeAndResourceTemplate(ctx, inputs, localSettings, pluginsToScaffold, true);
        if (scaffoldRes.isErr()) {
            (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.info(`failed to scaffold ${pluginNames}!`);
            ctx.projectSetting.solutionSettings = originalSettings;
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddCapability, scaffoldRes.error, ctx.telemetryReporter));
        }
        (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(`finish scaffolding ${pluginNames}!`);
        const addNames = capabilitiesAnswer.map((c) => `'${c}'`).join(" and ");
        const single = capabilitiesAnswer.length === 1;
        const template = inputs.platform === teamsfx_api_1.Platform.CLI
            ? single
                ? tools_1.getStrings().solution.AddCapabilityNoticeForCli
                : tools_1.getStrings().solution.AddCapabilitiesNoticeForCli
            : single
                ? tools_1.getStrings().solution.AddCapabilityNotice
                : tools_1.getStrings().solution.AddCapabilitiesNotice;
        const msg = util.format(template, addNames);
        ctx.userInteraction.showMessage("info", msg, false);
        (_h = ctx.telemetryReporter) === null || _h === void 0 ? void 0 : _h.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddCapability, {
            [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
            [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            [constants_1.SolutionTelemetryProperty.Capabilities]: capabilitiesAnswer.join(";"),
        });
        return teamsfx_api_1.ok({ solutionSettings: settings, solutionConfig: { provisionSucceeded: false } });
    }
    const cannotAddCapWarnMsg = "Add nothing";
    ctx.userInteraction.showMessage("warn", cannotAddCapWarnMsg, false);
    ctx.telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddCapability, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
        [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
        [constants_1.SolutionTelemetryProperty.Capabilities]: [].join(";"),
    });
    return teamsfx_api_1.ok({});
}
exports.addCapability = addCapability;
function showUpdateArmTemplateNotice(ui) {
    const msg = util.format(tools_1.getStrings().solution.UpdateArmTemplateNotice);
    ui === null || ui === void 0 ? void 0 : ui.showMessage("info", msg, false);
}
exports.showUpdateArmTemplateNotice = showUpdateArmTemplateNotice;
async function scaffoldCodeAndResourceTemplate(ctx, inputs, localSettings, pluginsToScaffold, generateTemplate, pluginsToDoArm) {
    const result = await scaffolding_1.scaffoldByPlugins(ctx, inputs, localSettings, pluginsToScaffold);
    if (result.isErr()) {
        return result;
    }
    if (!generateTemplate || !tools_1.isArmSupportEnabled()) {
        return result;
    }
    const scaffoldLocalDebugSettingsResult = await scaffolding_2.scaffoldLocalDebugSettings(ctx, inputs, localSettings);
    if (scaffoldLocalDebugSettingsResult.isErr()) {
        return scaffoldLocalDebugSettingsResult;
    }
    return generateResourceTemplate_1.generateResourceTemplateForPlugins(ctx, inputs, pluginsToDoArm ? pluginsToDoArm : pluginsToScaffold);
}
async function addResource(ctx, inputs, localSettings, func, envInfo, tokenProvider) {
    var _a, _b, _c, _d, _e;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddResourceStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    const settings = utils_1.getAzureSolutionSettings(ctx);
    const canProceed = canAddResource(settings, ctx.telemetryReporter);
    if (canProceed.isErr()) {
        return canProceed;
    }
    const selectedPlugins = settings.activeResourcePlugins;
    const functionPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin);
    const sqlPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin);
    const apimPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.ApimPlugin);
    const keyVaultPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.KeyVaultPlugin);
    const alreadyHaveFunction = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(functionPlugin.name);
    const alreadyHaveSql = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(sqlPlugin.name);
    const alreadyHaveApim = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(apimPlugin.name);
    const alreadyHaveKeyVault = selectedPlugins === null || selectedPlugins === void 0 ? void 0 : selectedPlugins.includes(keyVaultPlugin.name);
    const addResourcesAnswer = inputs[question_1.AzureSolutionQuestionNames.AddResources];
    if (!addResourcesAnswer) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(`answer of ${question_1.AzureSolutionQuestionNames.AddResources} is empty!`), constants_1.SolutionSource, constants_1.SolutionError.InvalidInput));
    }
    const addSQL = addResourcesAnswer.includes(question_1.AzureResourceSQL.id);
    const addFunc = addResourcesAnswer.includes(question_1.AzureResourceFunction.id);
    const addApim = addResourcesAnswer.includes(question_1.AzureResourceApim.id);
    const addKeyVault = addResourcesAnswer.includes(question_1.AzureResourceKeyVault.id);
    if ((alreadyHaveSql && addSQL) ||
        (alreadyHaveApim && addApim) ||
        (alreadyHaveKeyVault && addKeyVault)) {
        const e = teamsfx_api_1.returnUserError(new Error("SQL/APIM/KeyVault is already added."), constants_1.SolutionSource, constants_1.SolutionError.AddResourceNotSupport);
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddResource, e, ctx.telemetryReporter));
    }
    let addNewResourceToProvision = false;
    const notifications = [];
    const pluginsToScaffold = [];
    const pluginsToDoArm = [];
    const azureResource = Array.from(settings.azureResources || []);
    let scaffoldApim = false;
    if (addFunc || ((addSQL || addApim) && !alreadyHaveFunction)) {
        pluginsToScaffold.push(functionPlugin);
        if (!azureResource.includes(question_1.AzureResourceFunction.id)) {
            azureResource.push(question_1.AzureResourceFunction.id);
            addNewResourceToProvision = true;
            pluginsToDoArm.push(functionPlugin);
        }
        notifications.push(question_1.AzureResourceFunction.label);
    }
    if (addSQL && !alreadyHaveSql) {
        pluginsToScaffold.push(sqlPlugin);
        pluginsToDoArm.push(sqlPlugin);
        azureResource.push(question_1.AzureResourceSQL.id);
        notifications.push(question_1.AzureResourceSQL.label);
        addNewResourceToProvision = true;
    }
    if (addApim && !alreadyHaveApim) {
        // We don't add apimPlugin into pluginsToScaffold because
        // apim plugin needs to modify config output during scaffolding,
        // which is not supported by the scaffoldSourceCode API.
        // The scaffolding will run later as a usertask as a work around.
        azureResource.push(question_1.AzureResourceApim.id);
        notifications.push(question_1.AzureResourceApim.label);
        addNewResourceToProvision = true;
        pluginsToDoArm.push(apimPlugin);
        scaffoldApim = true;
    }
    if (addKeyVault && !alreadyHaveKeyVault) {
        pluginsToScaffold.push(keyVaultPlugin);
        pluginsToDoArm.push(keyVaultPlugin);
        azureResource.push(question_1.AzureResourceKeyVault.id);
        notifications.push(question_1.AzureResourceKeyVault.label);
        addNewResourceToProvision = true;
    }
    if (notifications.length > 0) {
        if (tools_1.isArmSupportEnabled() && addNewResourceToProvision) {
            showUpdateArmTemplateNotice(ctx.userInteraction);
        }
        settings.azureResources = azureResource;
        utils_1.reloadV2Plugins(settings);
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`start scaffolding ${notifications.join(",")}.....`);
        let scaffoldRes = await scaffoldCodeAndResourceTemplate(ctx, inputs, localSettings, pluginsToScaffold, addNewResourceToProvision, pluginsToDoArm);
        if (scaffoldApim) {
            if (apimPlugin && apimPlugin.executeUserTask) {
                const result = await apimPlugin.executeUserTask(ctx, inputs, func, {}, envInfo, tokenProvider);
                if (result.isErr()) {
                    scaffoldRes = teamsfx_api_1.combine([scaffoldRes, result]);
                }
            }
        }
        if (scaffoldRes.isErr()) {
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`failed to scaffold ${notifications.join(",")}!`);
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.AddResource, scaffoldRes.error, ctx.telemetryReporter));
        }
        (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(`finish scaffolding ${notifications.join(",")}!`);
        ctx.userInteraction.showMessage("info", util.format(inputs.platform === teamsfx_api_1.Platform.CLI
            ? tools_1.getStrings().solution.AddResourceNoticeForCli
            : tools_1.getStrings().solution.AddResourceNotice, notifications.join(",")), false);
    }
    (_e = ctx.telemetryReporter) === null || _e === void 0 ? void 0 : _e.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.AddResource, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
        [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
        [constants_1.SolutionTelemetryProperty.Resources]: addResourcesAnswer.join(";"),
    });
    return teamsfx_api_1.ok(addNewResourceToProvision
        ? { solutionSettings: settings, solutionConfig: { provisionSucceeded: false } }
        : teamsfx_api_1.Void);
}
exports.addResource = addResource;
function extractParamForRegisterTeamsAppAndAad(answers) {
    if (answers == undefined) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Input is undefined"), constants_1.SolutionSource, constants_1.SolutionError.FailedToGetParamForRegisterTeamsAppAndAad));
    }
    const param = {
        "app-name": "",
        endpoint: "",
        environment: "local",
        "root-path": "",
    };
    for (const key of Object.keys(param)) {
        const value = answers[key];
        if (value == undefined) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`${key} not found`), constants_1.SolutionSource, constants_1.SolutionError.FailedToGetParamForRegisterTeamsAppAndAad));
        }
        param[key] = value;
    }
    return teamsfx_api_1.ok(param);
}
exports.extractParamForRegisterTeamsAppAndAad = extractParamForRegisterTeamsAppAndAad;
//# sourceMappingURL=executeUserTask.js.map