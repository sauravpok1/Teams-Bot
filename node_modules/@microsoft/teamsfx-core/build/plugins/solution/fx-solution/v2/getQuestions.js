"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsForAddResource = exports.getQuestionsForAddCapability = exports.getQuestionsForUserTask = exports.getQuestions = exports.getTabScaffoldQuestionsV2 = exports.getQuestionsForScaffolding = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
const tools_1 = require("../../../../common/tools");
const constants_1 = require("../../../../common/constants");
const constants_2 = require("../constants");
const question_1 = require("../question");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const utils_1 = require("./utils");
const __1 = require("../../../..");
const constants_3 = require("./constants");
async function getQuestionsForScaffolding(ctx, inputs) {
    const node = new teamsfx_api_1.QTreeNode({
        name: "azure-solution-group",
        type: "func",
        func: (inputs) => {
            inputs[question_1.AzureSolutionQuestionNames.Solution] = constants_3.TeamsAppSolutionNameV2;
        },
    });
    if (!__1.isV3()) {
        node.condition = {
            containsAny: [question_1.TabSPFxItem.id, question_1.TabOptionItem.id, question_1.BotOptionItem.id, question_1.MessageExtensionItem.id],
        };
        // 1.1.1 SPFX Tab
        const spfxPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SpfxPlugin);
        if (spfxPlugin.getQuestionsForScaffolding) {
            const res = await spfxPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const spfxNode = res.value;
                spfxNode.condition = {
                    validFunc: (input, inputs) => {
                        if (!inputs) {
                            return "Invalid inputs";
                        }
                        const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                        if (cap.includes(question_1.TabSPFxItem.id)) {
                            return undefined;
                        }
                        return "SPFx is not selected";
                    },
                };
                if (spfxNode.data)
                    node.addChild(spfxNode);
            }
        }
    }
    else {
        node.condition = { containsAny: [question_1.TabOptionItem.id, question_1.BotOptionItem.id, question_1.MessageExtensionItem.id] };
    }
    // 1.1.2 Azure Tab
    const tabRes = await getTabScaffoldQuestionsV2(ctx, inputs, teamsfx_api_1.CLIPlatforms.includes(inputs.platform) // only CLI and CLI_HELP support azure-resources question
    );
    if (tabRes.isErr())
        return tabRes;
    if (tabRes.value) {
        const tabNode = tabRes.value;
        tabNode.condition = {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    return "Invalid inputs";
                }
                const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                if (cap.includes(question_1.TabOptionItem.id)) {
                    return undefined;
                }
                return "Tab is not selected";
            },
        };
        node.addChild(tabNode);
    }
    // 1.2 Bot
    const botPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
    if (botPlugin.getQuestionsForScaffolding) {
        const res = await botPlugin.getQuestionsForScaffolding(ctx, inputs);
        if (res.isErr())
            return res;
        if (res.value) {
            const botGroup = res.value;
            botGroup.condition = {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        return "Invalid inputs";
                    }
                    const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                    if (cap.includes(question_1.BotOptionItem.id) || cap.includes(question_1.MessageExtensionItem.id)) {
                        return undefined;
                    }
                    return "Bot/Message Extension is not selected";
                },
            };
            node.addChild(botGroup);
        }
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForScaffolding = getQuestionsForScaffolding;
async function getTabScaffoldQuestionsV2(ctx, inputs, addAzureResource) {
    const tabNode = new teamsfx_api_1.QTreeNode({ type: "group" });
    //Frontend plugin
    const fehostPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
    if (fehostPlugin.getQuestionsForScaffolding) {
        const res = await fehostPlugin.getQuestionsForScaffolding(ctx, inputs);
        if (res.isErr())
            return res;
        if (res.value) {
            const frontendNode = res.value;
            if (frontendNode.data)
                tabNode.addChild(frontendNode);
        }
    }
    if (addAzureResource) {
        const azureResourceNode = new teamsfx_api_1.QTreeNode(question_1.AzureResourcesQuestion);
        tabNode.addChild(azureResourceNode);
        const functionPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin);
        //Azure Function
        if (functionPlugin.getQuestionsForScaffolding) {
            const res = await functionPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_function = res.value;
                azure_function.condition = { minItems: 1 };
                if (azure_function.data)
                    azureResourceNode.addChild(azure_function);
            }
        }
        const sqlPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin);
        //Azure SQL
        if (sqlPlugin.getQuestionsForScaffolding) {
            const res = await sqlPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_sql = res.value;
                azure_sql.condition = { contains: question_1.AzureResourceSQL.id };
                if (azure_sql.data)
                    azureResourceNode.addChild(azure_sql);
            }
        }
    }
    return teamsfx_api_1.ok(tabNode);
}
exports.getTabScaffoldQuestionsV2 = getTabScaffoldQuestionsV2;
async function getQuestions(ctx, inputs, envInfo, tokenProvider) {
    const stage = inputs.stage;
    if (!stage) {
        return teamsfx_api_1.err(new teamsfx_api_1.InvalidInputError(constants_2.SolutionSource, "inputs.stage", "undefined"));
    }
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    const node = new teamsfx_api_1.QTreeNode({ type: "group" });
    const solutionSettings = ctx.projectSetting.solutionSettings;
    if (stage == teamsfx_api_1.Stage.migrateV1) {
        const capQuestion = question_1.createV1CapabilityQuestion();
        const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
        node.addChild(capNode);
    }
    else if (stage === teamsfx_api_1.Stage.provision) {
        if (isDynamicQuestion) {
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (provisioned)
                return teamsfx_api_1.ok(undefined);
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(solutionSettings);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
            node.addChild(new teamsfx_api_1.QTreeNode(question_1.AskSubscriptionQuestion));
        }
        for (const plugin of plugins) {
            if (plugin.getQuestions) {
                const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                if (getQuestionRes.isErr())
                    return getQuestionRes;
                if (getQuestionRes.value) {
                    const subnode = getQuestionRes.value;
                    node.addChild(subnode);
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.deploy) {
        if (isDynamicQuestion) {
            const isAzure = utils_1.isAzureProject(solutionSettings);
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (isAzure && !provisioned) {
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(tools_1.getStrings().solution.FailedToDeployBeforeProvision), constants_2.SolutionSource, constants_2.SolutionError.CannotDeployBeforeProvision, constants_1.HelpLinks.WhyNeedProvision));
            }
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(solutionSettings);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
        }
        plugins = plugins.filter((plugin) => !!plugin.deploy);
        if (plugins.length === 0) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("No resource to deploy"), constants_2.SolutionSource, constants_2.SolutionError.NoResourceToDeploy));
        }
        const pluginPrefix = "fx-resource-";
        const options = plugins.map((plugin) => {
            const item = {
                id: plugin.name,
                label: plugin.displayName,
                cliName: plugin.name.replace(pluginPrefix, ""),
            };
            return item;
        });
        const selectQuestion = question_1.DeployPluginSelectQuestion;
        selectQuestion.staticOptions = options;
        selectQuestion.default = options.map((i) => i.id);
        const pluginSelection = new teamsfx_api_1.QTreeNode(selectQuestion);
        node.addChild(pluginSelection);
        for (const plugin of plugins) {
            if (plugin.getQuestions) {
                const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                if (getQuestionRes.isErr())
                    return getQuestionRes;
                if (getQuestionRes.value) {
                    const subnode = getQuestionRes.value;
                    subnode.condition = { contains: plugin.name };
                    if (subnode.data)
                        pluginSelection.addChild(subnode);
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.publish) {
        if (isDynamicQuestion) {
            const isAzure = utils_1.isAzureProject(solutionSettings);
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (!provisioned) {
                const errorMsg = isAzure
                    ? tools_1.getStrings().solution.FailedToPublishBeforeProvision
                    : tools_1.getStrings().solution.SPFxAskProvisionBeforePublish;
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error(errorMsg), constants_2.SolutionSource, constants_2.SolutionError.CannotPublishBeforeProvision, constants_1.HelpLinks.WhyNeedProvision));
            }
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(solutionSettings);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
        }
        plugins = plugins.filter((plugin) => !!plugin.publishApplication);
        for (const plugin of plugins) {
            if (plugin.getQuestions) {
                const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                if (getQuestionRes.isErr())
                    return getQuestionRes;
                if (getQuestionRes.value) {
                    const subnode = getQuestionRes.value;
                    node.addChild(subnode);
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.grantPermission) {
        node.addChild(new teamsfx_api_1.QTreeNode(question_1.GetUserEmailQuestion));
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestions = getQuestions;
async function getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider) {
    const namespace = func.namespace;
    const array = namespace.split("/");
    if (func.method === "addCapability") {
        return await getQuestionsForAddCapability(ctx, inputs);
    }
    if (func.method === "addResource") {
        return await getQuestionsForAddResource(ctx, inputs, func, envInfo, tokenProvider);
    }
    if (array.length == 2) {
        const pluginName = array[1];
        const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
        const plugin = pluginMap.get(pluginName);
        if (plugin && plugin.getQuestionsForUserTask) {
            return await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForUserTask = getQuestionsForUserTask;
async function getQuestionsForAddCapability(ctx, inputs) {
    var _a;
    const settings = ctx.projectSetting.solutionSettings;
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    if (!(settings.hostType === question_1.HostTypeOptionAzure.id) && isDynamicQuestion) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Add capability is not supported for SPFx project"), constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport));
    }
    const capabilities = settings.capabilities || [];
    const alreadyHaveTab = capabilities.includes(question_1.TabOptionItem.id);
    const alreadyHaveBotOrMe = capabilities.includes(question_1.BotOptionItem.id) || capabilities.includes(question_1.MessageExtensionItem.id);
    if (alreadyHaveBotOrMe && alreadyHaveTab) {
        const cannotAddCapWarnMsg = "Your App already has both Tab and Bot/Messaging extension, can not Add Capability.";
        (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("error", cannotAddCapWarnMsg, false);
        return teamsfx_api_1.ok(undefined);
    }
    const addCapQuestion = question_1.addCapabilityQuestion(alreadyHaveTab, alreadyHaveBotOrMe);
    const addCapNode = new teamsfx_api_1.QTreeNode(addCapQuestion);
    //Tab sub tree
    if (!alreadyHaveTab || !isDynamicQuestion) {
        const tabRes = await getTabScaffoldQuestionsV2(ctx, inputs, false);
        if (tabRes.isErr())
            return tabRes;
        if (tabRes.value) {
            const tabNode = tabRes.value;
            tabNode.condition = { contains: question_1.TabOptionItem.id };
            addCapNode.addChild(tabNode);
        }
    }
    // Bot has no question at all
    return teamsfx_api_1.ok(addCapNode);
}
exports.getQuestionsForAddCapability = getQuestionsForAddCapability;
async function getQuestionsForAddResource(ctx, inputs, func, envInfo, tokenProvider) {
    const settings = ctx.projectSetting.solutionSettings;
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    if (isDynamicQuestion &&
        !(settings.hostType === question_1.HostTypeOptionAzure.id &&
            settings.capabilities &&
            settings.capabilities.includes(question_1.TabOptionItem.id))) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionError.AddResourceNotSupport, "Add resource is only supported for Tab app hosted in Azure.", constants_2.SolutionSource));
    }
    const selectedPlugins = settings.activeResourcePlugins || [];
    if (!selectedPlugins) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("selectedPlugins is empty"), constants_2.SolutionSource, constants_2.SolutionError.InternelError));
    }
    const functionPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin);
    const sqlPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin);
    const apimPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.ApimPlugin);
    const keyVaultPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.KeyVaultPlugin);
    const alreadyHaveFunction = selectedPlugins.includes(functionPlugin.name);
    const alreadyHaveSQL = selectedPlugins.includes(sqlPlugin.name);
    const alreadyHaveAPIM = selectedPlugins.includes(apimPlugin.name);
    const alreadyHavekeyVault = selectedPlugins.includes(keyVaultPlugin.name);
    const addQuestion = question_1.createAddAzureResourceQuestion(alreadyHaveFunction, alreadyHaveSQL, alreadyHaveAPIM, alreadyHavekeyVault);
    const addAzureResourceNode = new teamsfx_api_1.QTreeNode(addQuestion);
    // there two cases to add function re-scaffold: 1. select add function   2. select add sql and function is not selected when creating
    if (functionPlugin.getQuestionsForUserTask) {
        const res = await functionPlugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
        if (res.isErr())
            return res;
        if (res.value) {
            const azure_function = res.value;
            if (alreadyHaveFunction) {
                // if already has function, the question will appear depends on whether user select function, otherwise, the question will always show
                azure_function.condition = { contains: question_1.AzureResourceFunction.id };
            }
            else {
                // if not function activated, select any option will trigger function question
                azure_function.condition = {
                    containsAny: [question_1.AzureResourceApim.id, question_1.AzureResourceFunction.id, question_1.AzureResourceSQL.id],
                };
            }
            if (azure_function.data)
                addAzureResourceNode.addChild(azure_function);
        }
    }
    // //Azure SQL
    // if (sqlPlugin.getQuestionsForUserTask && !alreadyHaveSQL) {
    //   const res = await sqlPlugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
    //   if (res.isErr()) return res;
    //   if (res.value) {
    //     const azure_sql = res.value as QTreeNode;
    //     azure_sql.condition = { contains: AzureResourceSQL.id };
    //     if (azure_sql.data) addAzureResourceNode.addChild(azure_sql);
    //   }
    // }
    // //APIM
    // if (apimPlugin.getQuestionsForUserTask && (!alreadyHaveAPIM || !isDynamicQuestion)) {
    //   const res = await apimPlugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
    //   if (res.isErr()) return res;
    //   if (res.value) {
    //     const apim = res.value as QTreeNode;
    //     if (apim.data.type !== "group" || (apim.children && apim.children.length > 0)) {
    //       const groupNode = new QTreeNode({ type: "group" });
    //       groupNode.condition = { contains: AzureResourceApim.id };
    //       addAzureResourceNode.addChild(groupNode);
    //       const funcNode = new QTreeNode(AskSubscriptionQuestion);
    //       AskSubscriptionQuestion.func = async (
    //         inputs: Inputs
    //       ): Promise<Result<SubscriptionInfo, FxError>> => {
    //         const res = await checkSubscription(envInfo, tokenProvider.azureAccountProvider);
    //         if (res.isOk()) {
    //           const sub = res.value;
    //           inputs.subscriptionId = sub.subscriptionId;
    //           inputs.tenantId = sub.tenantId;
    //         }
    //         return res;
    //       };
    //       groupNode.addChild(funcNode);
    //       groupNode.addChild(apim);
    //     }
    //   }
    // }
    return teamsfx_api_1.ok(addAzureResourceNode);
}
exports.getQuestionsForAddResource = getQuestionsForAddResource;
//# sourceMappingURL=getQuestions.js.map