"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPermission = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const common_1 = require("../../../../common");
const constants_1 = require("../constants");
const util_1 = require("../utils/util");
const executor_1 = require("../executor");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const utils4v2_1 = require("../../../resource/utils4v2");
const executor_2 = require("./executor");
const collaborationUtil_1 = require("./collaborationUtil");
const utils_1 = require("./utils");
async function executeCheckPermissionV1(ctx, userInfo) {
    var _a;
    const plugins = ResourcePluginContainer_1.getActivatedResourcePlugins((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings);
    const pluginsWithCtx = utils_1.getPluginAndContextArray(ctx, plugins);
    const checkPermissionWithCtx = pluginsWithCtx.map(([plugin, context]) => {
        return [
            (plugin === null || plugin === void 0 ? void 0 : plugin.checkPermission)
                ? (ctx) => plugin.checkPermission.bind(plugin)(ctx, userInfo)
                : undefined,
            context,
            plugin.name,
        ];
    });
    const results = await executor_1.executeConcurrently("", checkPermissionWithCtx);
    const permissions = [];
    const errors = [];
    for (const result of results) {
        if (result.isErr()) {
            errors.push(result);
            continue;
        }
        if (result && result.value) {
            for (const res of result.value) {
                permissions.push(res);
            }
        }
    }
    return [permissions, errors];
}
async function executeCheckPermissionV2(ctx, inputs, envInfo, tokenProvider, userInfo) {
    var _a;
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins((_a = ctx.projectSetting) === null || _a === void 0 ? void 0 : _a.solutionSettings);
    const thunks = plugins
        .filter((plugin) => !!plugin.checkPermission)
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "checkPermission",
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            thunk: () => plugin.checkPermission(ctx, inputs, envInfo, tokenProvider, userInfo),
        };
    });
    const results = await executor_2.executeConcurrently(thunks, ctx.logProvider);
    return collaborationUtil_1.CollaborationUtil.collectPermissionsAndErrors(results);
}
async function checkPermissionImpl(param, envState, envName, telemetryReporter, ui, graphTokenProvider, logProvider, platform) {
    var _a, _b;
    telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.CheckPermissionStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    const result = await collaborationUtil_1.CollaborationUtil.getCurrentUserInfo(graphTokenProvider);
    if (result.isErr()) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.CheckPermission, result.error, telemetryReporter));
    }
    const stateResult = collaborationUtil_1.CollaborationUtil.getCurrentCollaborationState(envState, result.value);
    if (stateResult.state != common_1.CollaborationState.OK) {
        if (platform === teamsfx_api_1.Platform.CLI) {
            ui === null || ui === void 0 ? void 0 : ui.showMessage("warn", stateResult.message, false);
        }
        return teamsfx_api_1.ok({
            state: stateResult.state,
            message: stateResult.message,
        });
    }
    const userInfo = result.value;
    if (platform === teamsfx_api_1.Platform.CLI) {
        const aadAppTenantId = (_a = envState.get(constants_1.PluginNames.SOLUTION)) === null || _a === void 0 ? void 0 : _a.get(constants_1.REMOTE_TEAMS_APP_TENANT_ID);
        if (!envName) {
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.CheckPermission, teamsfx_api_1.returnSystemError(new Error("Failed to get env name."), constants_1.SolutionSource, constants_1.SolutionError.FailedToGetEnvName), telemetryReporter));
        }
        const message = [
            { content: `Account used to check: `, color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: userInfo.userPrincipalName + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            {
                content: `Starting check permission for environment: `,
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            },
            { content: `${envName}\n`, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            { content: `Tenant ID: `, color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: aadAppTenantId + "\n", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
        ];
        ui === null || ui === void 0 ? void 0 : ui.showMessage("info", message, false);
    }
    const [permissions, errors] = param.apiVersion === 1
        ? await executeCheckPermissionV1(param.ctx, userInfo)
        : await executeCheckPermissionV2(param.ctx, param.inputs, param.envInfo, param.tokenProvider, userInfo);
    let errorMsg = "";
    if (errors.length > 0) {
        errorMsg += `Failed to check permission for the below resources.\n Resource details: \n`;
        for (const fxError of errors) {
            errorMsg += fxError.error.message + "\n";
        }
    }
    if (platform === teamsfx_api_1.Platform.CLI) {
        for (const permission of permissions) {
            const message = [
                { content: `Resource ID: `, color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                { content: (_b = permission.resourceId) !== null && _b !== void 0 ? _b : "undefined", color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                { content: `, Resource Name: `, color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                { content: permission.name, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                { content: `, Permission: `, color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                {
                    content: permission.roles ? permission.roles.toString() : "undefined" + "\n",
                    color: teamsfx_api_1.Colors.BRIGHT_MAGENTA,
                },
            ];
            ui === null || ui === void 0 ? void 0 : ui.showMessage("info", message, false);
        }
    }
    if (errorMsg) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.CheckPermission, teamsfx_api_1.returnUserError(new Error(errorMsg), constants_1.SolutionSource, constants_1.SolutionError.FailedToCheckPermission), telemetryReporter));
    }
    const aadPermission = permissions.find((permission) => permission.name === "Azure AD App");
    const teamsAppPermission = permissions.find((permission) => permission.name === "Teams App");
    telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.CheckPermission, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
        [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
        [constants_1.SolutionTelemetryProperty.AadPermission]: (aadPermission === null || aadPermission === void 0 ? void 0 : aadPermission.roles)
            ? aadPermission.roles.join(";")
            : "undefined",
        [constants_1.SolutionTelemetryProperty.TeamsAppPermission]: (teamsAppPermission === null || teamsAppPermission === void 0 ? void 0 : teamsAppPermission.roles)
            ? teamsAppPermission.roles.join(";")
            : "undefined",
    });
    return teamsfx_api_1.ok({
        state: common_1.CollaborationState.OK,
        permissions,
    });
}
async function checkPermission(param) {
    var _a, _b;
    if (param.apiVersion === 1) {
        const envState = param.ctx.envInfo.state;
        const envName = param.ctx.envInfo.envName;
        const telemetryReporter = param.ctx.telemetryReporter;
        const ui = param.ctx.ui;
        const graphTokenProvider = param.ctx.graphTokenProvider;
        const logProvider = param.ctx.logProvider;
        const platform = (_a = param.ctx.answers) === null || _a === void 0 ? void 0 : _a.platform;
        return checkPermissionImpl(param, envState, envName, telemetryReporter, ui, graphTokenProvider, logProvider, platform);
    }
    else {
        const configMap = teamsfx_api_1.ConfigMap.fromJSON(param.envInfo.state);
        if (!configMap) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error(`failed to convert profile ${JSON.stringify(param.envInfo.state)}`), constants_1.PluginNames.SOLUTION, constants_1.SolutionError.InternelError));
        }
        const envState = utils4v2_1.flattenConfigMap(configMap);
        const envName = param.envInfo.envName;
        const telemetryReporter = param.ctx.telemetryReporter;
        const ui = param.ctx.userInteraction;
        const graphTokenProvider = param.tokenProvider.graphTokenProvider;
        const logProvider = param.ctx.logProvider;
        const platform = (_b = param.inputs) === null || _b === void 0 ? void 0 : _b.platform;
        return checkPermissionImpl(param, envState, envName, telemetryReporter, ui, graphTokenProvider, logProvider, platform);
    }
}
exports.checkPermission = checkPermission;
//# sourceMappingURL=checkPermission.js.map