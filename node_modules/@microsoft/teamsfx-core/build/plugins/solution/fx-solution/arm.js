"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.formattedDeploymentError = exports.ArmTemplateRenderContext = exports.getParameterJsonV3 = exports.getParameterJson = exports.copyParameterJson = exports.deployArmTemplatesV3 = exports.deployArmTemplates = exports.doDeployArmTemplatesV3 = exports.doDeployArmTemplates = exports.pollDeploymentStatus = exports.getRequiredOperation = exports.generateArmTemplateV3 = exports.generateArmTemplate = void 0;
const tslib_1 = require("tslib");
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const util_1 = require("util");
const constants_1 = require("./constants");
const environment_1 = require("../../../core/environment");
const common_1 = require("../../../common");
const constants_2 = require("../../../common/constants");
const cpUtils_1 = require("../../../common/cpUtils");
const tools_1 = require("../../../common/tools");
const folder_1 = require("../../../folder");
const ResourcePluginContainer_1 = require("./ResourcePluginContainer");
const bicepChecker_1 = require("./utils/depsChecker/bicepChecker");
const progressHelper_1 = require("./utils/progressHelper");
const util_2 = require("./utils/util");
const adaptor_1 = require("./v2/adaptor");
const bicepOrchestrationFileName = "main.bicep";
const bicepOrchestrationProvisionFileName = "provision.bicep";
const bicepOrchestrationConfigFileName = "config.bicep";
const templatesFolder = "./templates/azure";
const configsFolder = `.${teamsfx_api_1.ConfigFolderName}/configs`;
const parameterFileNameTemplate = `azure.parameters.${teamsfx_api_1.EnvNamePlaceholder}.json`;
const pollWaitSeconds = 10;
const maxRetryTimes = 4;
// constant string
const resourceBaseName = "resourceBaseName";
const parameterName = "parameters";
const solutionName = "solution";
const InvalidTemplateErrorCode = "InvalidTemplate";
// Get ARM template content from each resource plugin and output to project folder
async function generateArmTemplate(ctx, selectedPlugins = []) {
    var _a, _b;
    let result;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplateStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doGenerateArmTemplate(ctx, selectedPlugins);
        if (result.isOk()) {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(teamsfx_api_1.returnSystemError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToGenerateArmTemplates));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
    }
    return result;
}
exports.generateArmTemplate = generateArmTemplate;
async function generateArmTemplateV3(ctx, inputs, activatedPlugins, addedPlugins) {
    var _a, _b;
    let result;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplateStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doGenerateArmTemplateV3(ctx, inputs, activatedPlugins, addedPlugins);
        if (result.isOk()) {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(teamsfx_api_1.returnSystemError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToGenerateArmTemplates));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
    }
    return result;
}
exports.generateArmTemplateV3 = generateArmTemplateV3;
function getRequiredOperation(operation, deployCtx) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (((_b = (_a = operation.properties) === null || _a === void 0 ? void 0 : _a.targetResource) === null || _b === void 0 ? void 0 : _b.resourceName) &&
        ((_d = (_c = operation.properties) === null || _c === void 0 ? void 0 : _c.targetResource) === null || _d === void 0 ? void 0 : _d.id) &&
        operation.properties.provisioningState &&
        ((_e = operation.properties) === null || _e === void 0 ? void 0 : _e.timestamp) &&
        operation.properties.timestamp.getTime() > deployCtx.deploymentStartTime) {
        try {
            const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(operation.properties.targetResource.id);
            const subscriptionId = tools_1.getSubscriptionIdFromResourceId(operation.properties.targetResource.id);
            return {
                resourceName: (_g = (_f = operation.properties) === null || _f === void 0 ? void 0 : _f.targetResource) === null || _g === void 0 ? void 0 : _g.resourceName,
                resourceGroupName: resourceGroupName,
                subscriptionId: subscriptionId,
                resourceType: operation.properties.targetResource.resourceType,
                status: operation.properties.provisioningState,
            };
        }
        catch (error) {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.getRequiredOperation = getRequiredOperation;
async function pollDeploymentStatus(deployCtx) {
    var _a, _b, _c;
    let tryCount = 0;
    let previousStatus = {};
    let polledOperations = [];
    (_a = deployCtx.ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.PollDeploymentStatusNotice, constants_2.PluginDisplayName.Solution));
    while (!deployCtx.finished) {
        await tools_1.waitSeconds(pollWaitSeconds);
        try {
            const operations = await deployCtx.client.deploymentOperations.list(deployCtx.resourceGroupName, deployCtx.deploymentName);
            if (deployCtx.finished) {
                return;
            }
            const currentStatus = {};
            await Promise.all(operations.map(async (o) => {
                var _a;
                const operation = getRequiredOperation(o, deployCtx);
                if (operation) {
                    currentStatus[operation.resourceName] = operation.status;
                    if (!polledOperations.includes(operation.resourceName)) {
                        polledOperations.push(operation.resourceName);
                        // get sub operations when resource type is deployments.
                        if (operation.resourceType === constants_2.ConstantString.DeploymentResourceType) {
                            let client = deployCtx.client;
                            if (operation.subscriptionId !== deployCtx.client.subscriptionId) {
                                const azureToken = await ((_a = deployCtx.ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync());
                                client = new arm_resources_1.ResourceManagementClient(azureToken, operation.subscriptionId);
                            }
                            const subOperations = await client.deploymentOperations.list(operation.resourceGroupName, operation.resourceName);
                            subOperations.forEach((sub) => {
                                const subOperation = getRequiredOperation(sub, deployCtx);
                                if (subOperation) {
                                    currentStatus[subOperation.resourceName] = subOperation.status;
                                }
                            });
                        }
                    }
                }
            }));
            for (const key in currentStatus) {
                if (currentStatus[key] !== previousStatus[key]) {
                    (_b = deployCtx.ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`[${constants_2.PluginDisplayName.Solution}] ${key} -> ${currentStatus[key]}`);
                }
            }
            previousStatus = currentStatus;
            polledOperations = [];
        }
        catch (error) {
            tryCount++;
            if (tryCount < maxRetryTimes) {
                (_c = deployCtx.ctx.logProvider) === null || _c === void 0 ? void 0 : _c.warning(`[${constants_2.PluginDisplayName.Solution}] ${deployCtx.deploymentName} -> waiting to get deplomyment status [Retry time: ${tryCount}]`);
            }
            else if (tryCount === maxRetryTimes) {
                const pollError = teamsfx_api_1.returnSystemError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToPollArmDeploymentStatus);
                util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, pollError, deployCtx.ctx.telemetryReporter);
            }
        }
    }
}
exports.pollDeploymentStatus = pollDeploymentStatus;
async function doDeployArmTemplates(ctx) {
    var _a, _b, _c;
    const progressHandler = await progressHelper_1.ProgressHelper.startDeployArmTemplatesProgressHandler(ctx.ui);
    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progressHelper_1.DeployArmTemplatesSteps.ExecuteDeployment));
    // update parameters
    const parameterJson = await getParameterJson(ctx);
    const resourceGroupName = (_a = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _a === void 0 ? void 0 : _a.getString(constants_1.RESOURCE_GROUP_NAME);
    if (!resourceGroupName) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Failed to get resource group from project solution settings."), constants_1.SolutionSource, "NoResourceGroupFound"));
    }
    const bicepCommand = await bicepChecker_1.ensureBicep(ctx, ctx.answers);
    // Compile bicep file to json
    const templateDir = path_1.default.join(ctx.root, templatesFolder);
    const bicepOrchestrationFilePath = path_1.default.join(templateDir, bicepOrchestrationFileName);
    const armTemplateJson = await compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, ctx.logProvider);
    (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.CompileBicepSuccessNotice, constants_2.PluginDisplayName.Solution));
    // deploy arm templates to azure
    const subscriptionId = (_c = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.get(constants_1.SUBSCRIPTION_ID);
    const client = await getResourceManagementClientForArmDeployment(ctx.azureAccountProvider, subscriptionId);
    const deploymentName = `${constants_2.PluginDisplayName.Solution}_deployment`.replace(" ", "_").toLowerCase();
    const deploymentParameters = {
        properties: {
            parameters: parameterJson.parameters,
            template: armTemplateJson,
            mode: "Incremental",
        },
    };
    const deployCtx = {
        ctx: ctx,
        finished: false,
        deploymentStartTime: Date.now(),
        client: client,
        resourceGroupName: resourceGroupName,
        deploymentName: deploymentName,
    };
    try {
        const result = client.deployments
            .createOrUpdate(resourceGroupName, deploymentName, deploymentParameters)
            .then((result) => {
            var _a, _b;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.SuccessNotice, constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName));
            syncArmOutput(ctx.envInfo, (_b = result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
            return result;
        })
            .finally(() => {
            deployCtx.finished = true;
        });
        await pollDeploymentStatus(deployCtx);
        await result;
        return teamsfx_api_1.ok(undefined);
    }
    catch (error) {
        // return the error if the template is invalid
        if (error.code === InvalidTemplateErrorCode) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToValidateArmTemplates));
        }
        // try to get deployment error
        const result = await wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName);
        if (result.isOk()) {
            const deploymentError = result.value;
            // return thrown error if deploymentError is empty
            if (!deploymentError) {
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure));
            }
            const deploymentErrorObj = formattedDeploymentError(deploymentError);
            const deploymentErrorMessage = JSON.stringify(deploymentErrorObj, undefined, 2);
            let errorMessage = util_1.format(common_1.getStrings().solution.DeployArmTemplates.FailNotice, constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName);
            errorMessage += `\nError message: ${error.message}\nDetailed message: \n${deploymentErrorMessage}\nGet toolkit help from ${constants_2.HelpLinks.ArmHelpLink}.`;
            const notificationMessage = getNotificationMessage(deploymentError, deploymentName);
            const returnError = new teamsfx_api_1.UserError(new Error(errorMessage), constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure, constants_2.HelpLinks.ArmHelpLink, notificationMessage);
            returnError.innerError = JSON.stringify(deploymentErrorObj);
            return teamsfx_api_1.err(returnError);
        }
        else {
            return result;
        }
    }
}
exports.doDeployArmTemplates = doDeployArmTemplates;
async function doDeployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider) {
    var _a;
    const progressHandler = await progressHelper_1.ProgressHelper.startDeployArmTemplatesProgressHandler(ctx.userInteraction);
    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progressHelper_1.DeployArmTemplatesSteps.ExecuteDeployment));
    // update parameters
    const parameterJson = await getParameterJsonV3(ctx, inputs.projectPath, envInfo);
    const envState = envInfo.state;
    const resourceGroupName = envState.solution.resourceGroupName;
    if (!resourceGroupName) {
        return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Failed to get resource group from project solution settings."), constants_1.SolutionSource, "NoResourceGroupFound"));
    }
    const bicepCommand = await bicepChecker_1.ensureBicep(ctx, inputs);
    // Compile bicep file to json
    const templateDir = path_1.default.join(inputs.projectPath, templatesFolder);
    const bicepOrchestrationFilePath = path_1.default.join(templateDir, bicepOrchestrationFileName);
    const armTemplateJson = await compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, ctx.logProvider);
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.CompileBicepSuccessNotice, constants_2.PluginDisplayName.Solution));
    // deploy arm templates to azure
    const client = await getResourceManagementClientForArmDeployment(azureAccountProvider, envState.solution.subscriptionId);
    const deploymentName = `${constants_2.PluginDisplayName.Solution}_deployment`.replace(" ", "_").toLowerCase();
    const deploymentParameters = {
        properties: {
            parameters: parameterJson.parameters,
            template: armTemplateJson,
            mode: "Incremental",
        },
    };
    const deployCtx = {
        ctx: ctx,
        finished: false,
        deploymentStartTime: Date.now(),
        client: client,
        resourceGroupName: resourceGroupName,
        deploymentName: deploymentName,
    };
    try {
        const result = client.deployments
            .createOrUpdate(resourceGroupName, deploymentName, deploymentParameters)
            .then((result) => {
            var _a, _b;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.SuccessNotice, constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName));
            syncArmOutput(envInfo, (_b = result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
            return result;
        })
            .finally(() => {
            deployCtx.finished = true;
        });
        await pollDeploymentStatus(deployCtx);
        await result;
        return teamsfx_api_1.ok(undefined);
    }
    catch (error) {
        // return the error if the template is invalid
        if (error.code === InvalidTemplateErrorCode) {
            return teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToValidateArmTemplates));
        }
        // try to get deployment error
        const result = await wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName);
        if (result.isOk()) {
            const deploymentError = result.value;
            // return thrown error if deploymentError is empty
            if (!deploymentError) {
                return teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure));
            }
            const deploymentErrorObj = formattedDeploymentError(deploymentError);
            const deploymentErrorMessage = JSON.stringify(deploymentErrorObj, undefined, 2);
            let errorMessage = util_1.format(common_1.getStrings().solution.DeployArmTemplates.FailNotice, constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName);
            errorMessage += `\nError message: ${error.message}\nDetailed message: \n${deploymentErrorMessage}\nGet toolkit help from ${constants_2.HelpLinks.ArmHelpLink}.`;
            const notificationMessage = getNotificationMessage(deploymentError, deploymentName);
            const returnError = new teamsfx_api_1.UserError(new Error(errorMessage), constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure, constants_2.HelpLinks.ArmHelpLink, notificationMessage);
            returnError.innerError = JSON.stringify(deploymentErrorObj);
            return teamsfx_api_1.err(returnError);
        }
        else {
            return result;
        }
    }
}
exports.doDeployArmTemplatesV3 = doDeployArmTemplatesV3;
function syncArmOutput(envInfo, armOutput) {
    var _a;
    if (armOutput instanceof Object) {
        const armOutputKeys = Object.keys(armOutput);
        for (const armOutputKey of armOutputKeys) {
            const moduleOutput = armOutput[armOutputKey].value;
            if (moduleOutput instanceof Object) {
                const moduleOutputKeys = Object.keys(moduleOutput);
                for (const moduleOutputKey of moduleOutputKeys) {
                    const pluginOutput = moduleOutput[moduleOutputKey].value;
                    if (pluginOutput instanceof Object) {
                        const pluginId = pluginOutput[constants_1.TEAMS_FX_RESOURCE_ID_KEY];
                        if (pluginId) {
                            const pluginOutputKeys = Object.keys(pluginOutput);
                            for (const pluginOutputKey of pluginOutputKeys) {
                                if (pluginOutputKey != constants_1.TEAMS_FX_RESOURCE_ID_KEY) {
                                    if (envInfo.state instanceof Map) {
                                        (_a = envInfo.state
                                            .get(pluginId)) === null || _a === void 0 ? void 0 : _a.set(pluginOutputKey, pluginOutput[pluginOutputKey]);
                                    }
                                    else {
                                        envInfo.state[pluginId][pluginOutputKey] =
                                            pluginOutput[pluginOutputKey];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
async function deployArmTemplates(ctx) {
    var _a, _b, _c;
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.StartNotice, constants_2.PluginDisplayName.Solution));
    let result;
    (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeploymentStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doDeployArmTemplates(ctx);
        if (result.isOk()) {
            (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeployment, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            const errorProperties = {};
            if (result.error.innerError) {
                errorProperties[constants_1.SolutionTelemetryProperty.ArmDeploymentError] = result.error.innerError;
            }
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter, errorProperties);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter);
    }
    await progressHelper_1.ProgressHelper.endDeployArmTemplatesProgress(result.isOk());
    return result;
}
exports.deployArmTemplates = deployArmTemplates;
async function deployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider) {
    var _a, _b, _c;
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(util_1.format(common_1.getStrings().solution.DeployArmTemplates.StartNotice, constants_2.PluginDisplayName.Solution));
    let result;
    (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeploymentStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doDeployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider);
        if (result.isOk()) {
            (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeployment, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            const errorProperties = {};
            if (result.error.innerError) {
                errorProperties[constants_1.SolutionTelemetryProperty.ArmDeploymentError] = result.error.innerError;
            }
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter, errorProperties);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(teamsfx_api_1.returnUserError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToDeployArmTemplatesToAzure));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter);
    }
    await progressHelper_1.ProgressHelper.endDeployArmTemplatesProgress(result.isOk());
    return result;
}
exports.deployArmTemplatesV3 = deployArmTemplatesV3;
async function copyParameterJson(projectPath, appName, targetEnvName, sourceEnvName) {
    var _a, _b, _c;
    if (!targetEnvName || !sourceEnvName) {
        return;
    }
    const parameterFolderPath = path_1.default.join(projectPath, configsFolder);
    const targetParameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, targetEnvName);
    const sourceParameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, sourceEnvName);
    const targetParameterFilePath = path_1.default.join(parameterFolderPath, targetParameterFileName);
    const sourceParameterFilePath = path_1.default.join(parameterFolderPath, sourceParameterFileName);
    const targetParameterContent = await fs.readJson(sourceParameterFilePath);
    if ((_c = (_b = (_a = targetParameterContent[parameterName]) === null || _a === void 0 ? void 0 : _a.provisionParameters) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.resourceBaseName) {
        targetParameterContent[parameterName].provisionParameters.value.resourceBaseName =
            generateResourceBaseName(appName, targetEnvName);
    }
    await fs.ensureDir(parameterFolderPath);
    await fs.writeFile(targetParameterFilePath, JSON.stringify(targetParameterContent, undefined, 4).replace(/\r?\n/g, os_1.default.EOL));
}
exports.copyParameterJson = copyParameterJson;
async function getParameterJson(ctx) {
    var _a;
    if (!ctx.envInfo.envName) {
        throw new Error("Failed to get target environment name from solution context.");
    }
    const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, ctx.envInfo.envName);
    const parameterFolderPath = path_1.default.join(ctx.root, configsFolder);
    const parameterFilePath = path_1.default.join(parameterFolderPath, parameterFileName);
    try {
        await fs.stat(parameterFilePath);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] ${parameterFilePath} does not exist.`);
        const returnError = new Error(`[${constants_2.PluginDisplayName.Solution}] ${parameterFilePath} does not exist.`);
        throw teamsfx_api_1.returnUserError(returnError, constants_1.SolutionSource, "ParameterFileNotExist");
    }
    const parameterJson = await getExpandedParameter(ctx, parameterFilePath); // only expand secrets in memory
    return parameterJson;
}
exports.getParameterJson = getParameterJson;
async function getParameterJsonV3(ctx, projectPath, envInfo) {
    var _a;
    if (!(envInfo === null || envInfo === void 0 ? void 0 : envInfo.envName)) {
        throw new Error("Failed to get target environment name from solution context.");
    }
    const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName);
    const parameterFolderPath = path_1.default.join(projectPath, configsFolder);
    const parameterFilePath = path_1.default.join(parameterFolderPath, parameterFileName);
    try {
        await fs.stat(parameterFilePath);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] ${parameterFilePath} does not exist.`);
        const returnError = new Error(`[${constants_2.PluginDisplayName.Solution}] ${parameterFilePath} does not exist.`);
        throw teamsfx_api_1.returnUserError(returnError, constants_1.SolutionSource, "ParameterFileNotExist");
    }
    const parameterJson = await getExpandedParameterV3(ctx, envInfo, parameterFilePath); // only expand secrets in memory
    return parameterJson;
}
exports.getParameterJsonV3 = getParameterJsonV3;
function generateArmFromResult(result, bicepOrchestrationTemplate, pluginWithArm, moduleProvisionFiles, moduleConfigFiles) {
    var _a, _b;
    bicepOrchestrationTemplate.applyTemplate(pluginWithArm.name, result);
    if ((_a = result.Configuration) === null || _a === void 0 ? void 0 : _a.Modules) {
        for (const module of Object.entries(result.Configuration.Modules)) {
            const moduleName = module[0];
            const moduleValue = module[1];
            moduleConfigFiles.set(generateBicepModuleConfigFilePath(moduleName), moduleValue);
        }
    }
    if ((_b = result.Provision) === null || _b === void 0 ? void 0 : _b.Modules) {
        for (const module of Object.entries(result.Provision.Modules)) {
            const moduleName = module[0];
            const moduleValue = module[1];
            moduleProvisionFiles.set(generateBicepModuleProvisionFilePath(moduleName), moduleValue);
        }
    }
}
async function doGenerateArmTemplate(ctx, selectedPlugins) {
    var _a, _b, _c;
    const azureSolutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
    const baseName = generateResourceBaseName(ctx.projectSettings.appName, ctx.envInfo.envName);
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSolutionSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p)); // This function ensures return result won't be empty
    const bicepOrchestrationTemplate = new BicepOrchestrationContent(plugins.map((p) => p.name), baseName);
    const moduleProvisionFiles = new Map();
    const moduleConfigFiles = new Map();
    // Get bicep content from each resource plugin
    for (const plugin of plugins) {
        const pluginWithArm = plugin; // Temporary solution before adding it to teamsfx-api
        const pluginContext = util_2.getPluginContext(ctx, pluginWithArm.name);
        let result;
        let errMessage = "";
        if (pluginWithArm.updateArmTemplates &&
            !selectedPlugins.find((pluginItem) => pluginItem.name === pluginWithArm.name)) {
            result = (await pluginWithArm.updateArmTemplates(pluginContext));
            errMessage = common_1.getStrings().solution.UpdateArmTemplateFailNotice;
        }
        else if (pluginWithArm.generateArmTemplates &&
            selectedPlugins.find((pluginItem) => pluginItem.name === pluginWithArm.name)) {
            result = (await pluginWithArm.generateArmTemplates(pluginContext));
            errMessage = common_1.getStrings().solution.GenerateArmTemplateFailNotice;
        }
        else {
            continue;
        }
        if (result.isOk()) {
            generateArmFromResult(result.value, bicepOrchestrationTemplate, pluginWithArm, moduleProvisionFiles, moduleConfigFiles);
        }
        else {
            const msg = util_1.format(errMessage, (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.appName);
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.error(msg);
            return result;
        }
    }
    await persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, ctx.root);
    return teamsfx_api_1.ok(undefined); // Nothing to return when success
}
async function doGenerateArmTemplateV3(ctx, inputs, activatedPlugins, addedPlugins) {
    var _a;
    const baseName = generateResourceBaseName(ctx.projectSetting.appName, "");
    const bicepOrchestrationTemplate = new BicepOrchestrationContent(activatedPlugins.map((p) => p.name), baseName);
    const moduleProvisionFiles = new Map();
    const moduleConfigFiles = new Map();
    for (const plugin of activatedPlugins) {
        let result;
        let errMessage = "";
        if (plugin.updateResourceTemplate &&
            !addedPlugins.find((pluginItem) => pluginItem.name === plugin.name)) {
            result = await plugin.updateResourceTemplate(ctx, inputs);
            errMessage = common_1.getStrings().solution.UpdateArmTemplateFailNotice;
        }
        else if (plugin.generateResourceTemplate &&
            addedPlugins.find((pluginItem) => pluginItem.name === plugin.name)) {
            result = await plugin.generateResourceTemplate(ctx, inputs);
            errMessage = common_1.getStrings().solution.GenerateArmTemplateFailNotice;
        }
        else {
            continue;
        }
        if (result.isOk()) {
            if (result.value.kind === "bicep") {
                const armTemplate = result.value.template;
                generateArmFromResult(armTemplate, bicepOrchestrationTemplate, plugin, moduleProvisionFiles, moduleConfigFiles);
            }
        }
        else {
            const msg = util_1.format(errMessage, ctx.projectSetting.appName);
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(msg);
            return result;
        }
    }
    await persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, inputs.projectPath);
    return teamsfx_api_1.ok(undefined); // Nothing to return when success
}
async function persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, projectaPath) {
    // Write bicep content to project folder
    if (bicepOrchestrationTemplate.needsGenerateTemplate()) {
        // Output parameter file
        const envListResult = await environment_1.environmentManager.listEnvConfigs(projectaPath);
        if (envListResult.isErr()) {
            return teamsfx_api_1.err(envListResult.error);
        }
        const parameterEnvFolderPath = path_1.default.join(projectaPath, configsFolder);
        await fs.ensureDir(parameterEnvFolderPath);
        for (const env of envListResult.value) {
            const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, env);
            const parameterEnvFilePath = path_1.default.join(parameterEnvFolderPath, parameterFileName);
            let parameterFileContent = "";
            if (await fs.pathExists(parameterEnvFilePath)) {
                try {
                    const parameterFile = await fs.readJson(parameterEnvFilePath);
                    const parameterObj = parameterFile.parameters.provisionParameters.value;
                    const appendParam = bicepOrchestrationTemplate.getAppendedParameters();
                    const duplicateParam = Object.keys(parameterObj).filter((val) => Object.keys(appendParam).includes(val));
                    if (duplicateParam && duplicateParam.length != 0) {
                        const duplicateParamError = new Error(`There are some duplicate parameters in ${parameterEnvFilePath}, to avoid the conflict, please modify these parameter names: ${duplicateParam}`);
                        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(duplicateParamError, constants_1.SolutionSource, constants_1.SolutionError.FailedToUpdateArmParameters, constants_2.HelpLinks.ArmHelpLink));
                    }
                    parameterFile.parameters.provisionParameters.value = Object.assign(parameterObj, appendParam);
                    parameterFileContent = JSON.stringify(parameterFile, undefined, 2);
                }
                catch (error) {
                    const parameterFileError = new Error(`There are some errors in ${parameterEnvFilePath}, please make sure this file is valid. The error message is ${error.message}`);
                    return teamsfx_api_1.err(teamsfx_api_1.returnUserError(parameterFileError, constants_1.SolutionSource, constants_1.SolutionError.FailedToUpdateArmParameters, constants_2.HelpLinks.ArmHelpLink));
                }
            }
            else {
                parameterFileContent = bicepOrchestrationTemplate.getParameterFileContent();
            }
            await fs.writeFile(parameterEnvFilePath, parameterFileContent.replace(/\r?\n/g, os_1.default.EOL));
        }
        // Generate main.bicep, config.bicep, provision.bicep
        const templateFolderPath = path_1.default.join(projectaPath, templatesFolder);
        await fs.ensureDir(templateFolderPath);
        await fs.ensureDir(path_1.default.join(templateFolderPath, "teamsFx"));
        await fs.ensureDir(path_1.default.join(templateFolderPath, "provision"));
        let bicepOrchestrationProvisionContent = "";
        let bicepOrchestrationConfigContent = "";
        if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationProvisionFileName)))) {
            bicepOrchestrationProvisionContent = await fs.readFile(path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution", "provision.bicep"), constants_2.ConstantString.UTF8Encoding);
        }
        if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationConfigFileName)))) {
            bicepOrchestrationConfigContent = await fs.readFile(path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution", "config.bicep"), constants_2.ConstantString.UTF8Encoding);
        }
        bicepOrchestrationProvisionContent +=
            os_1.default.EOL + bicepOrchestrationTemplate.getOrchestractionProvisionContent();
        bicepOrchestrationConfigContent +=
            os_1.default.EOL + bicepOrchestrationTemplate.getOrchestractionConfigContent();
        const templateSolitionPath = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution");
        if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationFileName)))) {
            await fs.copyFile(path_1.default.join(templateSolitionPath, bicepOrchestrationFileName), path_1.default.join(templateFolderPath, bicepOrchestrationFileName));
        }
        await fs.appendFile(path_1.default.join(templateFolderPath, bicepOrchestrationProvisionFileName), bicepOrchestrationProvisionContent.replace(/\r?\n/g, os_1.default.EOL));
        await fs.appendFile(path_1.default.join(templateFolderPath, bicepOrchestrationConfigFileName), bicepOrchestrationConfigContent.replace(/\r?\n/g, os_1.default.EOL));
        // Generate module provision bicep files
        for (const module of moduleProvisionFiles) {
            const res = bicepOrchestrationTemplate.applyReference(module[1]);
            await fs.appendFile(path_1.default.join(templateFolderPath, module[0]), res.replace(/\r?\n/g, os_1.default.EOL));
        }
        // Generate module configuration bicep files
        for (const module of moduleConfigFiles) {
            const res = bicepOrchestrationTemplate.applyReference(module[1]);
            await fs.writeFile(path_1.default.join(templateFolderPath, module[0]), res.replace(/\r?\n/g, os_1.default.EOL));
        }
    }
}
async function getExpandedParameter(ctx, filePath) {
    var _a;
    try {
        const parameterTemplate = await fs.readFile(filePath, constants_2.ConstantString.UTF8Encoding);
        const parameterJsonString = expandParameterPlaceholders(ctx, parameterTemplate);
        return JSON.parse(parameterJsonString);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] Failed to get expanded parameter from ${filePath}.`);
        throw err;
    }
}
async function getExpandedParameterV3(ctx, envInfo, filePath) {
    var _a;
    try {
        const parameterTemplate = await fs.readFile(filePath, constants_2.ConstantString.UTF8Encoding);
        const parameterJsonString = expandParameterPlaceholdersV3(ctx, envInfo, parameterTemplate);
        return JSON.parse(parameterJsonString);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] Failed to get expanded parameter from ${filePath}.`);
        throw err;
    }
}
async function getResourceManagementClientForArmDeployment(azureAccountProvider, subscriptionId) {
    const azureToken = await azureAccountProvider.getAccountCredentialAsync();
    if (!azureToken) {
        throw teamsfx_api_1.returnSystemError(new Error("Azure Credential is invalid."), constants_2.PluginDisplayName.Solution, constants_1.SolutionError.FailedToGetAzureCredential);
    }
    if (!subscriptionId) {
        throw teamsfx_api_1.returnSystemError(new Error(`Failed to get subscription id.`), constants_2.PluginDisplayName.Solution, constants_1.SolutionError.NoSubscriptionSelected);
    }
    return new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
}
async function compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, logger) {
    try {
        const result = await cpUtils_1.executeCommand(bicepCommand, ["build", bicepOrchestrationFilePath, "--stdout"], logger, { shell: false });
        return JSON.parse(result);
    }
    catch (err) {
        throw new Error(`Failed to compile bicep files to Json arm templates file: ${err.message}`);
    }
}
// Context used by handlebars to render the main.bicep file
class ArmTemplateRenderContext {
    constructor(pluginNames) {
        this.Plugins = {};
        for (const plugin of pluginNames) {
            this.Plugins[plugin] = {};
        }
    }
    addPluginOutput(pluginName, armResult) {
        var _a, _b;
        const PluginContext = {
            Provision: {},
            Configuration: {},
            References: {},
        };
        const provision = (_a = armResult.Provision) === null || _a === void 0 ? void 0 : _a.Modules;
        const references = armResult.Reference;
        const configs = (_b = armResult.Configuration) === null || _b === void 0 ? void 0 : _b.Modules;
        if (provision) {
            for (const module of Object.entries(provision)) {
                const moduleFileName = module[0];
                PluginContext.Provision[moduleFileName] = {
                    path: generateBicepModuleProvisionFilePath(moduleFileName),
                };
            }
        }
        if (configs) {
            for (const module of Object.entries(configs)) {
                const moduleFileName = module[0];
                PluginContext.Configuration[moduleFileName] = {
                    path: generateBicepModuleConfigFilePath(moduleFileName),
                };
            }
        }
        if (references) {
            for (const output of Object.entries(references)) {
                const outputKey = output[0];
                const outputValue = output[1];
                PluginContext.References[outputKey] = outputValue;
            }
        }
        this.Plugins[pluginName] = PluginContext;
    }
}
exports.ArmTemplateRenderContext = ArmTemplateRenderContext;
// Stores the bicep orchestration information for all resource plugins
class BicepOrchestrationContent {
    constructor(pluginNames, baseName) {
        this.ParameterJsonTemplate = {};
        this.TemplateAdded = false;
        this.ProvisionTemplate = "";
        this.ConfigTemplate = "";
        this.ParameterJsonTemplate[resourceBaseName] = baseName;
        this.RenderContext = new ArmTemplateRenderContext(pluginNames);
    }
    applyTemplate(pluginName, armResult) {
        var _a, _b;
        this.ProvisionTemplate += this.normalizeTemplateSnippet((_a = armResult.Provision) === null || _a === void 0 ? void 0 : _a.Orchestration);
        this.ConfigTemplate += this.normalizeTemplateSnippet((_b = armResult.Configuration) === null || _b === void 0 ? void 0 : _b.Orchestration);
        this.RenderContext.addPluginOutput(pluginName, armResult);
        Object.assign(this.ParameterJsonTemplate, armResult.Parameters);
    }
    applyReference(configContent) {
        return common_1.compileHandlebarsTemplateString(configContent, this.RenderContext.Plugins);
    }
    getOrchestractionProvisionContent() {
        const orchestrationTemplate = this.normalizeTemplateSnippet(this.ProvisionTemplate, false) + os_1.default.EOL;
        return common_1.compileHandlebarsTemplateString(orchestrationTemplate, this.RenderContext.Plugins).trim();
    }
    getOrchestractionConfigContent() {
        const orchestrationTemplate = this.normalizeTemplateSnippet(this.ConfigTemplate, false) + os_1.default.EOL;
        return common_1.compileHandlebarsTemplateString(orchestrationTemplate, this.RenderContext.Plugins).trim();
    }
    getParameterFileContent() {
        const parameterObject = {
            $schema: "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
            contentVersion: "1.0.0.0",
            parameters: { provisionParameters: { value: this.ParameterJsonTemplate } },
        };
        return JSON.stringify(parameterObject, undefined, 2);
    }
    getAppendedParameters() {
        const res = this.ParameterJsonTemplate;
        if (res.resourceBaseName) {
            delete res.resourceBaseName;
        }
        return res;
    }
    needsGenerateTemplate() {
        return this.TemplateAdded;
    }
    normalizeTemplateSnippet(snippet, updateTemplateChangeFlag = true) {
        if (snippet) {
            if (updateTemplateChangeFlag) {
                this.TemplateAdded = true;
            }
            return snippet.trim() + os_1.default.EOL;
        }
        return "";
    }
}
function generateBicepModuleProvisionFilePath(moduleFileName) {
    return `./provision/${moduleFileName}.bicep`;
}
function generateBicepModuleConfigFilePath(moduleFileName) {
    return `./teamsFx/${moduleFileName}.bicep`;
}
function expandParameterPlaceholders(ctx, parameterContent) {
    var _a;
    const azureSolutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSolutionSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p)); // This function ensures return result won't be empty
    const stateVariables = {};
    const availableVariables = { state: stateVariables };
    // Add plugin contexts to available variables
    for (const plugin of plugins) {
        const pluginContext = util_2.getPluginContext(ctx, plugin.name);
        const pluginVariables = {};
        for (const configItem of pluginContext.config) {
            if (typeof configItem[1] === "string") {
                // Currently we only config with string type
                pluginVariables[configItem[0]] = configItem[1];
            }
        }
        stateVariables[plugin.name] = pluginVariables;
    }
    // Add solution config to available variables
    const solutionConfig = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG);
    if (solutionConfig) {
        const solutionVariables = {};
        for (const configItem of solutionConfig) {
            if (typeof configItem[1] === "string") {
                // Currently we only config with string type
                solutionVariables[configItem[0]] = configItem[1];
            }
        }
        stateVariables[solutionName] = solutionVariables;
    }
    // Add environment variable to available variables
    const processVariables = Object.keys(process.env).reduce((obj, key) => {
        obj[key] = process.env[key];
        return obj;
    }, {});
    availableVariables["$env"] = processVariables;
    return common_1.compileHandlebarsTemplateString(parameterContent, availableVariables);
}
function expandParameterPlaceholdersV3(ctx, envInfo, parameterContent) {
    const azureSolutionSettings = ctx.projectSetting.solutionSettings;
    const plugins = azureSolutionSettings.activeResourcePlugins.map((p) => typedi_1.Container.get(p));
    const stateVariables = {};
    const availableVariables = { state: stateVariables };
    const envState = envInfo.state;
    // Add plugin contexts to available variables
    for (const plugin of plugins) {
        const resourceState = envState[plugin.name] || {};
        // const pluginContext = getPluginContext(ctx, plugin.name);
        const pluginVariables = {};
        for (const key of Object.keys(resourceState)) {
            if (typeof resourceState[key] === "string") {
                // Currently we only config with string type
                pluginVariables[key] = resourceState[key];
            }
        }
        stateVariables[plugin.name] = pluginVariables;
    }
    // Add solution config to available variables
    const solutionConfig = envState.solution;
    if (solutionConfig) {
        const solutionVariables = {};
        for (const key of Object.keys(solutionConfig)) {
            if (typeof solutionConfig[key] === "string") {
                // Currently we only config with string type
                solutionVariables[key] = solutionConfig[key];
            }
        }
        stateVariables[solutionName] = solutionVariables;
    }
    // Add environment variable to available variables
    const processVariables = Object.keys(process.env).reduce((obj, key) => {
        obj[key] = process.env[key];
        return obj;
    }, {});
    availableVariables["$env"] = processVariables;
    return common_1.compileHandlebarsTemplateString(parameterContent, availableVariables);
}
function generateResourceBaseName(appName, envName) {
    const maxAppNameLength = 10;
    const maxEnvNameLength = 4;
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    const normalizedEnvName = envName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return (normalizedAppName.substr(0, maxAppNameLength) +
        normalizedEnvName.substr(0, maxEnvNameLength) +
        tools_1.getUuid().substr(0, 6));
}
async function wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName) {
    var _a;
    try {
        const deploymentError = await getDeploymentError(deployCtx, resourceGroupName, deploymentName);
        return teamsfx_api_1.ok(deploymentError);
    }
    catch (error) {
        (_a = deployCtx.ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] Failed to get deployment error for ${error.message}.`);
        const returnError = new Error(`resource deployments (${deployCtx.deploymentName} module) for your project failed and get the error message failed. Please refer to the resource group ${deployCtx.resourceGroupName} in portal for deployment error.`);
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(returnError, constants_1.SolutionSource, "GetDeploymentErrorFailed"));
    }
}
async function getDeploymentError(deployCtx, resourceGroupName, deploymentName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    let deployment;
    try {
        deployment = await deployCtx.client.deployments.get(resourceGroupName, deploymentName);
    }
    catch (error) {
        if (deploymentName !== deployCtx.deploymentName &&
            error.code === constants_2.ConstantString.DeploymentNotFound) {
            return undefined;
        }
        throw error;
    }
    if (!((_a = deployment.properties) === null || _a === void 0 ? void 0 : _a.error)) {
        return undefined;
    }
    const deploymentError = {
        error: (_b = deployment.properties) === null || _b === void 0 ? void 0 : _b.error,
    };
    const operations = await deployCtx.client.deploymentOperations.list(resourceGroupName, deploymentName);
    for (const operation of operations) {
        if ((_d = (_c = operation.properties) === null || _c === void 0 ? void 0 : _c.statusMessage) === null || _d === void 0 ? void 0 : _d.error) {
            if (!deploymentError.subErrors) {
                deploymentError.subErrors = {};
            }
            const name = (_f = (_e = operation.properties.targetResource) === null || _e === void 0 ? void 0 : _e.resourceName) !== null && _f !== void 0 ? _f : operation.id;
            deploymentError.subErrors[name] = {
                error: operation.properties.statusMessage.error,
            };
            if (((_g = operation.properties.targetResource) === null || _g === void 0 ? void 0 : _g.resourceType) ===
                constants_2.ConstantString.DeploymentResourceType &&
                ((_h = operation.properties.targetResource) === null || _h === void 0 ? void 0 : _h.resourceName) &&
                ((_j = operation.properties.targetResource) === null || _j === void 0 ? void 0 : _j.id)) {
                const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(operation.properties.targetResource.id);
                const subError = await getDeploymentError(deployCtx, resourceGroupName, (_k = operation.properties.targetResource) === null || _k === void 0 ? void 0 : _k.resourceName);
                if (subError) {
                    deploymentError.subErrors[name].inner = subError;
                }
            }
        }
    }
    return deploymentError;
}
function getNotificationMessage(deploymentError, deploymentName) {
    let failedDeployments = [];
    if (deploymentError.subErrors) {
        failedDeployments = Object.keys(deploymentError.subErrors);
    }
    else {
        failedDeployments.push(deploymentName);
    }
    const format = failedDeployments.map((deployment) => deployment + " module");
    return `resource deployments (${format.join(", ")}) for your project failed. Please refer to output channel for more error details.`;
}
function formattedDeploymentError(deploymentError) {
    var _a, _b, _c;
    if (deploymentError.subErrors) {
        const result = {};
        for (const key in deploymentError.subErrors) {
            const subError = deploymentError.subErrors[key];
            if (subError.inner) {
                result[key] = formattedDeploymentError(subError.inner);
            }
            else {
                const needFilter = ((_b = (_a = subError.error) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes("Template output evaluation skipped")) &&
                    ((_c = subError.error) === null || _c === void 0 ? void 0 : _c.code) === "DeploymentOperationFailed";
                if (!needFilter) {
                    result[key] = subError.error;
                }
            }
        }
        return result;
    }
    else {
        return deploymentError.error;
    }
}
exports.formattedDeploymentError = formattedDeploymentError;
class Arm {
    async generateArmTemplate(ctx, inputs, activatedPlugins, addedPlugins) {
        return generateArmTemplateV3(ctx, inputs, activatedPlugins, addedPlugins);
    }
    async deployArmTemplates(ctx, inputs, envInfo, azureAccountProvider) {
        return deployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider);
    }
}
const arm = new Arm();
exports.default = arm;
//# sourceMappingURL=arm.js.map