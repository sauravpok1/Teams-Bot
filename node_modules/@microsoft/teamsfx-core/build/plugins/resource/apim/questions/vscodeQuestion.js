"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewApiVersionQuestion = exports.ApiVersionQuestion = exports.ApiPrefixQuestion = exports.ExistingOpenApiDocumentFunc = exports.OpenApiDocumentQuestion = exports.ApimServiceQuestion = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const error_1 = require("../error");
const constants_1 = require("../constants");
const config_1 = require("../config");
const answer_1 = require("../answer");
const namingRules_1 = require("../utils/namingRules");
const question_1 = require("./question");
const commonUtils_1 = require("../utils/commonUtils");
const tools_1 = require("../../../../common/tools");
class ApimServiceQuestion extends question_1.BaseQuestionService {
    constructor(lazyApimService, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.lazyApimService = lazyApimService;
    }
    getQuestion() {
        return {
            type: "singleSelect",
            name: constants_1.QuestionConstants.VSCode.Apim.questionName,
            title: constants_1.QuestionConstants.VSCode.Apim.description,
            staticOptions: [
                {
                    id: constants_1.QuestionConstants.VSCode.Apim.createNewApimOption,
                    label: constants_1.QuestionConstants.VSCode.Apim.createNewApimOption,
                },
            ],
            dynamicOptions: async (inputs) => {
                return this.getDynamicOptions();
            },
            returnObject: true,
            skipSingleOption: false,
        };
    }
    async getDynamicOptions() {
        const apimService = await this.lazyApimService.getValue();
        const apimServiceList = await apimService.listService();
        const existingOptions = apimServiceList.map((apimService) => {
            return {
                id: apimService.serviceName,
                label: apimService.serviceName,
                description: apimService.resourceGroupName,
                data: apimService,
            };
        });
        const newOption = {
            id: constants_1.QuestionConstants.VSCode.Apim.createNewApimOption,
            label: constants_1.QuestionConstants.VSCode.Apim.createNewApimOption,
        };
        return [newOption, ...existingOptions];
    }
}
exports.ApimServiceQuestion = ApimServiceQuestion;
class OpenApiDocumentQuestion extends question_1.BaseQuestionService {
    constructor(openApiProcessor, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.openApiProcessor = openApiProcessor;
    }
    getQuestion(ctx) {
        return {
            type: "singleSelect",
            name: constants_1.QuestionConstants.VSCode.OpenApiDocument.questionName,
            title: constants_1.QuestionConstants.VSCode.OpenApiDocument.description,
            staticOptions: [],
            dynamicOptions: async (inputs) => {
                return this.getDynamicOptions(ctx.root);
            },
            returnObject: true,
            skipSingleOption: false,
        };
    }
    async getDynamicOptions(root) {
        const filePath2OpenApiMap = await this.openApiProcessor.listOpenApiDocument(root, constants_1.QuestionConstants.VSCode.OpenApiDocument.excludeFolders, constants_1.QuestionConstants.VSCode.OpenApiDocument.openApiDocumentFileExtensions);
        if (filePath2OpenApiMap.size === 0) {
            throw error_1.BuildError(error_1.NoValidOpenApiDocument);
        }
        const result = [];
        filePath2OpenApiMap.forEach((value, key) => result.push({ id: key, label: key, data: value }));
        return result;
    }
}
exports.OpenApiDocumentQuestion = OpenApiDocumentQuestion;
class ExistingOpenApiDocumentFunc extends question_1.BaseQuestionService {
    constructor(openApiProcessor, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.openApiProcessor = openApiProcessor;
    }
    getQuestion(ctx) {
        return {
            type: "func",
            name: constants_1.QuestionConstants.VSCode.ExistingOpenApiDocument.questionName,
            func: async (inputs) => {
                const apimConfig = new config_1.ApimPluginConfig(ctx.config, ctx.envInfo.envName);
                const openApiDocumentPath = apimConfig.checkAndGet(constants_1.ApimPluginConfigKeys.apiDocumentPath);
                const openApiDocument = await this.openApiProcessor.loadOpenApiDocument(openApiDocumentPath, ctx.root);
                return { id: openApiDocumentPath, label: openApiDocumentPath, data: openApiDocument };
            },
        };
    }
}
exports.ExistingOpenApiDocumentFunc = ExistingOpenApiDocumentFunc;
class ApiPrefixQuestion extends question_1.BaseQuestionService {
    constructor(telemetryReporter, logger) {
        super(telemetryReporter, logger);
    }
    getQuestion() {
        return {
            type: "text",
            name: constants_1.QuestionConstants.VSCode.ApiPrefix.questionName,
            title: constants_1.QuestionConstants.VSCode.ApiPrefix.description,
            prompt: constants_1.QuestionConstants.VSCode.ApiPrefix.prompt,
            default: async (inputs) => {
                var _a, _b;
                const apiTitle = (_b = (_a = answer_1.buildAnswer(inputs)) === null || _a === void 0 ? void 0 : _a.openApiDocumentSpec) === null || _b === void 0 ? void 0 : _b.info.title;
                let apiPrefix;
                if (apiTitle) {
                    apiPrefix = namingRules_1.NamingRules.apiPrefix.sanitize(apiTitle);
                }
                return apiPrefix ? apiPrefix : constants_1.ApimDefaultValues.apiPrefix;
            },
            validation: {
                validFunc: (input, previousInputs) => namingRules_1.NamingRules.validate(input, namingRules_1.NamingRules.apiPrefix),
            },
        };
    }
}
exports.ApiPrefixQuestion = ApiPrefixQuestion;
class ApiVersionQuestion extends question_1.BaseQuestionService {
    constructor(lazyApimService, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.lazyApimService = lazyApimService;
    }
    getQuestion(ctx) {
        return {
            type: "singleSelect",
            name: constants_1.QuestionConstants.VSCode.ApiVersion.questionName,
            title: constants_1.QuestionConstants.VSCode.ApiVersion.description,
            staticOptions: [],
            dynamicOptions: async (inputs) => {
                return this.getDynamicOptions(inputs, ctx);
            },
            returnObject: true,
            skipSingleOption: false,
        };
    }
    async getDynamicOptions(inputs, ctx) {
        var _a, _b, _c;
        const apimService = await this.lazyApimService.getValue();
        const apimConfig = new config_1.ApimPluginConfig(ctx.config, ctx.envInfo.envName);
        const solutionConfig = new config_1.SolutionConfig(ctx.envInfo);
        const answer = answer_1.buildAnswer(inputs);
        let resourceGroupName, serviceName;
        if (tools_1.isArmSupportEnabled()) {
            const apimServiceResourceId = apimConfig.checkAndGet(constants_1.ApimPluginConfigKeys.serviceResourceId);
            resourceGroupName = tools_1.getResourceGroupNameFromResourceId(apimServiceResourceId);
            serviceName = commonUtils_1.getApimServiceNameFromResourceId(apimServiceResourceId);
        }
        else {
            resourceGroupName = (_a = apimConfig.resourceGroupName) !== null && _a !== void 0 ? _a : solutionConfig.resourceGroupName;
            serviceName = apimConfig.checkAndGet(constants_1.ApimPluginConfigKeys.serviceName);
        }
        const apiPrefix = (_b = answer.apiPrefix) !== null && _b !== void 0 ? _b : apimConfig.checkAndGet(constants_1.ApimPluginConfigKeys.apiPrefix);
        const versionSetId = (_c = apimConfig.versionSetId) !== null && _c !== void 0 ? _c : namingRules_1.NamingRules.versionSetId.sanitize(apiPrefix, solutionConfig.resourceNameSuffix);
        const apiContracts = await apimService.listApi(resourceGroupName, serviceName, versionSetId);
        const existingApiVersionOptions = apiContracts.map((api) => {
            var _a, _b, _c;
            const result = {
                id: (_a = api.name) !== null && _a !== void 0 ? _a : "",
                label: (_b = api.apiVersion) !== null && _b !== void 0 ? _b : "",
                description: (_c = api.name) !== null && _c !== void 0 ? _c : "",
                data: api,
            };
            return result;
        });
        const createNewApiVersionOption = {
            id: constants_1.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
            label: constants_1.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
        };
        return [createNewApiVersionOption, ...existingApiVersionOptions];
    }
}
exports.ApiVersionQuestion = ApiVersionQuestion;
class NewApiVersionQuestion extends question_1.BaseQuestionService {
    constructor(telemetryReporter, logger) {
        super(telemetryReporter, logger);
    }
    condition() {
        return {
            equals: constants_1.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
        };
    }
    getQuestion() {
        return {
            type: "text",
            name: constants_1.QuestionConstants.VSCode.NewApiVersion.questionName,
            title: constants_1.QuestionConstants.VSCode.NewApiVersion.description,
            default: async (inputs) => {
                var _a, _b;
                const apiVersion = (_b = (_a = answer_1.buildAnswer(inputs)) === null || _a === void 0 ? void 0 : _a.openApiDocumentSpec) === null || _b === void 0 ? void 0 : _b.info.version;
                let versionIdentity;
                if (apiVersion) {
                    versionIdentity = namingRules_1.NamingRules.versionIdentity.sanitize(apiVersion);
                }
                return versionIdentity ? versionIdentity : constants_1.ApimDefaultValues.apiVersion;
            },
            validation: {
                validFunc: (input, previousInputs) => namingRules_1.NamingRules.validate(input, namingRules_1.NamingRules.versionIdentity),
            },
        };
    }
}
exports.NewApiVersionQuestion = NewApiVersionQuestion;
//# sourceMappingURL=vscodeQuestion.js.map