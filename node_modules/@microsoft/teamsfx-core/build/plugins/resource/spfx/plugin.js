"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const uuid = tslib_1.__importStar(require("uuid"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const _1 = require(".");
const utils_1 = require("./utils/utils");
const constants_1 = require("./utils/constants");
const error_1 = require("./error");
const util = tslib_1.__importStar(require("util"));
const progress_helper_1 = require("./utils/progress-helper");
const tools_1 = require("../../../common/tools");
const __1 = require("../../..");
const constants_2 = require("../appstudio/constants");
const axios_1 = tslib_1.__importDefault(require("axios"));
const spoClient_1 = require("./spoClient");
class SPFxPluginImpl {
    async postScaffold(ctx) {
        var _a;
        try {
            const webpartName = ctx.answers[_1.SPFXQuestionNames.webpart_name];
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = lodash_1.default.camelCase(componentName);
            const componentId = uuid.v4();
            const componentClassName = `${componentName}WebPart`;
            const componentStrings = componentClassName + "Strings";
            const libraryName = lodash_1.default.kebabCase((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.appName);
            let componentAlias = componentClassName;
            if (componentClassName.length > constants_1.Constants.MAX_ALIAS_LENGTH) {
                componentAlias = componentClassName.substring(0, constants_1.Constants.MAX_ALIAS_LENGTH);
            }
            let componentClassNameKebabCase = lodash_1.default.kebabCase(componentClassName);
            if (componentClassNameKebabCase.length > constants_1.Constants.MAX_BUNDLE_NAME_LENGTH) {
                componentClassNameKebabCase = componentClassNameKebabCase.substring(0, constants_1.Constants.MAX_BUNDLE_NAME_LENGTH);
                const lastCharacterIndex = componentClassNameKebabCase.length - 1;
                if (componentClassNameKebabCase[lastCharacterIndex] === "-") {
                    componentClassNameKebabCase = componentClassNameKebabCase.substring(0, lastCharacterIndex);
                }
            }
            const outputFolderPath = `${ctx.root}/SPFx`;
            await fs.mkdir(outputFolderPath);
            // teams folder
            const teamsDir = `${outputFolderPath}/teams`;
            const templateFolder = path.join(__1.getTemplatesFolder(), "plugins", "resource", "spfx");
            await fs.mkdir(teamsDir);
            await fs.copyFile(path.resolve(templateFolder, "./webpart/base/images/color.png"), `${teamsDir}/${componentId}_color.png`);
            await fs.copyFile(path.resolve(templateFolder, "./webpart/base/images/outline.png"), `${teamsDir}/${componentId}_outline.png`);
            // src folder
            const srcDir = `${outputFolderPath}/src`;
            await fs.mkdir(srcDir);
            await fs.copyFile(path.resolve(templateFolder, "./solution/src/index.ts"), `${srcDir}/index.ts`);
            switch (ctx.answers[_1.SPFXQuestionNames.framework_type]) {
                case constants_1.Constants.FRAMEWORK_NONE:
                    fs.mkdirSync(`${srcDir}/webparts/${componentNameCamelCase}`, {
                        recursive: true,
                    });
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/none/{componentClassName}.module.scss"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.module.scss`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/none/{componentClassName}.ts"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.ts`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/none/package.json"), `${outputFolderPath}/package.json`);
                    break;
                case constants_1.Constants.FRAMEWORK_REACT:
                    const componentDir = `${srcDir}/webparts/${componentNameCamelCase}/components`;
                    fs.mkdirSync(componentDir, { recursive: true });
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/react/{componentClassName}.ts"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.ts`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/react/components/{componentName}.module.scss"), `${componentDir}/${componentName}.module.scss`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/react/components/{componentName}.tsx"), `${componentDir}/${componentName}.tsx`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/react/components/I{componentName}Props.ts"), `${componentDir}/I${componentName}Props.ts`);
                    await fs.copyFile(path.resolve(templateFolder, "./webpart/react/package.json"), `${outputFolderPath}/package.json`);
                    break;
            }
            await fs.copy(path.resolve(templateFolder, "./webpart/base/loc"), `${srcDir}/webparts/${componentNameCamelCase}/loc`);
            await fs.copy(path.resolve(templateFolder, "./webpart/base/{componentClassName}.manifest.json"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.manifest.json`);
            // config folder
            await fs.copy(path.resolve(templateFolder, "./solution/config"), `${outputFolderPath}/config`);
            // Other files
            await fs.copyFile(path.resolve(templateFolder, "./solution/README.md"), `${outputFolderPath}/README.md`);
            await fs.copyFile(path.resolve(templateFolder, "./solution/_gitignore"), `${outputFolderPath}/.gitignore`);
            await fs.copyFile(path.resolve(templateFolder, "./solution/gulpfile.js"), `${outputFolderPath}/gulpfile.js`);
            await fs.copyFile(path.resolve(templateFolder, "./solution/tsconfig.json"), `${outputFolderPath}/tsconfig.json`);
            await fs.copyFile(path.resolve(templateFolder, "./solution/tslint.json"), `${outputFolderPath}/tslint.json`);
            // Configure placeholders
            const replaceMap = new Map();
            replaceMap.set(constants_1.PlaceHolders.componentName, componentName);
            replaceMap.set(constants_1.PlaceHolders.componentNameCamelCase, componentNameCamelCase);
            replaceMap.set(constants_1.PlaceHolders.componentClassName, componentClassName);
            replaceMap.set(constants_1.PlaceHolders.componentStrings, componentStrings);
            replaceMap.set(constants_1.PlaceHolders.libraryName, libraryName);
            replaceMap.set(constants_1.PlaceHolders.componentId, componentId);
            replaceMap.set(constants_1.PlaceHolders.componentAlias, componentAlias);
            replaceMap.set(constants_1.PlaceHolders.componentDescription, ctx.answers[_1.SPFXQuestionNames.webpart_desp]);
            replaceMap.set(constants_1.PlaceHolders.componentNameUnescaped, webpartName);
            replaceMap.set(constants_1.PlaceHolders.componentClassNameKebabCase, componentClassNameKebabCase);
            const appDirectory = await tools_1.getAppDirectory(ctx.root);
            await utils_1.Utils.configure(outputFolderPath, replaceMap);
            if (tools_1.isMultiEnvEnabled()) {
                await utils_1.Utils.configure(path.join(appDirectory, constants_2.MANIFEST_TEMPLATE), replaceMap);
                await utils_1.Utils.configure(path.join(appDirectory, constants_2.MANIFEST_LOCAL), replaceMap);
            }
            else {
                await utils_1.Utils.configure(path.join(appDirectory, constants_2.REMOTE_MANIFEST), replaceMap);
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            return teamsfx_api_1.err(error_1.ScaffoldError(error));
        }
    }
    async buildSPPackage(ctx) {
        var _a, _b, _c, _d;
        const progressHandler = await progress_helper_1.ProgressHelper.startPreDeployProgressHandler(ctx);
        if (((_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.platform) === teamsfx_api_1.Platform.VSCode) {
            ctx.logProvider.outputChannel.show();
        }
        try {
            const workspacePath = `${ctx.root}/SPFx`;
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.NpmInstall));
            await utils_1.Utils.execute(`npm install`, "SPFx", workspacePath, ctx.logProvider, true);
            const gulpCommand = await SPFxPluginImpl.findGulpCommand(workspacePath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpBundle));
            await utils_1.Utils.execute(`${gulpCommand} bundle --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpPackage));
            await utils_1.Utils.execute(`${gulpCommand} package-solution --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
            const sharepointPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(sharepointPackage))) {
                throw error_1.NoSPPackageError(sharepointPackage);
            }
            const dir = path.normalize(path.parse(sharepointPackage).dir);
            if (((_b = ctx.answers) === null || _b === void 0 ? void 0 : _b.platform) === teamsfx_api_1.Platform.CLI) {
                const guidance = [
                    {
                        content: "Success: SharePoint package successfully built at ",
                        color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                    },
                    { content: dir, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", guidance, false);
            }
            else {
                const guidance = util.format(tools_1.getStrings().plugins.SPFx.buildNotice, dir);
                (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", guidance, false, "OK");
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            await progress_helper_1.ProgressHelper.endPreDeployProgress(false);
            return teamsfx_api_1.err(error_1.BuildSPPackageError(error));
        }
    }
    async preDeploy(ctx) {
        return this.buildSPPackage(ctx);
    }
    async deploy(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const progressHandler = await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx);
        let success = false;
        try {
            const tenant = await this.getTenant(ctx);
            if (tenant.isErr()) {
                return tenant;
            }
            spoClient_1.SPOClient.setBaseUrl(tenant.value);
            const spoToken = await ((_a = ctx.sharepointTokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken());
            if (!spoToken) {
                return teamsfx_api_1.err(error_1.GetSPOTokenFailedError());
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            }
            else {
                const res = await ((_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.showMessage("warn", util.format(tools_1.getStrings().plugins.SPFx.createAppCatalogNotice, tenant.value), true, constants_1.Constants.READ_MORE));
                const confirm = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
                switch (confirm) {
                    case "OK":
                        try {
                            await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        }
                        catch (e) {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(e));
                        }
                        let retry = 0;
                        appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                        while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                            retry += 1;
                        }
                        if (appCatalogSite) {
                            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                        }
                        else {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(new Error("Cannot get app catalog site url after creation.")));
                        }
                        break;
                    case constants_1.Constants.READ_MORE:
                        (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.openUrl(constants_1.Constants.CREATE_APP_CATALOG_GUIDE);
                        return teamsfx_api_1.ok(teamsfx_api_1.UserCancelError);
                    default:
                        return teamsfx_api_1.ok(undefined);
                }
            }
            const appPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(appPackage))) {
                return teamsfx_api_1.err(error_1.NoSPPackageError(appPackage));
            }
            const fileName = path.parse(appPackage).base;
            const bytes = await fs.readFile(appPackage);
            try {
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            }
            catch (e) {
                if (((_d = e.response) === null || _d === void 0 ? void 0 : _d.status) === 403) {
                    (_e = ctx.ui) === null || _e === void 0 ? void 0 : _e.showMessage("error", util.format(tools_1.getStrings().plugins.SPFx.deployFailedNotice, appCatalogSite), false, "OK");
                    return teamsfx_api_1.err(error_1.InsufficientPermissionError(appCatalogSite));
                }
                else {
                    return teamsfx_api_1.err(error_1.UploadAppPackageFailedError(e));
                }
            }
            const appID = await this.getAppID(ctx.root);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            const guidance = util.format(tools_1.getStrings().plugins.SPFx.deployNotice, appPackage, appCatalogSite, appCatalogSite);
            if (((_f = ctx.answers) === null || _f === void 0 ? void 0 : _f.platform) === teamsfx_api_1.Platform.CLI) {
                (_g = ctx.ui) === null || _g === void 0 ? void 0 : _g.showMessage("info", guidance, false);
            }
            else {
                (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", guidance, false, "OK");
            }
            success = true;
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            await progress_helper_1.ProgressHelper.endDeployProgress(success);
        }
    }
    async getTenant(ctx) {
        var _a, _b;
        const graphToken = await ((_a = ctx.graphTokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        if (!graphToken) {
            return teamsfx_api_1.err(error_1.GetGraphTokenFailedError());
        }
        const tokenJson = await ((_b = ctx.graphTokenProvider) === null || _b === void 0 ? void 0 : _b.getJsonObject());
        const username = tokenJson.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                return teamsfx_api_1.err(error_1.GetTenantFailedError(username));
            }
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.GetTenantFailedError(username, e));
        }
        return teamsfx_api_1.ok(tenant);
    }
    async getPackage(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const sharepointPackage = `${root}/SPFx/sharepoint/${solutionConfig.paths.zippedPackage}`;
        return sharepointPackage;
    }
    async getAppID(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
    static async findGulpCommand(rootPath) {
        let gulpCommand;
        const platform = process.platform;
        if (platform === "win32" &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp.cmd")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp.cmd");
        }
        else if ((platform === "linux" || platform === "darwin") &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp");
        }
        else {
            gulpCommand = "gulp";
        }
        return gulpCommand;
    }
}
exports.SPFxPluginImpl = SPFxPluginImpl;
//# sourceMappingURL=plugin.js.map