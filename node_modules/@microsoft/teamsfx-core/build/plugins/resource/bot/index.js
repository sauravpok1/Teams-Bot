"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsBot = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const result_1 = require("./result");
const plugin_1 = require("./plugin");
const progressBars_1 = require("./progressBars");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const question_1 = require("../../solution/fx-solution/question");
const typedi_1 = require("typedi");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
require("./v2");
let TeamsBot = class TeamsBot {
    constructor() {
        this.name = "fx-resource-bot";
        this.displayName = "Bot";
        this.teamsBotImpl = new plugin_1.TeamsBotImpl();
    }
    activate(solutionSettings) {
        const cap = solutionSettings.capabilities || [];
        return cap.includes(question_1.BotOptionItem.id) || cap.includes(question_1.MessageExtensionItem.id);
    }
    async scaffold(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.scaffold(context), true, constants_1.LifecycleFuncNames.SCAFFOLD);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.SCAFFOLD_TITLE);
        return result;
    }
    async preProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await this.runWithExceptionCatching(context, () => this.teamsBotImpl.preProvision(context), true, constants_1.LifecycleFuncNames.PRE_PROVISION);
    }
    async provision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.provision(context), true, constants_1.LifecycleFuncNames.PROVISION);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.PROVISION_TITLE);
        return result;
    }
    async postProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await this.runWithExceptionCatching(context, () => this.teamsBotImpl.postProvision(context), true, constants_1.LifecycleFuncNames.POST_PROVISION);
    }
    async updateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.updateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
        return result;
    }
    async generateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.generateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
        return result;
    }
    async preDeploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await this.runWithExceptionCatching(context, () => this.teamsBotImpl.preDeploy(context), true, constants_1.LifecycleFuncNames.PRE_DEPLOY);
    }
    async deploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.deploy(context), true, constants_1.LifecycleFuncNames.DEPLOY);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.DEPLOY_TITLE);
        return result;
    }
    async localDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await this.runWithExceptionCatching(context, () => this.teamsBotImpl.localDebug(context), false, constants_1.LifecycleFuncNames.LOCAL_DEBUG);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.LOCAL_DEBUG_TITLE);
        return result;
    }
    async postLocalDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await this.runWithExceptionCatching(context, () => this.teamsBotImpl.postLocalDebug(context), false, constants_1.LifecycleFuncNames.POST_LOCAL_DEBUG);
    }
    async executeUserTask(func, context) {
        logger_1.Logger.setLogger(context.logProvider);
        if (func.method === "migrateV1Project") {
            return await this.runWithExceptionCatching(context, () => this.teamsBotImpl.migrateV1Project(context), true, constants_1.LifecycleFuncNames.MIGRATE_V1_PROJECT);
        }
        return teamsfx_api_1.ok(undefined);
    }
    wrapError(e, context, sendTelemetry, name) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        let errorMsg = e.message;
        if (e.innerError) {
            errorMsg += ` Detailed error: ${e.innerError.message}.`;
            if ((_b = (_a = e.innerError.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errorMessage) {
                errorMsg += ` Reason: ${(_d = (_c = e.innerError.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.errorMessage}`;
            }
            else if ((_g = (_f = (_e = e.innerError.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.message) {
                // For errors return from Graph API
                errorMsg += ` Reason: ${(_k = (_j = (_h = e.innerError.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.error) === null || _k === void 0 ? void 0 : _k.message}`;
            }
        }
        logger_1.Logger.error(errorMsg);
        if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
            const res = teamsfx_api_1.err(e);
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, res);
            return res;
        }
        if (e instanceof errors_1.PluginError) {
            const result = e.errorType === errors_1.ErrorType.System
                ? result_1.FxBotPluginResultFactory.SystemError(e.name, e.genMessage(), e.innerError)
                : result_1.FxBotPluginResultFactory.UserError(e.name, e.genMessage(), e.innerError, e.helpLink);
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, result);
            return result;
        }
        else {
            // Unrecognized Exception.
            const UnhandledErrorCode = "UnhandledError";
            sendTelemetry &&
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, result_1.FxBotPluginResultFactory.SystemError(UnhandledErrorCode, `Got an unhandled error: ${e.message}`, e.innerError));
            return result_1.FxBotPluginResultFactory.SystemError(UnhandledErrorCode, e.message, e.innerError);
        }
    }
    async runWithExceptionCatching(context, fn, sendTelemetry, name) {
        try {
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendStartEvent(context, name);
            const res = await fn();
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, res);
            return res;
        }
        catch (e) {
            await progressBars_1.ProgressBarFactory.closeProgressBar(false); // Close all progress bars.
            return this.wrapError(e, context, sendTelemetry, name);
        }
    }
};
TeamsBot = tslib_1.__decorate([
    typedi_1.Service(ResourcePluginContainer_1.ResourcePlugins.BotPlugin)
], TeamsBot);
exports.TeamsBot = TeamsBot;
exports.default = new TeamsBot();
//# sourceMappingURL=index.js.map