"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithErrorCatchAndWrap = exports.runWithErrorCatchAndThrow = exports.UnhandledErrorMessage = exports.UnhandledErrorCode = exports.UploadZipError = exports.PublishCredentialError = exports.ZipError = exports.BuildError = exports.ProjectPathError = exports.ConfigureWebAppError = exports.ProvisionError = exports.FetchConfigError = exports.BlazorPluginError = exports.ErrorType = void 0;
const logger_1 = require("../../utils/logger");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const errors_1 = require("../../resources/errors");
var ErrorType;
(function (ErrorType) {
    ErrorType[ErrorType["User"] = 0] = "User";
    ErrorType[ErrorType["System"] = 1] = "System";
})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
const tips = {
    checkLog: "Check log for more information.",
    doProvision: `Run 'Provision Resource' before this command.`,
    reProvision: `Run 'Provision' command again.`,
    reDeploy: "Run 'Deploy' command again.",
    checkNetwork: "Check your network connection.",
    checkFsPermissions: "Check if you have Read/Write permissions to your file system.",
    restoreEnvironment: `If you manually updated configuration files (under directory .${teamsfx_api_1.ConfigFolderName}), recover them.`,
};
class BlazorPluginError extends errors_1.FrontendPluginError {
    constructor(errorType, code, message, suggestions, helpLink, innerError) {
        super(errorType, code, message, suggestions, helpLink);
        this.innerError = innerError;
    }
    getMessage() {
        return `${this.message} Suggestions: ${this.suggestions.join(" ")}`;
    }
    setInnerError(error) {
        this.innerError = error;
    }
    getInnerError() {
        return this.innerError;
    }
}
exports.BlazorPluginError = BlazorPluginError;
class FetchConfigError extends BlazorPluginError {
    constructor(key) {
        super(ErrorType.User, "FetchConfigError", `Failed to find ${key} from configuration`, [
            tips.restoreEnvironment,
        ]);
    }
}
exports.FetchConfigError = FetchConfigError;
class ProvisionError extends BlazorPluginError {
    constructor(resource, innerErrorCode) {
        super(ErrorType.User, "ProvisionError", `Failed to check/create '${resource}' for blazor app${innerErrorCode ? `: ${innerErrorCode}` : ""}.`, [tips.reProvision]);
    }
}
exports.ProvisionError = ProvisionError;
class ConfigureWebAppError extends BlazorPluginError {
    constructor(innerErrorCode) {
        super(ErrorType.User, "ConfigureWebAppError", `Failed to retrieve or update Azure Web App Settings${innerErrorCode ? `: ${innerErrorCode}` : ""}.`, [tips.reProvision]);
    }
}
exports.ConfigureWebAppError = ConfigureWebAppError;
class ProjectPathError extends BlazorPluginError {
    constructor(projectFilePath) {
        super(ErrorType.User, "ProjectPathError", `Failed to find target project ${projectFilePath}.`, [
            tips.checkLog,
            tips.restoreEnvironment,
        ]);
    }
}
exports.ProjectPathError = ProjectPathError;
class BuildError extends BlazorPluginError {
    constructor(innerError) {
        super(ErrorType.User, "BuildError", "Failed to build Blazor project.", [tips.checkLog, tips.reDeploy], undefined, innerError);
    }
}
exports.BuildError = BuildError;
class ZipError extends BlazorPluginError {
    constructor() {
        super(ErrorType.User, "ZipError", "Failed to generate zip package.", [
            tips.checkFsPermissions,
            tips.reDeploy,
        ]);
    }
}
exports.ZipError = ZipError;
class PublishCredentialError extends BlazorPluginError {
    constructor() {
        super(ErrorType.User, "PublishCredentialError", "Failed to retrieve publish credential.", [
            tips.doProvision,
            tips.reDeploy,
        ]);
    }
}
exports.PublishCredentialError = PublishCredentialError;
class UploadZipError extends BlazorPluginError {
    constructor() {
        super(ErrorType.User, "UploadZipError", "Failed to upload zip package.", [
            tips.checkNetwork,
            tips.reDeploy,
        ]);
    }
}
exports.UploadZipError = UploadZipError;
exports.UnhandledErrorCode = "UnhandledError";
exports.UnhandledErrorMessage = "Unhandled error.";
async function runWithErrorCatchAndThrow(error, fn) {
    try {
        return await Promise.resolve(fn());
    }
    catch (e) {
        logger_1.Logger.error(e.toString());
        error.setInnerError(e);
        throw error;
    }
}
exports.runWithErrorCatchAndThrow = runWithErrorCatchAndThrow;
async function runWithErrorCatchAndWrap(wrap, fn) {
    try {
        return await Promise.resolve(fn());
    }
    catch (e) {
        logger_1.Logger.error(e.toString());
        const error = wrap(e);
        error.setInnerError(e);
        throw error;
    }
}
exports.runWithErrorCatchAndWrap = runWithErrorCatchAndWrap;
//# sourceMappingURL=errors.js.map