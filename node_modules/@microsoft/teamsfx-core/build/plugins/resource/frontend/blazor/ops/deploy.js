"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipDeploy = exports.generateZip = exports.build = exports.getFrameworkVersion = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const templatesUtils_1 = require("../../../../../common/templatesUtils");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("../resources/errors");
const constants_1 = require("../constants");
const execute_1 = require("../../../function/utils/execute");
const dir_walk_1 = require("../../../function/utils/dir-walk");
async function getFrameworkVersion(projectFilePath) {
    const content = await fs_extra_1.default.readFile(projectFilePath, "utf8");
    const framework = content.match(constants_1.RegularExpr.targetFramework);
    if (framework === null || framework === void 0 ? void 0 : framework.length) {
        return framework[0].trim();
    }
    return constants_1.BlazorPluginInfo.defaultFramework;
}
exports.getFrameworkVersion = getFrameworkVersion;
async function build(path, runtime) {
    const command = constants_1.BlazorCommands.buildRelease(runtime);
    await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.BuildError(error), async () => await execute_1.execute(command, path));
}
exports.build = build;
async function generateZip(componentPath) {
    const zip = new adm_zip_1.default();
    const tasks = [];
    const zipFiles = new Set();
    const addFileIntoZip = async (zip, filePath, zipPath) => {
        const content = await fs_extra_1.default.readFile(filePath);
        zip.addFile(zipPath, content);
    };
    await dir_walk_1.forEachFileAndDir(componentPath, (itemPath, stats) => {
        const relativePath = path.relative(componentPath, itemPath);
        if (relativePath && !stats.isDirectory()) {
            zipFiles.add(relativePath);
            // If fail to reuse cached entry, load it from disk.
            const fullPath = path.join(componentPath, relativePath);
            const task = addFileIntoZip(zip, fullPath, relativePath);
            tasks.push(task);
        }
    });
    await Promise.all(tasks);
    return zip;
}
exports.generateZip = generateZip;
async function zipDeploy(client, resourceGroupName, webAppName, componentPath) {
    const zip = await errors_1.runWithErrorCatchAndThrow(new errors_1.ZipError(), async () => await generateZip(componentPath));
    const zipContent = zip.toBuffer();
    const publishCred = await errors_1.runWithErrorCatchAndThrow(new errors_1.PublishCredentialError(), async () => await client.webApps.listPublishingCredentials(resourceGroupName, webAppName));
    const username = publishCred.publishingUserName;
    const password = publishCred.publishingPassword;
    if (!password) {
        // TODO: Logger.error("Filaed to query publish cred.");
        throw new errors_1.PublishCredentialError();
    }
    await errors_1.runWithErrorCatchAndThrow(new errors_1.UploadZipError(), async () => await templatesUtils_1.sendRequestWithRetry(async () => await axios_1.default.post(constants_1.AzureInfo.zipDeployURL(webAppName), zipContent, {
        headers: {
            "Content-Type": "application/octet-stream",
            "Cache-Control": "no-cache",
        },
        auth: {
            username: username,
            password: password,
        },
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        timeout: 10 * 60 * 1000,
    }), 3));
}
exports.zipDeploy = zipDeploy;
//# sourceMappingURL=deploy.js.map