"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const clients_1 = require("./clients");
const errors_1 = require("./resources/errors");
const constants_1 = require("./constants");
const configs_1 = require("./configs");
const deploy_1 = require("./ops/deploy");
const logger_1 = require("./utils/logger");
const messages_1 = require("./resources/messages");
const scaffold_1 = require("./ops/scaffold");
const progress_helper_1 = require("./utils/progress-helper");
const templateInfo_1 = require("./resources/templateInfo");
const azure_client_1 = require("./utils/azure-client");
const folder_1 = require("../../../folder");
const constants_2 = require("../../../common/constants");
const common_1 = require("../../../common");
const question_1 = require("../../solution/fx-solution/question");
const env_1 = require("./env");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../solution/fx-solution/v2/adaptor");
const tools_1 = require("../../../common/tools");
class FrontendPluginImpl {
    async scaffold(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartScaffold(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ctx);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.ScaffoldSteps.Scaffold));
        const templateInfo = new templateInfo_1.TemplateInfo(ctx);
        await scaffold_1.FrontendScaffold.scaffoldFromZipPackage(path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir), templateInfo);
        await progress_helper_1.ProgressHelper.endScaffoldProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndScaffold(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async preProvision(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartPreProvision(constants_1.FrontendPluginInfo.DisplayName));
        await this.ensureResourceGroupExists(new clients_1.AzureStorageClient(await configs_1.FrontendConfig.fromPluginContext(ctx)));
        logger_1.Logger.info(messages_1.Messages.EndPreProvision(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async provision(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartProvision(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.startProvisionProgressHandler(ctx);
        const config = await configs_1.FrontendConfig.fromPluginContext(ctx);
        const provider = azure_client_1.AzureClientFactory.getResourceProviderClient(config.credentials, config.subscriptionId);
        const client = new clients_1.AzureStorageClient(config);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.ProvisionSteps.RegisterResourceProvider));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.RegisterResourceProviderError(), async () => await azure_client_1.AzureLib.ensureResourceProviders(provider, constants_1.AzureInfo.RequiredResourceProviders));
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.ProvisionSteps.CreateStorage));
        const createStorageErrorWrapper = (innerError) => {
            if (innerError.code === constants_1.AzureErrorCode.ReservedResourceName) {
                return new errors_1.InvalidStorageNameError();
            }
            if (innerError.code === constants_1.AzureErrorCode.StorageAccountAlreadyTaken ||
                innerError.code === constants_1.AzureErrorCode.StorageAccountAlreadyExists) {
                return new errors_1.StorageAccountAlreadyTakenError();
            }
            return new errors_1.CreateStorageAccountError(innerError.code);
        };
        config.endpoint = await errors_1.runWithErrorCatchAndWrap(createStorageErrorWrapper, async () => await client.createStorageAccount());
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.ProvisionSteps.Configure));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.EnableStaticWebsiteError(), async () => await client.enableStaticWebsite());
        config.domain = new URL(config.endpoint).hostname;
        config.syncToPluginContext(ctx);
        await progress_helper_1.ProgressHelper.endProvisionProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndProvision(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async postProvision(ctx) {
        if (common_1.isArmSupportEnabled()) {
            logger_1.Logger.info(messages_1.Messages.StartPostProvision(constants_1.FrontendPluginInfo.DisplayName));
            const progressHandler = await progress_helper_1.ProgressHelper.startPostProvisionProgressHandler(ctx);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.PostProvisionSteps.EnableStaticWebsite));
            const client = new clients_1.AzureStorageClient(await configs_1.FrontendConfig.fromPluginContext(ctx));
            await errors_1.runWithErrorCatchAndThrow(new errors_1.EnableStaticWebsiteError(), async () => await client.enableStaticWebsite());
            await progress_helper_1.ProgressHelper.endPostProvisionProgress(true);
            logger_1.Logger.info(messages_1.Messages.EndPostProvision(constants_1.FrontendPluginInfo.DisplayName));
        }
        await this.updateDotEnv(ctx);
        return teamsfx_api_1.ok(undefined);
    }
    async preDeploy(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartPreDeploy(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.createPreDeployProgressHandler(ctx);
        await this.updateDotEnv(ctx);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.PreDeploySteps.CheckStorage));
        await this.checkStorageAvailability(ctx);
        await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndPreDeploy(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartDeploy(constants_1.FrontendPluginInfo.DisplayName));
        await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx);
        const config = await configs_1.FrontendConfig.fromPluginContext(ctx);
        const client = new clients_1.AzureStorageClient(config);
        const componentPath = path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir);
        const envName = ctx.envInfo.envName;
        const envs = await env_1.loadEnvFile(env_1.envFilePath(envName, componentPath));
        await deploy_1.FrontendDeployment.doFrontendBuild(componentPath, envs, envName);
        await deploy_1.FrontendDeployment.doFrontendDeployment(client, componentPath, envName);
        await progress_helper_1.ProgressHelper.endDeployProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndDeploy(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async updateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartUpdateArmTemplates(constants_1.FrontendPluginInfo.DisplayName));
        const result = {
            Reference: {
                endpoint: constants_1.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_1.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok(result);
    }
    async generateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartGenerateArmTemplates(constants_1.FrontendPluginInfo.DisplayName));
        const azureSolutionSettings = ctx.projectSettings.solutionSettings;
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSolutionSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const bicepTemplateDir = path_1.default.join(folder_1.getTemplatesFolder(), constants_1.FrontendPathInfo.BicepTemplateRelativeDir);
        const provisionFilePath = path_1.default.join(bicepTemplateDir, constants_2.Bicep.ProvisionFileName);
        const moduleProvisionFilePath = path_1.default.join(bicepTemplateDir, constants_1.FrontendPathInfo.ModuleProvisionFileName);
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionFilePath, pluginCtx);
        const provisionModules = await tools_1.generateBicepFromFile(moduleProvisionFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { frontendHosting: provisionModules },
            },
            Reference: {
                endpoint: constants_1.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_1.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok(result);
    }
    collectEnvs(ctx) {
        var _a, _b, _c, _d, _e, _f, _g;
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        const solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
        if ((_b = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.azureResources) === null || _b === void 0 ? void 0 : _b.includes(question_1.AzureResourceFunction.id)) {
            addToEnvs(env_1.EnvKeys.FuncName, (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.defaultFunctionName);
            addToEnvs(env_1.EnvKeys.FuncEndpoint, (_d = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.FunctionPluginName)) === null || _d === void 0 ? void 0 : _d.get(constants_1.DependentPluginInfo.FunctionEndpoint));
        }
        if (tools_1.IsSimpleAuthEnabled(ctx.projectSettings)) {
            addToEnvs(env_1.EnvKeys.RuntimeEndpoint, (_e = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.RuntimePluginName)) === null || _e === void 0 ? void 0 : _e.get(constants_1.DependentPluginInfo.RuntimeEndpoint));
            addToEnvs(env_1.EnvKeys.StartLoginPage, constants_1.DependentPluginInfo.StartLoginPageURL);
        }
        if ((_f = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins) === null || _f === void 0 ? void 0 : _f.includes(constants_1.DependentPluginInfo.AADPluginName)) {
            addToEnvs(env_1.EnvKeys.ClientID, (_g = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.AADPluginName)) === null || _g === void 0 ? void 0 : _g.get(constants_1.DependentPluginInfo.ClientID));
        }
        return envs;
    }
    async updateDotEnv(ctx) {
        const envs = this.collectEnvs(ctx);
        await env_1.saveEnvFile(env_1.envFilePath(ctx.envInfo.envName, path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir)), {
            teamsfxRemoteEnvs: envs,
            customizedRemoteEnvs: {},
        });
    }
    async executeUserTask(func, ctx) {
        if (func.method === "migrateV1Project") {
            logger_1.Logger.info(messages_1.Messages.StartMigrateV1Project(constants_1.FrontendPluginInfo.DisplayName));
            const progressHandler = await progress_helper_1.ProgressHelper.startMigrateProgressHandler(ctx);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(progress_helper_1.MigrateSteps.Migrate));
            const sourceFolder = path_1.default.join(ctx.root, teamsfx_api_1.ArchiveFolderName);
            const distFolder = path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir);
            const excludeFiles = [
                { fileName: teamsfx_api_1.ArchiveFolderName, recursive: false },
                { fileName: teamsfx_api_1.ArchiveLogFileName, recursive: false },
                { fileName: teamsfx_api_1.AppPackageFolderName, recursive: false },
                { fileName: constants_1.FrontendPathInfo.NodePackageFolderName, recursive: true },
            ];
            await errors_1.runWithErrorCatchAndThrow(new errors_1.MigrateV1ProjectError(), async () => {
                await common_1.copyFiles(sourceFolder, distFolder, excludeFiles);
            });
            await progress_helper_1.ProgressHelper.endMigrateProgress(true);
            logger_1.Logger.info(messages_1.Messages.EndMigrateV1Project(constants_1.FrontendPluginInfo.DisplayName));
            return teamsfx_api_1.ok(undefined);
        }
        throw new errors_1.UserTaskNotImplementedError(func.method);
    }
    async checkStorageAvailability(ctx) {
        const client = new clients_1.AzureStorageClient(await configs_1.FrontendConfig.fromPluginContext(ctx));
        await this.ensureResourceGroupExists(client);
        await this.ensureStorageExists(client);
        await this.ensureStorageAvailable(client);
    }
    async ensureResourceGroupExists(client) {
        const resourceGroupExists = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckResourceGroupError(), async () => await client.doesResourceGroupExists());
        if (!resourceGroupExists) {
            throw new errors_1.NoResourceGroupError();
        }
    }
    async ensureStorageExists(client) {
        const storageExists = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckStorageError(), async () => await client.doesStorageAccountExists());
        if (!storageExists) {
            throw new errors_1.NoStorageError();
        }
    }
    async ensureStorageAvailable(client) {
        const storageAvailable = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckStorageError(), async () => await client.isStorageStaticWebsiteEnabled());
        if (!storageAvailable) {
            throw new errors_1.StaticWebsiteDisabledError();
        }
    }
}
exports.FrontendPluginImpl = FrontendPluginImpl;
//# sourceMappingURL=plugin.js.map