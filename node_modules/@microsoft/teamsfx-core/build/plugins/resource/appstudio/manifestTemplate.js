"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCapabilities = exports.capabilityExceedLimit = exports.saveManifest = exports.loadManifest = exports.init = exports.getManifestTemplatePath = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const common_1 = require("../../../common");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_1 = require("./constants");
async function getManifestTemplatePath(projectRoot, isLocalDebug) {
    const appDir = await common_1.getAppDirectory(projectRoot);
    return isLocalDebug ? `${appDir}/${constants_1.MANIFEST_LOCAL}` : `${appDir}/${constants_1.MANIFEST_TEMPLATE}`;
}
exports.getManifestTemplatePath = getManifestTemplatePath;
async function init(projectRoot) {
    const localManifestString = constants_1.TEAMS_APP_MANIFEST_TEMPLATE_LOCAL_DEBUG;
    const localManifest = JSON.parse(localManifestString);
    await saveManifest(projectRoot, localManifest, true);
    const remoteManifestString = constants_1.TEAMS_APP_MANIFEST_TEMPLATE_FOR_MULTI_ENV;
    const remoteManifest = JSON.parse(remoteManifestString);
    await saveManifest(projectRoot, remoteManifest, false);
}
exports.init = init;
async function loadManifest(projectRoot, isLocalDebug) {
    const manifestFilePath = await getManifestTemplatePath(projectRoot, isLocalDebug);
    if (!(await fs.pathExists(manifestFilePath))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(manifestFilePath)));
    }
    try {
        const manifest = await fs.readJson(manifestFilePath);
        return teamsfx_api_1.ok(manifest);
    }
    catch (e) {
        if (e.stack && e.stack.startsWith("SyntaxError")) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestFilePath}, due to ${e.message}`)));
        }
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestFilePath}, due to ${e.message}`)));
    }
}
exports.loadManifest = loadManifest;
async function saveManifest(projectRoot, manifest, isLocalDebug) {
    const manifestFilePath = await getManifestTemplatePath(projectRoot, isLocalDebug);
    await fs.writeFile(manifestFilePath, JSON.stringify(manifest, null, 4));
    return teamsfx_api_1.ok(manifestFilePath);
}
exports.saveManifest = saveManifest;
async function capabilityExceedLimit(projectRoot, capability) {
    const localManifest = await loadManifest(projectRoot, true);
    if (localManifest.isErr()) {
        return teamsfx_api_1.err(localManifest.error);
    }
    const remoteManifest = await loadManifest(projectRoot, false);
    if (remoteManifest.isErr()) {
        return teamsfx_api_1.err(remoteManifest.error);
    }
    let localExceed, remoteExceed = false;
    switch (capability) {
        case "staticTab":
            localExceed =
                localManifest.value.staticTabs !== undefined &&
                    localManifest.value.staticTabs.length >= constants_1.STATIC_TABS_MAX_ITEMS;
            remoteExceed =
                remoteManifest.value.staticTabs !== undefined &&
                    remoteManifest.value.staticTabs.length >= constants_1.STATIC_TABS_MAX_ITEMS;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "configurableTab":
            localExceed =
                localManifest.value.configurableTabs !== undefined &&
                    localManifest.value.configurableTabs.length >= 1;
            remoteExceed =
                remoteManifest.value.configurableTabs !== undefined &&
                    remoteManifest.value.configurableTabs.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "Bot":
            localExceed = localManifest.value.bots !== undefined && localManifest.value.bots.length >= 1;
            remoteExceed =
                remoteManifest.value.bots !== undefined && remoteManifest.value.bots.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "MessageExtension":
            localExceed =
                localManifest.value.composeExtensions !== undefined &&
                    localManifest.value.composeExtensions.length >= 1;
            remoteExceed =
                remoteManifest.value.composeExtensions !== undefined &&
                    remoteManifest.value.composeExtensions.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        default:
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.InvalidCapabilityError.name, errors_1.AppStudioError.InvalidCapabilityError.message(capability)));
    }
}
exports.capabilityExceedLimit = capabilityExceedLimit;
async function addCapabilities(projectRoot, capabilities) {
    const localManifestRes = await loadManifest(projectRoot, true);
    if (localManifestRes.isErr()) {
        return teamsfx_api_1.err(localManifestRes.error);
    }
    const localManifest = localManifestRes.value;
    const remoteManifestRes = await loadManifest(projectRoot, false);
    if (remoteManifestRes.isErr()) {
        return teamsfx_api_1.err(remoteManifestRes.error);
    }
    const remoteManifest = remoteManifestRes.value;
    capabilities.map((capability) => {
        switch (capability.name) {
            case "staticTab":
                if (!localManifest.staticTabs) {
                    Object.assign(localManifest.staticTabs, []);
                }
                if (!remoteManifest.staticTabs) {
                    Object.assign(remoteManifest.staticTabs, []);
                }
                if (capability.snippet) {
                    localManifest.staticTabs.push(capability.snippet.local);
                    remoteManifest.staticTabs.push(capability.snippet.remote);
                }
                else {
                    localManifest.staticTabs = localManifest.staticTabs.concat(constants_1.STATIC_TABS_TPL_LOCAL_DEBUG);
                    remoteManifest.staticTabs = remoteManifest.staticTabs.concat(constants_1.STATIC_TABS_TPL_FOR_MULTI_ENV);
                }
                break;
            case "configurableTab":
                if (!localManifest.configurableTabs) {
                    Object.assign(localManifest.configurableTabs, []);
                }
                if (!remoteManifest.configurableTabs) {
                    Object.assign(remoteManifest.configurableTabs, []);
                }
                if (capability.snippet) {
                    localManifest.configurableTabs.push(capability.snippet.local);
                    remoteManifest.configurableTabs.push(capability.snippet.remote);
                }
                else {
                    localManifest.configurableTabs = localManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_LOCAL_DEBUG);
                    remoteManifest.configurableTabs = remoteManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_FOR_MULTI_ENV);
                }
                break;
            case "Bot":
                if (!localManifest.bots) {
                    Object.assign(localManifest.bots, []);
                }
                if (!remoteManifest.bots) {
                    Object.assign(remoteManifest.bots, []);
                }
                if (capability.snippet) {
                    localManifest.bots.push(capability.snippet.local);
                    remoteManifest.bots.push(capability.snippet.remote);
                }
                else {
                    localManifest.bots = localManifest.bots.concat(constants_1.BOTS_TPL_LOCAL_DEBUG);
                    remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_FOR_MULTI_ENV);
                }
                break;
            case "MessageExtension":
                if (!localManifest.composeExtensions) {
                    Object.assign(localManifest.composeExtensions, []);
                }
                if (!remoteManifest.composeExtensions) {
                    Object.assign(remoteManifest.composeExtensions, []);
                }
                if (capability.snippet) {
                    localManifest.composeExtensions.push(capability.snippet.local);
                    remoteManifest.composeExtensions.push(capability.snippet.remote);
                }
                else {
                    localManifest.composeExtensions = localManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_LOCAL_DEBUG);
                    remoteManifest.composeExtensions = remoteManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV);
                }
                break;
        }
    });
    let res = await saveManifest(projectRoot, localManifest, true);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    res = await saveManifest(projectRoot, remoteManifest, false);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.addCapabilities = addCapabilities;
//# sourceMappingURL=manifestTemplate.js.map