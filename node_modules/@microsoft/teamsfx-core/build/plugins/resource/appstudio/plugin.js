"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createManifest = exports.createLocalManifest = exports.AppStudioPluginImpl = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const appStudio_1 = require("./appStudio");
const question_1 = require("../../solution/fx-solution/question");
const constants_1 = require("../../solution/fx-solution/constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_2 = require("./constants");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs = tslib_1.__importStar(require("fs-extra"));
const __1 = require("../../..");
const path_1 = tslib_1.__importDefault(require("path"));
const common_1 = require("../../../common");
const localSettingsConstants_1 = require("../../../common/localSettingsConstants");
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const utils_1 = require("./utils/utils");
const telemetry_1 = require("./utils/telemetry");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const constants_3 = require("../../../common/constants");
const manifestTemplate_1 = require("./manifestTemplate");
class AppStudioPluginImpl {
    constructor() {
        this.commonProperties = {};
    }
    async getAppDefinitionAndUpdate(ctx, isLocalDebug, manifest) {
        var _a, _b;
        let teamsAppId;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        if (isLocalDebug) {
            const appDefinitionAndManifest = await this.getAppDefinitionAndManifest(ctx, true);
            if (appDefinitionAndManifest.isErr()) {
                return teamsfx_api_1.err(appDefinitionAndManifest.error);
            }
            const localTeamsAppID = await this.getTeamsAppId(ctx, true);
            let createIfNotExist = false;
            if (!localTeamsAppID) {
                createIfNotExist = true;
            }
            else {
                const appStudioToken = await ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken());
                try {
                    await appStudio_1.AppStudioClient.getApp(localTeamsAppID, appStudioToken, ctx.logProvider);
                }
                catch (error) {
                    createIfNotExist = true;
                }
            }
            teamsAppId = await this.updateApp(ctx, appDefinitionAndManifest.value[0], appStudioToken, isLocalDebug, createIfNotExist, appDirectory, createIfNotExist ? undefined : localTeamsAppID, ctx.logProvider);
            return teamsAppId;
        }
        else {
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, true);
            if (appDefinitionRes.isErr()) {
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            teamsAppId = await this.updateApp(ctx, appDefinitionRes.value, appStudioToken, isLocalDebug, true, appDirectory, undefined, ctx.logProvider);
            return teamsAppId;
        }
    }
    async getSPFxLocalDebugAppDefinitionAndUpdate(ctx, manifest) {
        var _a;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const localTeamsAppID = await this.getTeamsAppId(ctx, true);
        let create = !localTeamsAppID;
        if (localTeamsAppID) {
            try {
                await appStudio_1.AppStudioClient.getApp(localTeamsAppID, appStudioToken, ctx.logProvider);
            }
            catch (error) {
                create = true;
            }
        }
        const view = {
            localSettings: {
                teamsApp: {
                    teamsAppId: localTeamsAppID,
                },
            },
        };
        const manifestString = mustache_1.default.render(JSON.stringify(manifest), view);
        manifest = JSON.parse(manifestString);
        const appDefinition = await this.convertToAppDefinition(ctx, manifest, false);
        if (appDefinition.isErr()) {
            return teamsfx_api_1.err(appDefinition.error);
        }
        const teamsAppId = await this.updateApp(ctx, appDefinition.value, appStudioToken, true, create, appDirectory, create ? undefined : localTeamsAppID, ctx.logProvider);
        return teamsAppId;
    }
    /**
     * generate app manifest template according to existing manifest
     * @param settings
     * @returns
     */
    async createV1Manifest(ctx) {
        var _a, _b;
        const archiveManifestPath = path_1.default.join(ctx.root, teamsfx_api_1.ArchiveFolderName, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.V1ManifestFileName);
        const manifestSourceRes = await this.reloadManifest(archiveManifestPath);
        if (manifestSourceRes.isErr()) {
            throw manifestSourceRes.error;
        }
        const manifestSource = manifestSourceRes.value;
        let manifestString = (await fs.readFile(archiveManifestPath)).toString();
        manifestString = this.replaceExistingValueToPlaceholder(manifestString, manifestSource.developer.websiteUrl, "{{{localSettings.frontend.tabEndpoint}}}");
        const manifest = JSON.parse(manifestString);
        manifest.id = "{{localSettings.teamsApp.teamsAppId}}";
        manifest.validDomains = [];
        const includeBot = (_b = ((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings).activeResourcePlugins) === null || _b === void 0 ? void 0 : _b.includes(constants_1.PluginNames.BOT);
        if (includeBot) {
            if (manifest.bots !== undefined && manifest.bots.length > 0) {
                for (let index = 0; index < manifest.bots.length; ++index) {
                    manifest.bots[index].botId = "{{localSettings.bot.botId}}";
                }
            }
            if (manifest.composeExtensions !== undefined && manifest.composeExtensions.length > 0) {
                for (let index = 0; index < manifest.composeExtensions.length; ++index) {
                    manifest.composeExtensions[index].botId = "{{localSettings.bot.botId}}";
                }
            }
        }
        return manifest;
    }
    async provision(ctx) {
        var _a, _b, _c;
        let remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
        let create = false;
        if (!remoteTeamsAppId) {
            create = true;
        }
        else {
            const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
            try {
                await appStudio_1.AppStudioClient.getApp(remoteTeamsAppId, appStudioToken, ctx.logProvider);
            }
            catch (error) {
                create = true;
            }
        }
        if (create) {
            const result = await this.createApp(ctx, false);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            remoteTeamsAppId = result.value.teamsAppId;
            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`Teams app created ${remoteTeamsAppId}`);
        }
        (_c = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _c === void 0 ? void 0 : _c.set(constants_2.Constants.TEAMS_APP_ID, remoteTeamsAppId);
        return teamsfx_api_1.ok(remoteTeamsAppId);
    }
    async postProvision(ctx) {
        var _a, _b;
        const remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
        let manifestString;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, false);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        else {
            manifestString = JSON.stringify(manifestResult.value);
        }
        let appDefinition;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, false);
            const appDefinitionRes = await this.convertToAppDefinition(ctx, JSON.parse(manifestString), false);
            if (appDefinitionRes.isErr()) {
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            appDefinition = appDefinitionRes.value;
        }
        else {
            const remoteManifest = await this.getAppDefinitionAndManifest(ctx, false);
            if (remoteManifest.isErr()) {
                return teamsfx_api_1.err(remoteManifest.error);
            }
            [appDefinition] = remoteManifest.value;
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const result = await this.updateApp(ctx, appDefinition, appStudioToken, false, false, appDirectory, remoteTeamsAppId, ctx.logProvider);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`Teams app updated: ${result.value}`);
        return teamsfx_api_1.ok(remoteTeamsAppId);
    }
    async validateManifest(ctx, isLocalDebug) {
        var _a, _b;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        let manifestString = undefined;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const appDefinitionAndManifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (appDefinitionAndManifest.isErr()) {
                (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error("[Teams Toolkit] Manifest Validation failed!");
                return teamsfx_api_1.err(appDefinitionAndManifest.error);
            }
            else {
                manifestString = JSON.stringify(appDefinitionAndManifest.value[1]);
            }
        }
        const errors = await appStudio_1.AppStudioClient.validateManifest(manifestString, appStudioToken);
        const manifest = JSON.parse(manifestString);
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (manifest.icons.outline) {
            if (manifest.icons.outline.startsWith("https://") ||
                manifest.icons.outline.startsWith("http://")) {
                errors.push("icons.outline should be a relative path, URL is not supported");
            }
            else {
                const outlineFile = path_1.default.join(appDirectory, manifest.icons.outline);
                if (!(await fs.pathExists(outlineFile))) {
                    errors.push(`icons.outline "${outlineFile}" cannot be found.`);
                }
            }
        }
        if (manifest.icons.color) {
            if (manifest.icons.color.startsWith("https://") ||
                manifest.icons.color.startsWith("http://")) {
                errors.push("icons.color should be a relative path, URL is not supported");
            }
            else {
                const colorFile = path_1.default.join(appDirectory, manifest.icons.color);
                if (!(await fs.pathExists(colorFile))) {
                    errors.push(`icons.color "${colorFile}" cannot be found.`);
                }
            }
        }
        return teamsfx_api_1.ok(errors);
    }
    async updateManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const teamsAppId = await this.getTeamsAppId(ctx, isLocalDebug);
        let manifest;
        let manifestString;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        else {
            manifestString = JSON.stringify(manifestResult.value);
        }
        let appDefinition;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            manifest = JSON.parse(manifestString);
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, false);
            if (appDefinitionRes.isErr()) {
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            appDefinition = appDefinitionRes.value;
        }
        else {
            const appManifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (appManifest.isErr()) {
                (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error("[Teams Toolkit] Update manifest failed!");
                const isProvisionSucceeded = !!((_b = ctx.envInfo.state
                    .get("solution")) === null || _b === void 0 ? void 0 : _b.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (appManifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigError.name, errors_1.AppStudioError.GetRemoteConfigError.message("Update manifest failed"), constants_3.HelpLinks.WhyNeedProvision));
                }
                else {
                    return teamsfx_api_1.err(appManifest.error);
                }
            }
            [appDefinition] = appManifest.value;
            manifest = appManifest.value[1];
        }
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? "local" : ctx.envInfo.envName) +
            `.json`;
        if (!(await fs.pathExists(manifestFileName))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(manifestFileName) +
                " Run 'Provision in the cloud' first. Click Get Help to learn more about why you need to provision.", constants_3.HelpLinks.WhyNeedProvision));
        }
        const existingManifest = await fs.readJSON(manifestFileName);
        delete manifest.id;
        delete existingManifest.id;
        if (!lodash_1.default.isEqual(manifest, existingManifest)) {
            const res = await ((_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("warn", "The manifest file configurations has been modified already. Do you want to continue to regenerate the manifest file and update to Teams platform?", true, "Preview only", "Preview and update"));
            const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview only") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
                return teamsfx_api_1.err(error);
            }
            else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview and update") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        const appStudioToken = await ((_d = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _d === void 0 ? void 0 : _d.getAccessToken());
        try {
            const localUpdateTime = isLocalDebug
                ? undefined
                : (_e = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _e === void 0 ? void 0 : _e.get(constants_2.Constants.TEAMS_APP_UPDATED_AT);
            if (localUpdateTime) {
                const app = await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
                const devPortalUpdateTime = (_g = (_f = new Date(app.updatedAt)) === null || _f === void 0 ? void 0 : _f.getTime()) !== null && _g !== void 0 ? _g : -1;
                if (localUpdateTime < devPortalUpdateTime) {
                    const res = await ((_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("warn", "The manifest file on Teams platform has been changed since your last update. Do you want to continue to update and overwrite the manifest file on Teams platform?", true, "Overwrite and update"));
                    if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Overwrite and update")) {
                        const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
                        return teamsfx_api_1.err(error);
                    }
                }
            }
            const appDirectory = await common_1.getAppDirectory(ctx.root);
            const result = await this.updateApp(ctx, appDefinition, appStudioToken, isLocalDebug, false, appDirectory, teamsAppId, ctx.logProvider);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            (_j = ctx.logProvider) === null || _j === void 0 ? void 0 : _j.info(`Teams app updated: ${result.value}`);
            (_k = ctx.ui) === null || _k === void 0 ? void 0 : _k.showMessage("info", `Successfully updated manifest for [${manifest.name.short}]`, false);
            return teamsfx_api_1.ok(teamsAppId);
        }
        catch (error) {
            if (error.message && error.message.includes("404")) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
    }
    async migrateV1Project(ctx) {
        var _a, _b, _c;
        let manifest;
        const archiveAppPackageFolder = path_1.default.join(ctx.root, teamsfx_api_1.ArchiveFolderName, teamsfx_api_1.AppPackageFolderName);
        const archiveManifestPath = path_1.default.join(archiveAppPackageFolder, teamsfx_api_1.V1ManifestFileName);
        // cannot use getAppDirectory before creating the manifest file
        const newAppPackageFolder = `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}`;
        await fs.ensureDir(newAppPackageFolder);
        if (await fs.pathExists(archiveManifestPath)) {
            manifest = await this.createV1Manifest(ctx);
            const resourcesDir = path_1.default.join(newAppPackageFolder, constants_2.MANIFEST_RESOURCES);
            await fs.ensureDir(resourcesDir);
            if (((_a = manifest === null || manifest === void 0 ? void 0 : manifest.icons) === null || _a === void 0 ? void 0 : _a.color) && !manifest.icons.color.startsWith("https://")) {
                const archiveColorFile = path_1.default.join(archiveAppPackageFolder, manifest.icons.color);
                const existColorFile = await fs.pathExists(archiveColorFile);
                const newColorFileName = existColorFile
                    ? path_1.default.basename(manifest.icons.color)
                    : constants_2.DEFAULT_COLOR_PNG_FILENAME;
                await fs.copyFile(existColorFile ? archiveColorFile : path_1.default.join(__1.getTemplatesFolder(), constants_2.COLOR_TEMPLATE), path_1.default.join(resourcesDir, newColorFileName));
                manifest.icons.color = `${constants_2.MANIFEST_RESOURCES}/${newColorFileName}`;
            }
            if (((_b = manifest === null || manifest === void 0 ? void 0 : manifest.icons) === null || _b === void 0 ? void 0 : _b.outline) && !manifest.icons.outline.startsWith("https://")) {
                const archiveOutlineFile = path_1.default.join(archiveAppPackageFolder, manifest.icons.outline);
                const existOutlineFile = await fs.pathExists(archiveOutlineFile);
                const newOutlineFileName = existOutlineFile
                    ? path_1.default.basename(manifest.icons.outline)
                    : constants_2.DEFAULT_OUTLINE_PNG_FILENAME;
                await fs.copyFile(existOutlineFile ? archiveOutlineFile : path_1.default.join(__1.getTemplatesFolder(), constants_2.OUTLINE_TEMPLATE), path_1.default.join(resourcesDir, newOutlineFileName));
                manifest.icons.outline = `${constants_2.MANIFEST_RESOURCES}/${newOutlineFileName}`;
            }
            await fs.writeFile(path_1.default.join(newAppPackageFolder, constants_2.MANIFEST_LOCAL), JSON.stringify(manifest, null, 4));
            return { enableAuth: !!((_c = manifest === null || manifest === void 0 ? void 0 : manifest.webApplicationInfo) === null || _c === void 0 ? void 0 : _c.id) };
        }
        else {
            await this.scaffold(ctx);
            return { enableAuth: false };
        }
    }
    async scaffold(ctx) {
        var _a;
        let manifest;
        const templatesFolder = __1.getTemplatesFolder();
        // cannot use getAppDirectory before creating the manifest file
        const appDir = `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}`;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const templateManifestFolder = path_1.default.join(templatesFolder, "plugins", "resource", "spfx");
            const manifestFile = path_1.default.resolve(templateManifestFolder, "./solution/manifest_multi_env.json");
            const manifestString = (await fs.readFile(manifestFile)).toString();
            manifest = JSON.parse(manifestString);
            const localManifest = await createLocalManifest(ctx.projectSettings.appName, false, false, false, true, false);
            await fs.writeFile(`${appDir}/${constants_2.MANIFEST_LOCAL}`, JSON.stringify(localManifest, null, 4));
        }
        else {
            const solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
            const hasFrontend = solutionSettings.capabilities.includes(question_1.TabOptionItem.id);
            const hasBot = solutionSettings.capabilities.includes(question_1.BotOptionItem.id);
            const hasMessageExtension = solutionSettings.capabilities.includes(question_1.MessageExtensionItem.id);
            manifest = await createManifest(ctx.projectSettings.appName, hasFrontend, hasBot, hasMessageExtension, false, !!(solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.migrateFromV1));
            const localDebugManifest = await createLocalManifest(ctx.projectSettings.appName, hasFrontend, hasBot, hasMessageExtension, false, !!(solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.migrateFromV1));
            await fs.writeFile(`${appDir}/${constants_2.MANIFEST_LOCAL}`, JSON.stringify(localDebugManifest, null, 4));
        }
        await fs.ensureDir(appDir);
        const manifestTemplatePath = `${appDir}/${constants_2.MANIFEST_TEMPLATE}`;
        await fs.writeFile(manifestTemplatePath, JSON.stringify(manifest, null, 4));
        const defaultColorPath = path_1.default.join(templatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path_1.default.join(templatesFolder, constants_2.OUTLINE_TEMPLATE);
        const resourcesDir = path_1.default.join(appDir, constants_2.MANIFEST_RESOURCES);
        await fs.ensureDir(resourcesDir);
        await fs.copy(defaultColorPath, `${resourcesDir}/${constants_2.DEFAULT_COLOR_PNG_FILENAME}`);
        await fs.copy(defaultOutlinePath, `${resourcesDir}/${constants_2.DEFAULT_OUTLINE_PNG_FILENAME}`);
        return undefined;
    }
    async buildTeamsAppPackage(ctx, isLocalDebug) {
        var _a, _b, _c;
        // Validate manifest
        const validationResult = await this.validateManifest(ctx, isLocalDebug);
        if (validationResult.isOk() && validationResult.value.length > 0) {
            const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
            const validationFailed = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
            throw validationFailed;
        }
        let manifestString = undefined;
        if (!((_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.envName)) {
            throw new Error("Failed to get target environment name from plugin context.");
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        let zipFileName;
        if (isLocalDebug) {
            zipFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/appPackage.local.zip`;
        }
        else {
            zipFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/appPackage.${ctx.envInfo.envName}.zip`;
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const manifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (manifest.isOk()) {
                manifestString = JSON.stringify(manifest.value[1], null, 4);
            }
            else {
                (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error("[Teams Toolkit] Teams Package build failed!");
                const isProvisionSucceeded = !!((_c = ctx.envInfo.state
                    .get("solution")) === null || _c === void 0 ? void 0 : _c.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (manifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigError.name, errors_1.AppStudioError.GetRemoteConfigError.message("Teams package build failed"), constants_3.HelpLinks.WhyNeedProvision);
                }
                else {
                    throw manifest.error;
                }
            }
        }
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(manifestString));
        const manifest = JSON.parse(manifestString);
        // color icon
        if (manifest.icons.color && !manifest.icons.color.startsWith("https://")) {
            const colorFile = `${appDirectory}/${manifest.icons.color}`;
            const fileExists = await fs.pathExists(colorFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
            }
            const dir = path_1.default.dirname(manifest.icons.color);
            zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        }
        // outline icon
        if (manifest.icons.outline && !manifest.icons.outline.startsWith("https://")) {
            const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
            const fileExists = await fs.pathExists(outlineFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
            }
            const dir = path_1.default.dirname(manifest.icons.outline);
            zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        }
        await fs.ensureDir(path_1.default.dirname(zipFileName));
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? "local" : ctx.envInfo.envName) +
            `.json`;
        if (await fs.pathExists(manifestFileName)) {
            await fs.chmod(manifestFileName, 0o777);
        }
        await fs.writeFile(manifestFileName, manifestString);
        await fs.chmod(manifestFileName, 0o444);
        // localization file
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            await Promise.all(manifest.localizationInfo.additionalLanguages.map(async function (language) {
                const file = language.file;
                const fileName = `${appDirectory}/${file}`;
                if (!(await fs.pathExists(fileName))) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
                }
                const dir = path_1.default.dirname(file);
                zip.addLocalFile(fileName, dir === "." ? "" : dir);
            }));
        }
        zip.writeZip(zipFileName);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            await fs.copyFile(zipFileName, `${ctx.root}/SPFx/teams/TeamsSPFxApp.zip`);
        }
        if (appDirectory === `${ctx.root}/.${teamsfx_api_1.ConfigFolderName}`) {
            await fs.ensureDir(path_1.default.join(ctx.root, `${teamsfx_api_1.AppPackageFolderName}`));
            const formerZipFileName = `${appDirectory}/appPackage.zip`;
            if (await fs.pathExists(formerZipFileName)) {
                await fs.remove(formerZipFileName);
            }
            await fs.move(`${appDirectory}/${manifest.icons.color}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_RESOURCES}/${manifest.icons.color}`);
            await fs.move(`${appDirectory}/${manifest.icons.outline}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_RESOURCES}/${manifest.icons.outline}`);
            await fs.move(`${appDirectory}/${constants_2.REMOTE_MANIFEST}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_TEMPLATE}`);
        }
        return zipFileName;
    }
    async publish(ctx) {
        var _a, _b, _c;
        let manifest;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const manifestString = await this.getSPFxManifest(ctx, false);
            manifest = JSON.parse(manifestString);
        }
        else {
            const fillinRes = await this.getAppDefinitionAndManifest(ctx, false);
            if (fillinRes.isOk()) {
                manifest = fillinRes.value[1];
            }
            else {
                throw fillinRes.error;
            }
        }
        if (!manifest) {
            throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(""));
        }
        // manifest.id === externalID
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioToken);
        if (existApp) {
            let executePublishUpdate = false;
            let description = `The app ${existApp.displayName} has already been submitted to tenant App Catalog.\nStatus: ${existApp.publishingState}\n`;
            if (existApp.lastModifiedDateTime) {
                description =
                    description + `Last Modified: ${(_b = existApp.lastModifiedDateTime) === null || _b === void 0 ? void 0 : _b.toLocaleString()}\n`;
            }
            description = description + "Do you want to submit a new update?";
            const res = await ((_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("warn", description, true, "Confirm"));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
                executePublishUpdate = true;
            if (executePublishUpdate) {
                const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), true);
                return { id: appId, name: manifest.name.short, update: true };
            }
            else {
                throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
            }
        }
        else {
            const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), false);
            return { id: appId, name: manifest.name.short, update: false };
        }
    }
    async postLocalDebug(ctx) {
        var _a, _b;
        let teamsAppId;
        const manifest = await manifestTemplate_1.loadManifest(ctx.root, true);
        if (manifest.isErr()) {
            return teamsfx_api_1.err(manifest.error);
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            teamsAppId = await this.getSPFxLocalDebugAppDefinitionAndUpdate(ctx, manifest.value);
        }
        else {
            teamsAppId = await this.getAppDefinitionAndUpdate(ctx, true, manifest.value);
        }
        if (teamsAppId.isErr()) {
            return teamsAppId;
        }
        (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.set(constants_2.Constants.TEAMS_APP_ID, teamsAppId.value);
        return teamsfx_api_1.ok(teamsAppId.value);
    }
    async checkPermission(ctx, userInfo) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        const teamsAppRoles = await appStudio_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId);
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [teamsAppRoles],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async listCollaborator(ctx) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        let userLists;
        try {
            userLists = await appStudio_1.AppStudioClient.getUserList(teamsAppId, appStudioToken);
            if (!userLists) {
                return [];
            }
        }
        catch (error) {
            if (error.name === 404) {
                error.message = constants_2.ErrorMessages.TeamsAppNotFound(teamsAppId);
            }
            throw error;
        }
        const teamsAppAdmin = userLists
            .filter((userList, index) => {
            return userList.isAdministrator;
        })
            .map((userList, index) => {
            return {
                userObjectId: userList.aadId,
                displayName: userList.displayName,
                userPrincipalName: userList.userPrincipalName,
                resourceId: teamsAppId,
            };
        });
        return teamsAppAdmin;
    }
    async grantPermission(ctx, userInfo) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            throw new Error(errors_1.AppStudioError.GrantPermissionFailedError.message(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST)));
        }
        try {
            await appStudio_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo);
        }
        catch (error) {
            throw new Error(errors_1.AppStudioError.GrantPermissionFailedError.message(error === null || error === void 0 ? void 0 : error.message, teamsAppId));
        }
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [constants_2.Constants.PERMISSIONS.admin],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async beforePublish(ctx, appDirectory, manifestString, update) {
        var _a, _b, _c, _d, _e;
        const manifest = JSON.parse(manifestString);
        const publishProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(`Publishing ${manifest.name.short}`, 3);
        try {
            // Validate manifest
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.start("Validating manifest file"));
            const validationResult = await appStudio_1.AppStudioClient.validateManifest(manifestString, (await ((_b = ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken())));
            if (validationResult.length > 0) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message(validationResult));
            }
            // Update App in App Studio
            const remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(`Updating app definition for app ${remoteTeamsAppId} in app studio`));
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, true);
            if (appDefinitionRes.isErr()) {
                throw appDefinitionRes.error;
            }
            let appStudioToken = await ((_c = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _c === void 0 ? void 0 : _c.getAccessToken());
            const colorIconContent = manifest.icons.color
                ? (await fs.readFile(`${appDirectory}/${manifest.icons.color}`)).toString("base64")
                : undefined;
            const outlineIconContent = manifest.icons.outline
                ? (await fs.readFile(`${appDirectory}/${manifest.icons.outline}`)).toString("base64")
                : undefined;
            try {
                const app = await appStudio_1.AppStudioClient.updateApp(remoteTeamsAppId, appDefinitionRes.value, appStudioToken, undefined, colorIconContent, outlineIconContent);
                if (app.updatedAt) {
                    (_d = ctx.envInfo.state
                        .get(constants_1.PluginNames.APPST)) === null || _d === void 0 ? void 0 : _d.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, new Date(app.updatedAt).getTime());
                }
            }
            catch (e) {
                if (e.name === 404) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppNotFoundError.name, errors_1.AppStudioError.TeamsAppNotFoundError.message(remoteTeamsAppId));
                }
            }
            // Build Teams App package
            // Platforms will be checked in buildTeamsAppPackage(ctx)
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(`Building Teams app package in ${appDirectory}.`));
            const appPackage = await this.buildTeamsAppPackage(ctx, false);
            const appContent = await fs.readFile(appPackage);
            appStudioToken = await ((_e = ctx.appStudioToken) === null || _e === void 0 ? void 0 : _e.getAccessToken());
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(`Publishing ${manifest.name.short}`));
            if (update) {
                // Update existing app in App Catalog
                return await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, appContent, appStudioToken);
            }
            else {
                // Publish Teams App
                return await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, appContent, appStudioToken);
            }
        }
        finally {
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.end(true));
        }
    }
    replaceExistingValueToPlaceholder(config, value, placeholderName) {
        if (config && value && placeholderName) {
            config = config.split(value).join(placeholderName);
        }
        return config;
    }
    convertToAppDefinitionMessagingExtensions(appManifest) {
        const messagingExtensions = [];
        if (appManifest.composeExtensions) {
            appManifest.composeExtensions.forEach((ext) => {
                var _a;
                const me = {
                    botId: ext.botId,
                    canUpdateConfiguration: true,
                    commands: ext.commands,
                    messageHandlers: (_a = ext.messageHandlers) !== null && _a !== void 0 ? _a : [],
                };
                messagingExtensions.push(me);
            });
        }
        return messagingExtensions;
    }
    convertToAppDefinitionBots(appManifest) {
        const bots = [];
        if (appManifest.bots) {
            appManifest.bots.forEach((manBot) => {
                var _a, _b, _c;
                const teamCommands = [];
                const groupCommands = [];
                const personalCommands = [];
                (_a = manBot === null || manBot === void 0 ? void 0 : manBot.commandLists) === null || _a === void 0 ? void 0 : _a.forEach((list) => {
                    list.commands.forEach((command) => {
                        teamCommands.push({
                            title: command.title,
                            description: command.description,
                        });
                        groupCommands.push({
                            title: command.title,
                            description: command.description,
                        });
                        personalCommands.push({
                            title: command.title,
                            description: command.description,
                        });
                    });
                });
                const bot = {
                    botId: manBot.botId,
                    isNotificationOnly: (_b = manBot.isNotificationOnly) !== null && _b !== void 0 ? _b : false,
                    supportsFiles: (_c = manBot.supportsFiles) !== null && _c !== void 0 ? _c : false,
                    scopes: manBot.scopes,
                    teamCommands: teamCommands,
                    groupChatCommands: groupCommands,
                    personalCommands: personalCommands,
                };
                bots.push(bot);
            });
        }
        return bots;
    }
    async reloadManifest(manifestPath) {
        try {
            const manifest = await fs.readJson(manifestPath);
            if (!manifest) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file`)));
            }
            // Object.assign(ctx.app, manifest);
            return teamsfx_api_1.ok(manifest);
        }
        catch (e) {
            if (e.stack && e.stack.startsWith("SyntaxError")) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestPath}, due to ${e.message}`)));
            }
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestPath}, due to ${e.message}`)));
        }
    }
    async getConfigForCreatingManifest(ctx, localDebug) {
        const tabEndpoint = this.getTabEndpoint(ctx, localDebug);
        const tabDomain = this.getTabDomain(ctx, localDebug);
        const aadId = this.getAadClientId(ctx, localDebug);
        const botId = this.getBotId(ctx, localDebug);
        const botDomain = this.getBotDomain(ctx, localDebug);
        const teamsAppId = await this.getTeamsAppId(ctx, localDebug);
        // This config value is set by aadPlugin.setApplicationInContext. so aadPlugin.setApplicationInContext needs to run first.
        const webApplicationInfoResource = this.getApplicationIdUris(ctx, localDebug);
        return {
            tabEndpoint,
            tabDomain,
            aadId,
            botDomain,
            botId,
            webApplicationInfoResource,
            teamsAppId,
        };
    }
    getTabEndpoint(ctx, isLocalDebug) {
        var _a, _b, _c;
        const tabEndpoint = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.frontend) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsFrontendKeys.TabEndpoint)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_ENDPOINT);
        return tabEndpoint;
    }
    getTabDomain(ctx, isLocalDebug) {
        var _a, _b, _c;
        const tabDomain = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.frontend) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsFrontendKeys.TabDomain)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_DOMAIN);
        return tabDomain;
    }
    getAadClientId(ctx, isLocalDebug) {
        var _a, _b, _c;
        const clientId = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.AAD)) === null || _c === void 0 ? void 0 : _c.get(constants_1.REMOTE_AAD_ID);
        return clientId;
    }
    getBotId(ctx, isLocalDebug) {
        var _a, _b, _c;
        const botId = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.bot) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _c === void 0 ? void 0 : _c.get(constants_2.BOT_ID);
        return botId;
    }
    getBotDomain(ctx, isLocalDebug) {
        var _a, _b, _c;
        const botDomain = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.bot) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsBotKeys.BotDomain)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _c === void 0 ? void 0 : _c.get(constants_1.BOT_DOMAIN);
        return botDomain;
    }
    getApplicationIdUris(ctx, isLocalDebug) {
        var _a, _b, _c;
        const applicationIdUris = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.AAD)) === null || _c === void 0 ? void 0 : _c.get(constants_1.WEB_APPLICATION_INFO_SOURCE);
        return applicationIdUris;
    }
    async getTeamsAppId(ctx, isLocalDebug) {
        var _a, _b, _c;
        let teamsAppId = "";
        // User may manually update id in manifest template file, rather than configuration file
        // The id in manifest template file should override configurations
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isOk()) {
            teamsAppId = manifestResult.value.id;
        }
        if (!isUUID_1.default(teamsAppId)) {
            teamsAppId = isLocalDebug
                ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId)
                : (_c = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _c === void 0 ? void 0 : _c.get(constants_2.Constants.TEAMS_APP_ID);
        }
        return teamsAppId;
    }
    /**
     *
     * Refer to AppDefinitionProfile.cs
     */
    async convertToAppDefinition(ctx, appManifest, ignoreIcon) {
        const appDefinition = {
            appName: appManifest.name.short,
            validDomains: appManifest.validDomains,
        };
        appDefinition.showLoadingIndicator = appManifest.showLoadingIndicator;
        appDefinition.isFullScreen = appManifest.isFullScreen;
        appDefinition.appId = appManifest.id;
        appDefinition.appName = appManifest.name.short;
        appDefinition.shortName = appManifest.name.short;
        appDefinition.longName = appManifest.name.full;
        appDefinition.manifestVersion = appManifest.manifestVersion;
        appDefinition.version = appManifest.version;
        appDefinition.packageName = appManifest.packageName;
        appDefinition.accentColor = appManifest.accentColor;
        appDefinition.developerName = appManifest.developer.name;
        appDefinition.mpnId = appManifest.developer.mpnId;
        appDefinition.websiteUrl = appManifest.developer.websiteUrl;
        appDefinition.privacyUrl = appManifest.developer.privacyUrl;
        appDefinition.termsOfUseUrl = appManifest.developer.termsOfUseUrl;
        appDefinition.shortDescription = appManifest.description.short;
        appDefinition.longDescription = appManifest.description.full;
        appDefinition.staticTabs = appManifest.staticTabs;
        appDefinition.configurableTabs = appManifest.configurableTabs;
        appDefinition.bots = this.convertToAppDefinitionBots(appManifest);
        appDefinition.messagingExtensions = this.convertToAppDefinitionMessagingExtensions(appManifest);
        appDefinition.connectors = appManifest.connectors;
        appDefinition.devicePermissions = appManifest.devicePermissions;
        if (appManifest.localizationInfo) {
            let languages = [];
            if (appManifest.localizationInfo.additionalLanguages) {
                try {
                    languages = await Promise.all(appManifest.localizationInfo.additionalLanguages.map(async function (item) {
                        const templateDirectory = await common_1.getAppDirectory(ctx.root);
                        const fileName = `${templateDirectory}/${item.file}`;
                        if (!(await fs.pathExists(fileName))) {
                            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
                        }
                        const content = await fs.readJSON(fileName);
                        return {
                            languageTag: item.languageTag,
                            file: content,
                        };
                    }));
                }
                catch (error) {
                    return teamsfx_api_1.err(error);
                }
            }
            appDefinition.localizationInfo = {
                defaultLanguageTag: appManifest.localizationInfo.defaultLanguageTag,
                languages: languages,
            };
        }
        if (appManifest.webApplicationInfo) {
            appDefinition.webApplicationInfoId = appManifest.webApplicationInfo.id;
            appDefinition.webApplicationInfoResource = appManifest.webApplicationInfo.resource;
        }
        appDefinition.activities = appManifest.activities;
        if (!ignoreIcon && appManifest.icons.color) {
            appDefinition.colorIcon = appManifest.icons.color;
        }
        if (!ignoreIcon && appManifest.icons.outline) {
            appDefinition.outlineIcon = appManifest.icons.outline;
        }
        return teamsfx_api_1.ok(appDefinition);
    }
    async createApp(ctx, isLocalDebug) {
        var _a;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        const manifest = manifestResult.value;
        manifest.bots = undefined;
        manifest.composeExtensions = undefined;
        if (isLocalDebug || !isUUID_1.default(manifest.id)) {
            manifest.id = uuid_1.v4();
        }
        const colorFile = `${appDirectory}/${manifest.icons.color}`;
        if (!(await fs.pathExists(colorFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
        }
        const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
        if (!(await fs.pathExists(outlineFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest)));
        zip.addLocalFile(colorFile);
        zip.addLocalFile(outlineFile);
        const archivedFile = zip.toBuffer();
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        try {
            const appDefinition = await appStudio_1.AppStudioClient.createApp(archivedFile, appStudioToken, ctx.logProvider);
            return teamsfx_api_1.ok(appDefinition);
        }
        catch (e) {
            return teamsfx_api_1.err(isLocalDebug
                ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdCreateFailedError.name, errors_1.AppStudioError.LocalAppIdCreateFailedError.message(e))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdCreateFailedError.name, errors_1.AppStudioError.RemoteAppIdCreateFailedError.message(e)));
        }
    }
    async updateApp(ctx, appDefinition, appStudioToken, isLocalDebug, createIfNotExist, appDirectory, teamsAppId, logProvider) {
        var _a;
        if (appStudioToken === undefined || appStudioToken.length === 0) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.AppStudioTokenGetFailedError.name, errors_1.AppStudioError.AppStudioTokenGetFailedError.message));
        }
        if (createIfNotExist) {
            const appDef = await this.createApp(ctx, isLocalDebug);
            if (appDef.isErr()) {
                return teamsfx_api_1.err(appDef.error);
            }
            if (!appDef.value.teamsAppId) {
                return teamsfx_api_1.err(isLocalDebug
                    ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdCreateFailedError.name, errors_1.AppStudioError.LocalAppIdCreateFailedError.message())
                    : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdCreateFailedError.name, errors_1.AppStudioError.RemoteAppIdCreateFailedError.message()));
            }
            teamsAppId = appDef.value.teamsAppId;
            appDefinition.outlineIcon = appDef.value.outlineIcon;
            appDefinition.colorIcon = appDef.value.colorIcon;
        }
        const colorIconContent = appDirectory && appDefinition.colorIcon && !appDefinition.colorIcon.startsWith("https://")
            ? (await fs.readFile(`${appDirectory}/${appDefinition.colorIcon}`)).toString("base64")
            : undefined;
        const outlineIconContent = appDirectory && appDefinition.outlineIcon && !appDefinition.outlineIcon.startsWith("https://")
            ? (await fs.readFile(`${appDirectory}/${appDefinition.outlineIcon}`)).toString("base64")
            : undefined;
        appDefinition.appId = teamsAppId;
        try {
            const app = await appStudio_1.AppStudioClient.updateApp(teamsAppId, appDefinition, appStudioToken, logProvider, colorIconContent, outlineIconContent);
            if (app.updatedAt && !isLocalDebug) {
                const time = new Date(app.updatedAt).getTime();
                (_a = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _a === void 0 ? void 0 : _a.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, time);
            }
            return teamsfx_api_1.ok(teamsAppId);
        }
        catch (e) {
            if (e instanceof Error) {
                return teamsfx_api_1.err(isLocalDebug
                    ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdUpdateFailedError.name, errors_1.AppStudioError.LocalAppIdUpdateFailedError.message(e))
                    : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdUpdateFailedError.name, errors_1.AppStudioError.RemoteAppIdUpdateFailedError.message(e)));
            }
            throw e;
        }
    }
    async getAppDefinitionAndManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const { tabEndpoint, tabDomain, aadId, botDomain, botId, webApplicationInfoResource, teamsAppId, } = await this.getConfigForCreatingManifest(ctx, isLocalDebug);
        const isProvisionSucceeded = !!((_a = ctx.envInfo.state
            .get("solution")) === null || _a === void 0 ? void 0 : _a.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
        const validDomains = [];
        if (tabDomain) {
            validDomains.push(tabDomain);
        }
        if (botId) {
            if (!botDomain) {
                if (isLocalDebug) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(`Data required: ${constants_1.LOCAL_DEBUG_BOT_DOMAIN}`))));
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(new Error(`Data required: ${constants_1.BOT_DOMAIN}`), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
            }
            else {
                validDomains.push(botDomain);
            }
        }
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        let manifestString = JSON.stringify(manifestResult.value);
        // Bot only project, without frontend hosting
        let endpoint = tabEndpoint;
        const solutionSettings = (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.solutionSettings;
        const hasFrontend = solutionSettings.capabilities.includes(question_1.TabOptionItem.id);
        if (!endpoint && !hasFrontend) {
            endpoint = constants_2.DEFAULT_DEVELOPER_WEBSITE_URL;
        }
        const customizedKeys = utils_1.getCustomizedKeys("", JSON.parse(manifestString));
        this.commonProperties = {
            [telemetry_1.TelemetryPropertyKey.customizedKeys]: JSON.stringify(customizedKeys),
        };
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-frontend-hosting": {
                    endpoint: endpoint !== null && endpoint !== void 0 ? endpoint : "{{{state.fx-resource-frontend-hosting.endpoint}}}",
                },
                "fx-resource-aad-app-for-teams": {
                    clientId: aadId !== null && aadId !== void 0 ? aadId : "{{state.fx-resource-aad-app-for-teams.clientId}}",
                    applicationIdUris: webApplicationInfoResource !== null && webApplicationInfoResource !== void 0 ? webApplicationInfoResource : "{{{state.fx-resource-aad-app-for-teams.applicationIdUris}}}",
                },
                "fx-resource-appstudio": {
                    teamsAppId: teamsAppId !== null && teamsAppId !== void 0 ? teamsAppId : "{{state.fx-resource-appstudio.teamsAppId}}",
                },
                "fx-resource-bot": {
                    botId: botId !== null && botId !== void 0 ? botId : "{{state.fx-resource-bot.botId}}",
                },
            },
            localSettings: {
                frontend: {
                    tabEndpoint: endpoint ? endpoint : "{{{localSettings.frontend.tabEndpoint}}}",
                },
                auth: {
                    clientId: ((_d = (_c = ctx.localSettings) === null || _c === void 0 ? void 0 : _c.auth) === null || _d === void 0 ? void 0 : _d.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId))
                        ? (_f = (_e = ctx.localSettings) === null || _e === void 0 ? void 0 : _e.auth) === null || _f === void 0 ? void 0 : _f.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId)
                        : "{{localSettings.auth.clientId}}",
                    applicationIdUris: ((_h = (_g = ctx.localSettings) === null || _g === void 0 ? void 0 : _g.auth) === null || _h === void 0 ? void 0 : _h.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris))
                        ? (_k = (_j = ctx.localSettings) === null || _j === void 0 ? void 0 : _j.auth) === null || _k === void 0 ? void 0 : _k.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris)
                        : "{{{localSettings.auth.applicationIdUris}}}",
                },
                teamsApp: {
                    teamsAppId: ((_m = (_l = ctx.localSettings) === null || _l === void 0 ? void 0 : _l.teamsApp) === null || _m === void 0 ? void 0 : _m.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId))
                        ? (_p = (_o = ctx.localSettings) === null || _o === void 0 ? void 0 : _o.teamsApp) === null || _p === void 0 ? void 0 : _p.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId)
                        : "{{localSettings.teamsApp.teamsAppId}}",
                },
                bot: {
                    botId: ((_r = (_q = ctx.localSettings) === null || _q === void 0 ? void 0 : _q.bot) === null || _r === void 0 ? void 0 : _r.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId))
                        ? (_t = (_s = ctx.localSettings) === null || _s === void 0 ? void 0 : _s.bot) === null || _t === void 0 ? void 0 : _t.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId)
                        : "{{localSettings.bot.botId}}",
                },
            },
        };
        manifestString = mustache_1.default.render(manifestString, view);
        const tokens = [
            ...new Set(mustache_1.default.parse(manifestString)
                .filter((x) => {
                return x[0] != "text" && x[1] != "localSettings.teamsApp.teamsAppId";
            })
                .map((x) => x[1])),
        ];
        if (tokens.length > 0) {
            if (isLocalDebug) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(`Data required: ${tokens.join(",")}`))));
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(new Error(`Data required: ${tokens.join(",")}`), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        let updatedManifest;
        try {
            updatedManifest = JSON.parse(manifestString);
        }
        catch (error) {
            if (error.stack && error.stack.startsWith("SyntaxError")) {
                // teams app id in userData may be updated by user, result to invalid manifest
                const reg = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
                const result = teamsAppId.match(reg);
                if (!result) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error, "teamsAppId"), undefined, error.stack));
                }
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error), undefined, error.stack));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        for (const domain of validDomains) {
            (_u = updatedManifest.validDomains) === null || _u === void 0 ? void 0 : _u.push(domain);
        }
        const appDefinitionRes = await this.convertToAppDefinition(ctx, updatedManifest, false);
        if (appDefinitionRes.isErr()) {
            return teamsfx_api_1.err(appDefinitionRes.error);
        }
        const appDefinition = appDefinitionRes.value;
        return teamsfx_api_1.ok([appDefinition, updatedManifest]);
    }
    async getSPFxManifest(ctx, isLocalDebug) {
        var _a, _b;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            throw manifestResult.error;
        }
        let manifestString = JSON.stringify(manifestResult.value);
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-appstudio": {
                    teamsAppId: await this.getTeamsAppId(ctx, isLocalDebug),
                },
            },
            localSettings: {
                teamsApp: {
                    teamsAppId: (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId),
                },
            },
        };
        manifestString = mustache_1.default.render(manifestString, view);
        return manifestString;
    }
}
exports.AppStudioPluginImpl = AppStudioPluginImpl;
async function createLocalManifest(appName, hasFrontend, hasBot, hasMessageExtension, isSPFx, migrateFromV1) {
    let name = appName;
    const suffix = "-local-debug";
    if (suffix.length + appName.length <= constants_2.TEAMS_APP_SHORT_NAME_MAX_LENGTH) {
        name = name + suffix;
    }
    if (isSPFx) {
        const templateManifestFolder = path_1.default.join(__1.getTemplatesFolder(), "plugins", "resource", "spfx");
        const localManifestFile = path_1.default.resolve(templateManifestFolder, `./solution/${constants_2.MANIFEST_LOCAL}`);
        let manifestString = (await fs.readFile(localManifestFile)).toString();
        manifestString = utils_1.replaceConfigValue(manifestString, "appName", name);
        const manifest = JSON.parse(manifestString);
        return manifest;
    }
    else {
        let manifestString = constants_2.TEAMS_APP_MANIFEST_TEMPLATE_LOCAL_DEBUG;
        manifestString = utils_1.replaceConfigValue(manifestString, "appName", name);
        const manifest = JSON.parse(manifestString);
        if (hasFrontend) {
            manifest.staticTabs = constants_2.STATIC_TABS_TPL_LOCAL_DEBUG;
            manifest.configurableTabs = constants_2.CONFIGURABLE_TABS_TPL_LOCAL_DEBUG;
        }
        if (hasBot) {
            manifest.bots = constants_2.BOTS_TPL_LOCAL_DEBUG;
        }
        if (hasMessageExtension) {
            manifest.composeExtensions = constants_2.COMPOSE_EXTENSIONS_TPL_LOCAL_DEBUG;
        }
        if (migrateFromV1) {
            manifest.webApplicationInfo = undefined;
        }
        return manifest;
    }
}
exports.createLocalManifest = createLocalManifest;
async function createManifest(appName, hasFrontend, hasBot, hasMessageExtension, isSPFx, migrateFromV1) {
    if (!hasBot && !hasMessageExtension && !hasFrontend) {
        throw new Error(`Invalid capability`);
    }
    if (!isSPFx || hasBot || hasMessageExtension) {
        const manifestString = constants_2.TEAMS_APP_MANIFEST_TEMPLATE_FOR_MULTI_ENV;
        const manifest = JSON.parse(manifestString);
        if (hasFrontend) {
            manifest.staticTabs = constants_2.STATIC_TABS_TPL_FOR_MULTI_ENV;
            manifest.configurableTabs = constants_2.CONFIGURABLE_TABS_TPL_FOR_MULTI_ENV;
        }
        if (hasBot) {
            manifest.bots = constants_2.BOTS_TPL_FOR_MULTI_ENV;
        }
        if (hasMessageExtension) {
            manifest.composeExtensions = constants_2.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV;
        }
        if (migrateFromV1) {
            manifest.webApplicationInfo = undefined;
        }
        return manifest;
    }
    return undefined;
}
exports.createManifest = createManifest;
//# sourceMappingURL=plugin.js.map