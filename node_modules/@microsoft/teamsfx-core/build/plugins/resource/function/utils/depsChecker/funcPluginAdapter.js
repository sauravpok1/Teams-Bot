"use strict";
/* eslint-disable @typescript-eslint/no-namespace */
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuncPluginAdapter = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const funcPluginLogger_1 = require("./funcPluginLogger");
const errors_1 = require("./errors");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const common_1 = require("./common");
const __1 = require("../../../../..");
class FuncPluginAdapter {
    constructor(ctx, telemetry) {
        this.downloadIndicatorInterval = 1000; // same as vscode-dotnet-runtime
        this.dotnetSettingKey = "function-dotnet-checker-enabled";
        this._ctx = ctx;
        this._telemetry = telemetry;
    }
    displayLearnMore(message, link) {
        // TODO: implement learn more popup in plugin
        return Promise.resolve(true);
    }
    async displayWarningMessage(message, buttonText, action) {
        return await action();
    }
    displayContinueWithLearnMore(message, link) {
        return Promise.resolve(true);
    }
    showOutputChannel() {
        // TODO: find a way to implement in plugin
    }
    getResourceDir() {
        return path.resolve(path.join(__1.getResourceFolder(), "plugins", "resource", "function"));
    }
    dotnetCheckerEnabled() {
        let enabled = true;
        if (this._ctx.answers && this._ctx.answers[this.dotnetSettingKey] !== undefined) {
            enabled = this._ctx.answers[this.dotnetSettingKey];
        }
        return Promise.resolve(enabled);
    }
    async runWithProgressIndicator(callback) {
        // NOTE: We cannot use outputChannel in plugin to print the dots in one line.
        let counter = 1;
        const timer = setInterval(() => {
            const dots = Array(counter).fill(".").join("");
            funcPluginLogger_1.funcPluginLogger.info(dots);
            counter += 1;
        }, this.downloadIndicatorInterval);
        try {
            await callback();
        }
        finally {
            clearTimeout(timer);
        }
    }
    hasTeamsfxBackend() {
        throw new Error("Method not implemented.");
    }
    hasTeamsfxBot() {
        throw new Error("Method not implemented.");
    }
    funcToolCheckerEnabled() {
        throw new Error("Method not implemented.");
    }
    ngrokCheckerEnabled() {
        throw new Error("Method not implemented.");
    }
    nodeCheckerEnabled() {
        throw new Error("Method not implemented.");
    }
    handleDotnetError(error) {
        const source = "functionDepsChecker";
        const defaultAnchor = "report-issues";
        if (error instanceof errors_1.DepsCheckerError) {
            const [helpLink, anchor] = this.splitHelpLink(error.helpLink);
            throw teamsfx_api_1.returnUserError(error, source, anchor || defaultAnchor, helpLink, error);
        }
        else {
            throw teamsfx_api_1.returnUserError(new Error(common_1.Messages.defaultErrorMessage), source, defaultAnchor, common_1.defaultHelpLink, error);
        }
    }
    async handleDotnetForLinux(checker) {
        const confirmMessage = await this.generateMsg(common_1.Messages.linuxDepsNotFound, [checker]);
        return this.displayLearnMore(confirmMessage, common_1.dotnetManualInstallHelpLink);
    }
    async generateMsg(messageTemplate, checkers) {
        const supportedPackages = [];
        for (const checker of checkers) {
            const info = await checker.getDepsInfo();
            const supportedVersions = info.supportedVersions.map((version) => "v" + version).join(" or ");
            const supportedPackage = `${info.name} (${supportedVersions})`;
            supportedPackages.push(supportedPackage);
        }
        const supportedMessage = supportedPackages.join(" and ");
        return messageTemplate.replace("@SupportedPackages", supportedMessage);
    }
    splitHelpLink(link) {
        const lastAnchor = link.lastIndexOf("#");
        if (lastAnchor !== -1) {
            return [link.slice(0, lastAnchor), link.slice(lastAnchor + 1)];
        }
        else {
            return [link, ""];
        }
    }
}
exports.FuncPluginAdapter = FuncPluginAdapter;
//# sourceMappingURL=funcPluginAdapter.js.map