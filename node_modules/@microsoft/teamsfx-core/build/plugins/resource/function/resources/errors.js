"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithErrorCatchAndWrap = exports.runWithErrorCatchAndThrow = exports.UnknownFallbackError = exports.UploadZipError = exports.FindAppError = exports.PublishCredentialError = exports.ZipError = exports.InitAzureSDKError = exports.InstallNpmPackageError = exports.InstallTeamsfxBindingError = exports.FunctionAppOpError = exports.ConfigFunctionAppError = exports.GetConnectionStringError = exports.ProvisionError = exports.RegisterResourceProviderError = exports.UnzipError = exports.TemplateZipFallbackError = exports.TemplateZipNetworkError = exports.TemplateManifestError = exports.ValidationError = exports.FetchConfigError = exports.FunctionNameConflictError = exports.FunctionPluginError = exports.ErrorType = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const path = tslib_1.__importStar(require("path"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
var ErrorType;
(function (ErrorType) {
    ErrorType[ErrorType["User"] = 0] = "User";
    ErrorType[ErrorType["System"] = 1] = "System";
})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
const tips = {
    recoverTeamsfxConfigFiles: `If you manually updated configuration files (under directory .${teamsfx_api_1.ConfigFolderName}), recover them.`,
    recreateProject: "If you can not recover configuration files, create a new project.",
    checkNetwork: "Check your network connection.",
    retryRequest: "Retry the command after network connection is restored.",
    chooseAnotherCompose: "Create a project with another template.",
    checkDiskLock: "Check log to see whether there is a file locked by some process.",
    checkPathAccess: "Check log to see whether target path exists and you have write access to it.",
    checkSubscriptionId: "Check whether you choose the correct Azure subscription.",
    checkCredit: "Check Azure subscription credit.",
    checkLog: "Read log for more information.",
    recreateStorageAccount: "Remove your Azure Storage account instance and re-run provision.",
    checkPackageJson: "Check that package.json is valid.",
    checkCredential: "Check that you have logged in to Azure with the correct account.",
    doFullDeploy: `Remove ${constants_1.FunctionPluginPathInfo.solutionFolderName}/${constants_1.FunctionPluginPathInfo.funcDeploymentFolderName}.`,
    doProvision: "Run 'Provision'.",
    retryRequestForZip: "If the template zip file was broken, retry the command to download a new one.",
    checkFunctionExtVersion: `Check function extension version and ${constants_1.FunctionPluginPathInfo.solutionFolderName}${path.sep}${constants_1.FunctionPluginPathInfo.functionExtensionsFileName}.`,
    registerRequiredRP: `Register ${constants_1.AzureInfo.requiredResourceProviders.join(",")} resource provider for your subscription manually.`,
};
class FunctionPluginError extends Error {
    constructor(errorType, code, message, suggestions) {
        super(message);
        this.code = code;
        this.message = message;
        this.suggestions = suggestions;
        this.errorType = errorType;
        Object.setPrototypeOf(this, ValidationError.prototype);
    }
    getMessage() {
        return `${this.message} Suggestions: ${this.suggestions.join(" ")}`;
    }
}
exports.FunctionPluginError = FunctionPluginError;
class FunctionNameConflictError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "FunctionNameConflictError", "Function already exists, please choose another name.", []);
    }
}
exports.FunctionNameConflictError = FunctionNameConflictError;
class FetchConfigError extends FunctionPluginError {
    constructor(key) {
        super(ErrorType.User, "FetchConfigError", `Failed to find ${key} from configuration.`, [
            tips.recoverTeamsfxConfigFiles,
            tips.recreateProject,
        ]);
    }
}
exports.FetchConfigError = FetchConfigError;
class ValidationError extends FunctionPluginError {
    constructor(key) {
        super(ErrorType.User, "ValidationError", `Invalid ${key}.`, [
            tips.recoverTeamsfxConfigFiles,
            tips.recreateProject,
        ]);
    }
}
exports.ValidationError = ValidationError;
class TemplateManifestError extends FunctionPluginError {
    constructor(msg) {
        super(ErrorType.User, "TemplateManifestError", `Failed to find template from manifest: ${msg}.`, [tips.checkNetwork, tips.retryRequest]);
    }
}
exports.TemplateManifestError = TemplateManifestError;
class TemplateZipNetworkError extends FunctionPluginError {
    constructor(url) {
        super(ErrorType.User, "TemplateZipNetworkError", `Failed to download zip package from ${url}.`, [tips.checkNetwork, tips.retryRequest]);
    }
}
exports.TemplateZipNetworkError = TemplateZipNetworkError;
class TemplateZipFallbackError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "TemplateZipFallbackError", "Failed to download zip package and open local zip package.", [tips.checkLog, tips.checkNetwork, tips.retryRequest]);
    }
}
exports.TemplateZipFallbackError = TemplateZipFallbackError;
class UnzipError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "UnzipError", "Failed to unzip templates and write to disk.", [
            tips.checkDiskLock,
            tips.checkPathAccess,
            tips.retryRequestForZip,
        ]);
    }
}
exports.UnzipError = UnzipError;
// TODO: help link for the error
class RegisterResourceProviderError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "RegisterResourceProviderError", "Failed to register required resource provider for function app.", [tips.registerRequiredRP, tips.checkLog]);
    }
}
exports.RegisterResourceProviderError = RegisterResourceProviderError;
class ProvisionError extends FunctionPluginError {
    constructor(resource, innerErrorCode) {
        super(ErrorType.User, "ProvisionError", `Failed to check/create '${resource}' for function app${innerErrorCode ? `: ${innerErrorCode}` : ""}.`, [tips.checkSubscriptionId, tips.checkCredit, tips.checkNetwork, tips.retryRequest]);
    }
}
exports.ProvisionError = ProvisionError;
class GetConnectionStringError extends FunctionPluginError {
    constructor() {
        super(ErrorType.System, "GetConnectionStringError", "Failed to get connection string of Azure Storage account.", [tips.recreateStorageAccount, tips.checkNetwork, tips.retryRequest]);
    }
}
exports.GetConnectionStringError = GetConnectionStringError;
class ConfigFunctionAppError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "ConfigFunctionAppError", "Failed to retrieve or update function app settings.", [tips.checkSubscriptionId, tips.checkNetwork, tips.retryRequest]);
    }
}
exports.ConfigFunctionAppError = ConfigFunctionAppError;
class FunctionAppOpError extends FunctionPluginError {
    constructor(op) {
        super(ErrorType.User, "RestartFunctionAppError", `Failed to execute '${op}' on the function app.`, [tips.checkNetwork, tips.retryRequest]);
    }
}
exports.FunctionAppOpError = FunctionAppOpError;
class InstallTeamsfxBindingError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "InstallTeamsfxBindingError", "Failed to install Azure Functions bindings.", [tips.checkFunctionExtVersion]);
    }
}
exports.InstallTeamsfxBindingError = InstallTeamsfxBindingError;
class InstallNpmPackageError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "InstallNpmPackageError", "Failed to install NPM packages.", [
            tips.checkPackageJson,
        ]);
    }
}
exports.InstallNpmPackageError = InstallNpmPackageError;
class InitAzureSDKError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "InitAzureSDKError", "Failed to initialize Azure SDK Client.", [
            tips.checkCredential,
            tips.checkSubscriptionId,
        ]);
    }
}
exports.InitAzureSDKError = InitAzureSDKError;
class ZipError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "ZipError", "Failed to generate zip package.", [
            tips.checkDiskLock,
            tips.checkPathAccess,
            tips.doFullDeploy,
        ]);
    }
}
exports.ZipError = ZipError;
class PublishCredentialError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "PublishCredentialError", "Failed to retrieve publish credential.", [
            tips.checkCredential,
            tips.checkSubscriptionId,
            tips.checkNetwork,
            tips.retryRequest,
            tips.doProvision,
        ]);
    }
}
exports.PublishCredentialError = PublishCredentialError;
class FindAppError extends FunctionPluginError {
    constructor() {
        super(ErrorType.System, "FindAppError", "Failed to find the function app.", [tips.doProvision]);
    }
}
exports.FindAppError = FindAppError;
class UploadZipError extends FunctionPluginError {
    constructor() {
        super(ErrorType.User, "UploadZipError", "Failed to upload zip package.", [
            tips.checkNetwork,
            tips.retryRequest,
        ]);
    }
}
exports.UploadZipError = UploadZipError;
class UnknownFallbackError extends FunctionPluginError {
    constructor() {
        super(ErrorType.System, "UnknownFallbackError", "Trigger fallback caused by unknown reason.", []);
    }
}
exports.UnknownFallbackError = UnknownFallbackError;
async function runWithErrorCatchAndThrow(error, fn) {
    try {
        const res = await Promise.resolve(fn());
        return res;
    }
    catch (e) {
        if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
            throw e;
        }
        logger_1.Logger.error(e.toString());
        throw error;
    }
}
exports.runWithErrorCatchAndThrow = runWithErrorCatchAndThrow;
async function runWithErrorCatchAndWrap(wrap, fn) {
    try {
        const res = await Promise.resolve(fn());
        return res;
    }
    catch (e) {
        if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
            throw e;
        }
        logger_1.Logger.error(e.toString());
        const error = wrap(e);
        throw error;
    }
}
exports.runWithErrorCatchAndWrap = runWithErrorCatchAndWrap;
//# sourceMappingURL=errors.js.map