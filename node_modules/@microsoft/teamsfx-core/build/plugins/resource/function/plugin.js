"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const path = tslib_1.__importStar(require("path"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const uuid_1 = require("uuid");
const azure_client_1 = require("./utils/azure-client");
const errors_1 = require("./resources/errors");
const constants_1 = require("./constants");
const message_1 = require("./resources/message");
const enums_1 = require("./enums");
const deploy_1 = require("./ops/deploy");
const provision_1 = require("./ops/provision");
const scaffold_1 = require("./ops/scaffold");
const result_1 = require("./result");
const logger_1 = require("./utils/logger");
const steps_1 = require("./resources/steps");
const dotnetChecker_1 = require("./utils/depsChecker/dotnetChecker");
const common_1 = require("./utils/depsChecker/common");
const errors_2 = require("./utils/depsChecker/errors");
const node_version_1 = require("./utils/node-version");
const funcPluginAdapter_1 = require("./utils/depsChecker/funcPluginAdapter");
const funcPluginLogger_1 = require("./utils/depsChecker/funcPluginLogger");
const funcPluginTelemetry_1 = require("./utils/depsChecker/funcPluginTelemetry");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const folder_1 = require("../../../folder");
const constants_2 = require("../../../common/constants");
const common_2 = require("../../../common");
const question_1 = require("./question");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../solution/fx-solution/v2/adaptor");
const tools_1 = require("../../../common/tools");
class FunctionPluginImpl {
    constructor() {
        this.config = {
            skipDeploy: false,
        };
    }
    async syncConfigFromContext(ctx) {
        var _a, _b;
        this.config.functionLanguage = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.programmingLanguage;
        this.config.defaultFunctionName = (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.defaultFunctionName;
        this.config.functionEndpoint = ctx.config.get(enums_1.FunctionConfigKey.functionEndpoint);
        if (common_2.isArmSupportEnabled()) {
            this.config.functionAppResourceId = ctx.config.get(enums_1.FunctionConfigKey.functionAppResourceId);
        }
        else {
            const solutionConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.solutionPluginName);
            this.config.resourceNameSuffix = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.resourceNameSuffix);
            this.config.resourceGroupName = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.resourceGroupName);
            this.config.subscriptionId = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.subscriptionId);
            this.config.location = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.location);
            this.config.functionAppName = ctx.config.get(enums_1.FunctionConfigKey.functionAppName);
            this.config.storageAccountName = ctx.config.get(enums_1.FunctionConfigKey.storageAccountName);
            this.config.appServicePlanName = ctx.config.get(enums_1.FunctionConfigKey.appServicePlanName);
        }
        /* Always validate after sync for safety and security. */
        this.validateConfig();
    }
    syncConfigToContext(ctx) {
        // sync plugin config to context
        Object.entries(this.config)
            .filter((kv) => constants_1.FunctionPluginInfo.FunctionPluginPersistentConfig.find((x) => x === kv[0]))
            .forEach((kv) => {
            if (kv[1]) {
                ctx.config.set(kv[0], kv[1].toString());
            }
        });
        // sync project settings to context
        if (this.config.defaultFunctionName) {
            ctx.projectSettings.defaultFunctionName = this.config.defaultFunctionName;
        }
    }
    validateConfig() {
        if (this.config.functionLanguage &&
            !Object.values(enums_1.FunctionLanguage).includes(this.config.functionLanguage)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.functionLanguage);
        }
        if (this.config.resourceNameSuffix &&
            !constants_1.RegularExpr.validResourceSuffixPattern.test(this.config.resourceNameSuffix)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.resourceNameSuffix);
        }
        if (this.config.functionAppName &&
            !constants_1.RegularExpr.validFunctionAppNamePattern.test(this.config.functionAppName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.functionAppName);
        }
        if (this.config.storageAccountName &&
            !constants_1.RegularExpr.validStorageAccountNamePattern.test(this.config.storageAccountName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.storageAccountName);
        }
        if (this.config.appServicePlanName &&
            !constants_1.RegularExpr.validAppServicePlanNamePattern.test(this.config.appServicePlanName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.appServicePlanName);
        }
        if (this.config.defaultFunctionName &&
            !constants_1.RegularExpr.validFunctionNamePattern.test(this.config.defaultFunctionName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.defaultFunctionName);
        }
    }
    async callFunc(func, ctx) {
        var _a, _b;
        if (func.method === constants_1.QuestionValidationFunc.validateFunctionName) {
            const workingPath = this.getFunctionProjectRootPath(ctx);
            const name = func.params;
            if (!name || !constants_1.RegularExpr.validFunctionNamePattern.test(name)) {
                return result_1.FunctionPluginResultFactory.Success(message_1.ErrorMessages.invalidFunctionName);
            }
            const stage = ctx.answers[enums_1.QuestionKey.stage];
            if (stage === teamsfx_api_1.Stage.create) {
                return result_1.FunctionPluginResultFactory.Success();
            }
            const language = (_a = ctx.answers[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.programmingLanguage;
            // If language is unknown, skip checking and let scaffold handle the error.
            if (language && (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
                return result_1.FunctionPluginResultFactory.Success(message_1.ErrorMessages.functionAlreadyExists);
            }
        }
        return result_1.FunctionPluginResultFactory.Success();
    }
    getQuestionsForUserTask(func, ctx) {
        const res = new teamsfx_api_1.QTreeNode({
            type: "group",
        });
        if (func.method === enums_1.CustomizedTask.addResource) {
            question_1.functionNameQuestion.validation = {
                validFunc: async (input, previousInputs) => {
                    var _a, _b;
                    const workingPath = this.getFunctionProjectRootPath(ctx);
                    const name = input;
                    if (!name || !constants_1.RegularExpr.validFunctionNamePattern.test(name)) {
                        return message_1.ErrorMessages.invalidFunctionName;
                    }
                    const stage = ctx.answers[enums_1.QuestionKey.stage];
                    if (stage === teamsfx_api_1.Stage.create) {
                        return undefined;
                    }
                    const language = (_a = ctx.answers[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.programmingLanguage;
                    // If language is unknown, skip checking and let scaffold handle the error.
                    if (language &&
                        (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
                        return message_1.ErrorMessages.functionAlreadyExists;
                    }
                },
            };
            res.addChild(new teamsfx_api_1.QTreeNode(question_1.functionNameQuestion));
        }
        return result_1.FunctionPluginResultFactory.Success(res);
    }
    async executeUserTask(func, ctx) {
        let result = result_1.FunctionPluginResultFactory.Success();
        if (func.method === enums_1.CustomizedTask.addResource) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.addResource);
            result = result.isErr() ? result : await this.preScaffold(ctx);
            result = result.isErr() ? result : await this.scaffold(ctx);
        }
        return result;
    }
    async preScaffold(ctx) {
        var _a;
        await this.syncConfigFromContext(ctx);
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const name = (_a = ctx.answers[enums_1.QuestionKey.functionName]) !== null && _a !== void 0 ? _a : constants_1.DefaultValues.functionName;
        if (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, functionLanguage, name)) {
            throw new errors_1.FunctionNameConflictError();
        }
        this.config.functionName = name;
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async scaffold(ctx) {
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionName = this.checkAndGet(this.config.functionName, enums_1.FunctionConfigKey.functionName);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        await scaffold_1.FunctionScaffold.scaffoldFunction(workingPath, functionLanguage, constants_1.DefaultValues.functionTriggerType, functionName, {
            appName: ctx.projectSettings.appName,
            functionName: functionName,
        });
        if (!this.config.defaultFunctionName) {
            this.config.defaultFunctionName = this.config.functionName;
        }
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async preProvision(ctx) {
        var _a;
        await this.syncConfigFromContext(ctx);
        if (!common_2.isArmSupportEnabled() &&
            (!this.config.functionAppName ||
                !this.config.storageAccountName ||
                !this.config.appServicePlanName)) {
            const teamsAppName = ctx.projectSettings.appName;
            const suffix = (_a = this.config.resourceNameSuffix) !== null && _a !== void 0 ? _a : uuid_1.v4().substr(0, 6);
            if (!this.config.functionAppName) {
                this.config.functionAppName = provision_1.FunctionNaming.generateFunctionAppName(teamsAppName, constants_1.DefaultProvisionConfigs.nameSuffix, suffix);
                logger_1.Logger.info(message_1.InfoMessages.generateFunctionAppName(this.config.functionAppName));
            }
            if (!this.config.storageAccountName) {
                this.config.storageAccountName = provision_1.FunctionNaming.generateStorageAccountName(teamsAppName, constants_1.DefaultProvisionConfigs.nameSuffix, suffix);
                logger_1.Logger.info(message_1.InfoMessages.generateStorageAccountName(this.config.storageAccountName));
            }
            if (!this.config.appServicePlanName) {
                this.config.appServicePlanName = this.config.functionAppName;
                logger_1.Logger.info(message_1.InfoMessages.generateAppServicePlanName(this.config.appServicePlanName));
            }
        }
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async getValidNodeVersion(ctx) {
        var _a;
        const currentNodeVersion = await node_version_1.getNodeVersion(this.getFunctionProjectRootPath(ctx));
        const candidateNodeVersions = Object.values(enums_1.NodeVersion);
        return ((_a = candidateNodeVersions.find((v) => v === currentNodeVersion)) !== null && _a !== void 0 ? _a : constants_1.DefaultValues.nodeVersion);
    }
    async provision(ctx) {
        var _a;
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const location = this.checkAndGet(this.config.location, enums_1.FunctionConfigKey.location);
        const appServicePlanName = this.checkAndGet(this.config.appServicePlanName, enums_1.FunctionConfigKey.appServicePlanName);
        const storageAccountName = this.checkAndGet(this.config.storageAccountName, enums_1.FunctionConfigKey.storageAccountName);
        const functionAppName = this.checkAndGet(this.config.functionAppName, enums_1.FunctionConfigKey.functionAppName);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enums_1.FunctionConfigKey.credential);
        const nodeVersion = await this.getValidNodeVersion(ctx);
        const providerClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getResourceProviderClient(credential, subscriptionId));
        logger_1.Logger.info(message_1.InfoMessages.ensureResourceProviders(constants_1.AzureInfo.requiredResourceProviders, subscriptionId));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.RegisterResourceProviderError(), async () => steps_1.step(steps_1.StepGroup.ProvisionStepGroup, steps_1.ProvisionSteps.registerResourceProviders, async () => await azure_client_1.AzureLib.ensureResourceProviders(providerClient, constants_1.AzureInfo.requiredResourceProviders)));
        const storageManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getStorageManagementClient(credential, subscriptionId));
        logger_1.Logger.info(message_1.InfoMessages.checkResource(enums_1.ResourceType.storageAccount, storageAccountName, resourceGroupName));
        await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.ProvisionError(enums_1.ResourceType.storageAccount, error.code), async () => steps_1.step(steps_1.StepGroup.ProvisionStepGroup, steps_1.ProvisionSteps.ensureStorageAccount, async () => await azure_client_1.AzureLib.ensureStorageAccount(storageManagementClient, resourceGroupName, storageAccountName, constants_1.DefaultProvisionConfigs.storageConfig(location))));
        const storageConnectionString = await errors_1.runWithErrorCatchAndThrow(new errors_1.GetConnectionStringError(), async () => await steps_1.step(steps_1.StepGroup.ProvisionStepGroup, steps_1.ProvisionSteps.getConnectionString, async () => azure_client_1.AzureLib.getConnectionString(storageManagementClient, resourceGroupName, storageAccountName)));
        if (!storageConnectionString) {
            logger_1.Logger.error(message_1.ErrorMessages.failToGetConnectionString);
            throw new errors_1.GetConnectionStringError();
        }
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        logger_1.Logger.info(message_1.InfoMessages.checkResource(enums_1.ResourceType.appServicePlan, appServicePlanName, resourceGroupName));
        const appServicePlan = await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.ProvisionError(enums_1.ResourceType.appServicePlan, error.code), async () => await steps_1.step(steps_1.StepGroup.ProvisionStepGroup, steps_1.ProvisionSteps.ensureAppServicePlans, async () => azure_client_1.AzureLib.ensureAppServicePlans(webSiteManagementClient, resourceGroupName, appServicePlanName, constants_1.DefaultProvisionConfigs.appServicePlansConfig(location))));
        const appServicePlanId = appServicePlan.id;
        if (!appServicePlanId) {
            logger_1.Logger.error(message_1.ErrorMessages.failToGetAppServicePlanId);
            throw new errors_1.ProvisionError(enums_1.ResourceType.appServicePlan);
        }
        logger_1.Logger.info(message_1.InfoMessages.checkResource(enums_1.ResourceType.functionApp, appServicePlanName, resourceGroupName));
        const site = await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.ProvisionError(enums_1.ResourceType.functionApp, error.code), async () => await steps_1.step(steps_1.StepGroup.ProvisionStepGroup, steps_1.ProvisionSteps.ensureFunctionApp, async () => provision_1.FunctionProvision.ensureFunctionApp(webSiteManagementClient, resourceGroupName, location, functionAppName, functionLanguage, appServicePlanId, storageConnectionString, nodeVersion)));
        if (!site.defaultHostName) {
            logger_1.Logger.error(message_1.ErrorMessages.failToGetFunctionAppEndpoint);
            throw new errors_1.ProvisionError(enums_1.ResourceType.functionApp);
        }
        this.config.site = site;
        if (!this.config.functionEndpoint) {
            this.config.functionEndpoint = `https://${site.defaultHostName}`;
        }
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async postProvision(ctx) {
        var _a;
        await this.syncConfigFromContext(ctx);
        const functionAppName = this.getFunctionAppName();
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enums_1.FunctionConfigKey.credential);
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        const site = await this.getSite(ctx, webSiteManagementClient, resourceGroupName, functionAppName);
        // We must query app settings from azure here, for two reasons:
        // 1. The site object returned by SDK may not contain app settings.
        // 2. Azure automatically added some app settings during creation.
        const res = await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await webSiteManagementClient.webApps.listApplicationSettings(resourceGroupName, functionAppName));
        if (res.properties) {
            Object.entries(res.properties).forEach((kv) => {
                // The site have some settings added in provision step,
                // which should not be overwritten by queried settings.
                provision_1.FunctionProvision.pushAppSettings(site, kv[0], kv[1], false);
            });
        }
        this.collectFunctionAppSettings(ctx, site);
        await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await steps_1.step(steps_1.StepGroup.PostProvisionStepGroup, steps_1.PostProvisionSteps.updateFunctionSettings, async () => await webSiteManagementClient.webApps.update(resourceGroupName, functionAppName, site)));
        logger_1.Logger.info(message_1.InfoMessages.functionAppSettingsUpdated);
        if (!common_2.isArmSupportEnabled()) {
            await this.updateAuthSetting(ctx, webSiteManagementClient, resourceGroupName, functionAppName);
        }
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async preDeploy(ctx) {
        await this.syncConfigFromContext(ctx);
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const updated = await deploy_1.FunctionDeploy.hasUpdatedContent(workingPath, functionLanguage, ctx.envInfo.envName);
        if (!updated) {
            logger_1.Logger.info(message_1.InfoMessages.noChange);
            this.config.skipDeploy = true;
            return result_1.FunctionPluginResultFactory.Success();
        }
        // NOTE: make sure this step is before using `dotnet` command if you refactor this code.
        await this.handleDotnetChecker(ctx);
        await this.handleBackendExtensionsInstall(ctx, workingPath, functionLanguage);
        await errors_1.runWithErrorCatchAndThrow(new errors_1.InstallNpmPackageError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.npmPrepare, async () => deploy_1.FunctionDeploy.build(workingPath, functionLanguage)));
        this.config.skipDeploy = false;
        return result_1.FunctionPluginResultFactory.Success();
    }
    async updateArmTemplates(ctx) {
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const azureSolutionSettings = ctx.projectSettings.solutionSettings;
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSolutionSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.configuraitonTemplateFileName);
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Reference: {
                functionAppResourceId: constants_1.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_1.FunctionBicep.functionEndpoint,
            },
            Configuration: {
                Modules: { function: configModule },
            },
        };
        return result_1.FunctionPluginResultFactory.Success(result);
    }
    async generateArmTemplates(ctx) {
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const azureSolutionSettings = ctx.projectSettings.solutionSettings;
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(azureSolutionSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const provisionTemplateFilePath = path.join(bicepTemplateDirectory, constants_2.Bicep.ProvisionFileName);
        const provisionFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.provisionModuleTemplateFileName);
        const configTemplateFilePath = path.join(bicepTemplateDirectory, constants_2.Bicep.ConfigFileName);
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.configuraitonTemplateFileName);
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionTemplateFilePath, pluginCtx);
        const provisionModule = await tools_1.generateBicepFromFile(provisionFuncTemplateFilePath, pluginCtx);
        const configOrchestration = await tools_1.generateBicepFromFile(configTemplateFilePath, pluginCtx);
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { function: provisionModule },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { function: configModule },
            },
            Reference: {
                functionAppResourceId: constants_1.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_1.FunctionBicep.functionEndpoint,
            },
        };
        return result_1.FunctionPluginResultFactory.Success(result);
    }
    async deploy(ctx) {
        var _a;
        if (this.config.skipDeploy) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.skipDeploy);
            logger_1.Logger.warning(message_1.InfoMessages.skipDeployment);
            return result_1.FunctionPluginResultFactory.Success();
        }
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionAppName = this.getFunctionAppName();
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enums_1.FunctionConfigKey.credential);
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        logger_1.Logger.debug(`deploy function with subscription id: ${subscriptionId}, resourceGroup name: ${resourceGroupName}, function web app name: ${functionAppName}`);
        await deploy_1.FunctionDeploy.deployFunction(webSiteManagementClient, workingPath, functionAppName, functionLanguage, resourceGroupName, ctx.envInfo.envName);
        return result_1.FunctionPluginResultFactory.Success();
    }
    getFunctionProjectRootPath(ctx) {
        return path.join(ctx.root, constants_1.FunctionPluginPathInfo.solutionFolderName);
    }
    checkAndGet(v, key) {
        if (v) {
            return v;
        }
        throw new errors_1.FetchConfigError(key);
    }
    isPluginEnabled(ctx, plugin) {
        var _a;
        const selectedPlugins = ((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings)
            .activeResourcePlugins;
        return selectedPlugins.includes(plugin);
    }
    getFunctionAppName() {
        return common_2.isArmSupportEnabled()
            ? common_2.getSiteNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId))
            : this.checkAndGet(this.config.functionAppName, enums_1.FunctionConfigKey.functionAppName);
    }
    getFunctionAppResourceGroupName() {
        return common_2.isArmSupportEnabled()
            ? common_2.getResourceGroupNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId))
            : this.checkAndGet(this.config.resourceGroupName, enums_1.FunctionConfigKey.resourceGroupName);
    }
    getFunctionAppSubscriptionId() {
        return common_2.isArmSupportEnabled()
            ? common_2.getSubscriptionIdFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId))
            : this.checkAndGet(this.config.subscriptionId, enums_1.FunctionConfigKey.subscriptionId);
    }
    async getSite(ctx, client, resourceGroupName, functionAppName) {
        if (common_2.isArmSupportEnabled()) {
            const site = await azure_client_1.AzureLib.findFunctionApp(client, resourceGroupName, functionAppName);
            if (!site) {
                throw new errors_1.FindAppError();
            }
            else {
                const nodeVersion = await this.getValidNodeVersion(ctx);
                provision_1.FunctionProvision.pushAppSettings(site, "WEBSITE_NODE_DEFAULT_VERSION", "~" + nodeVersion);
                return site;
            }
        }
        else {
            // Retrieve and do cleanup
            const site = this.checkAndGet(this.config.site, enums_1.FunctionConfigKey.site);
            this.config.site = undefined;
            return site;
        }
    }
    async updateAuthSetting(ctx, client, resourceGroupName, functionAppName) {
        const authSettings = this.collectFunctionAppAuthSettings(ctx);
        if (authSettings) {
            await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await steps_1.step(steps_1.StepGroup.PostProvisionStepGroup, steps_1.PostProvisionSteps.updateFunctionSettings, async () => await client.webApps.updateAuthSettings(resourceGroupName, functionAppName, authSettings)));
        }
        logger_1.Logger.info(message_1.InfoMessages.functionAppAuthSettingsUpdated);
    }
    collectFunctionAppSettings(ctx, site) {
        const functionEndpoint = this.checkAndGet(this.config.functionEndpoint, enums_1.FunctionConfigKey.functionEndpoint);
        if (!common_2.isArmSupportEnabled()) {
            provision_1.FunctionProvision.updateFunctionSettingsSelf(site, functionEndpoint);
            const aadConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.aadPluginName);
            if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.aadPluginName) && aadConfig) {
                logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.aadPluginName));
                const clientId = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.aadClientId), "AAD client Id");
                const clientSecret = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.aadClientSecret), "AAD secret");
                const oauthHost = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.oauthHost), "OAuth Host");
                const tenantId = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.tenantId), "Tenant Id");
                const applicationIdUris = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.applicationIdUris), "Application Id URI");
                provision_1.FunctionProvision.updateFunctionSettingsForAAD(site, clientId, clientSecret, oauthHost, tenantId, applicationIdUris);
            }
            const frontendConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.frontendPluginName);
            if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.frontendPluginName) && frontendConfig) {
                logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.frontendPluginName));
                const frontendEndpoint = this.checkAndGet(frontendConfig.get(constants_1.DependentPluginInfo.frontendEndpoint), "frontend endpoint");
                provision_1.FunctionProvision.updateFunctionSettingsForFrontend(site, frontendEndpoint);
            }
            const sqlConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.sqlPluginName);
            const identityConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.identityPluginName);
            if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.sqlPluginName) &&
                this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.identityPluginName) &&
                sqlConfig &&
                identityConfig) {
                logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.sqlPluginName));
                logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.identityPluginName));
                const identityId = this.checkAndGet(identityConfig.get(constants_1.DependentPluginInfo.identityClientId), "identity client id");
                const databaseName = this.checkAndGet(sqlConfig.get(constants_1.DependentPluginInfo.databaseName), "database name");
                const sqlEndpoint = this.checkAndGet(sqlConfig.get(constants_1.DependentPluginInfo.sqlEndpoint), "sql endpoint");
                const identityResourceId = this.checkAndGet(identityConfig.get(constants_1.DependentPluginInfo.identityResourceId), "identity resource id");
                provision_1.FunctionProvision.updateFunctionSettingsForSQL(site, identityId, databaseName, sqlEndpoint, identityResourceId);
            }
        }
        const apimConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.apimPluginName);
        if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.apimPluginName) && apimConfig) {
            logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.apimPluginName));
            const clientId = this.checkAndGet(apimConfig.get(constants_1.DependentPluginInfo.apimAppId), "APIM app Id");
            provision_1.FunctionProvision.ensureFunctionAllowAppIds(site, [clientId]);
        }
    }
    collectFunctionAppAuthSettings(ctx) {
        const aadConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.aadPluginName);
        const frontendConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.frontendPluginName);
        if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.aadPluginName) &&
            this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.frontendPluginName) &&
            aadConfig &&
            frontendConfig) {
            const clientId = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.aadClientId), "AAD client Id");
            const oauthHost = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.oauthHost), "OAuth Host");
            const tenantId = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.tenantId), "tenant Id");
            const applicationIdUri = this.checkAndGet(aadConfig.get(constants_1.DependentPluginInfo.applicationIdUris), "Application Id URI");
            return provision_1.FunctionProvision.constructFunctionAuthSettings(clientId, applicationIdUri, oauthHost, tenantId);
        }
        return undefined;
    }
    async handleDotnetChecker(ctx) {
        try {
            const telemetry = new funcPluginTelemetry_1.FuncPluginTelemetry();
            const funcPluginAdapter = new funcPluginAdapter_1.FuncPluginAdapter(ctx, telemetry);
            await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.dotnetInstall, async () => {
                const dotnetChecker = new dotnetChecker_1.DotnetChecker(funcPluginAdapter, funcPluginLogger_1.funcPluginLogger, telemetry);
                try {
                    if (!(await dotnetChecker.isEnabled()) || (await dotnetChecker.isInstalled())) {
                        return;
                    }
                }
                catch (error) {
                    funcPluginLogger_1.funcPluginLogger.debug(message_1.InfoMessages.failedToCheckDotnet(error));
                    funcPluginAdapter.handleDotnetError(error);
                    return;
                }
                if (common_1.isLinux()) {
                    // TODO: handle linux installation
                    if (!(await funcPluginAdapter.handleDotnetForLinux(dotnetChecker))) {
                        // NOTE: this is a temporary fix for Linux, to make the error message more readable.
                        const message = await funcPluginAdapter.generateMsg(common_1.Messages.linuxDepsNotFoundHelpLinkMessage, [dotnetChecker]);
                        funcPluginAdapter.handleDotnetError(new errors_2.DepsCheckerError(message, common_1.dotnetManualInstallHelpLink));
                    }
                    return;
                }
                try {
                    await dotnetChecker.install();
                }
                catch (error) {
                    await funcPluginLogger_1.funcPluginLogger.printDetailLog();
                    funcPluginLogger_1.funcPluginLogger.error(message_1.InfoMessages.failedToInstallDotnet(error));
                    funcPluginAdapter.handleDotnetError(error);
                }
            });
        }
        finally {
            funcPluginLogger_1.funcPluginLogger.cleanup();
        }
    }
    async handleBackendExtensionsInstall(ctx, workingPath, functionLanguage) {
        await errors_1.runWithErrorCatchAndThrow(new errors_1.InstallTeamsfxBindingError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.installTeamsfxBinding, async () => {
            try {
                await deploy_1.FunctionDeploy.installFuncExtensions(ctx, workingPath, functionLanguage);
            }
            catch (error) {
                // wrap the original error to UserError so the extensibility model will pop-up a dialog correctly
                const telemetry = new funcPluginTelemetry_1.FuncPluginTelemetry();
                new funcPluginAdapter_1.FuncPluginAdapter(ctx, telemetry).handleDotnetError(error);
            }
        }));
    }
}
exports.FunctionPluginImpl = FunctionPluginImpl;
//# sourceMappingURL=plugin.js.map