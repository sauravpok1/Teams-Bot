"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlClient = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const tedious = tslib_1.__importStar(require("tedious"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
class SqlClient {
    constructor(ctx, config, token) {
        this.ctx = ctx;
        this.config = config;
        this.token = token;
    }
    static async create(ctx, config) {
        const token = await SqlClient.initToken(ctx, config);
        return new SqlClient(ctx, config, token);
    }
    async addDatabaseUser() {
        var _a;
        try {
            let query;
            query = `IF NOT EXISTS (SELECT name FROM [sys].[database_principals] WHERE name='${this.config.identity}')
      BEGIN
      CREATE USER [${this.config.identity}] FROM EXTERNAL PROVIDER;
      END;`;
            await this.doQuery(this.token, query);
            query = `sp_addrolemember 'db_datareader', '${this.config.identity}'`;
            await this.doQuery(this.token, query);
            query = `sp_addrolemember 'db_datawriter', '${this.config.identity}'`;
            await this.doQuery(this.token, query);
        }
        catch (error) {
            const link = constants_1.HelpLinks.default;
            if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes(errors_1.ErrorMessage.GuestAdminMessage)) {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(this.config.sqlServer, this.config.databaseName, this.config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, errorMessage, error, undefined, link, errorMessage + `. ${errors_1.ErrorMessage.GuestAdminError}`);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
            else {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(this.config.sqlServer, this.config.databaseName, this.config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, errorMessage, error, undefined, link, errorMessage + `. ${errors_1.ErrorMessage.GetDetail}`);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
        }
    }
    static async initToken(ctx, config) {
        var _a;
        const credential = await ctx.azureAccountProvider.getIdentityCredentialAsync();
        if (!credential) {
            const link = constants_1.HelpLinks.default;
            const reason = errors_1.ErrorMessage.IdentityCredentialUndefine(config.identity, config.databaseName);
            let message = errors_1.ErrorMessage.DatabaseUserCreateError.message(config.sqlServer, config.databaseName, config.identity);
            message += `. ${reason}`;
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, message + ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`, undefined, undefined, link, message);
        }
        try {
            const accessToken = await credential.getToken(constants_1.Constants.azureSqlScope);
            return accessToken.token;
        }
        catch (error) {
            const link = constants_1.HelpLinks.default;
            if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes(errors_1.ErrorMessage.DomainCode)) {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(config.sqlServer, config.databaseName, config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, errorMessage, error, undefined, link, errorMessage + `. ${errors_1.ErrorMessage.DomainError}`);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
            else {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(config.sqlServer, config.databaseName, config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, errorMessage, error, undefined, link, errorMessage + `. ${errors_1.ErrorMessage.GetDetail}`);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
        }
    }
    async doQuery(token, cmd) {
        const config = {
            server: this.config.sqlEndpoint,
            authentication: {
                type: "azure-active-directory-access-token",
                options: {
                    token: token,
                },
            },
            options: {
                debug: {
                    packet: true,
                    data: true,
                    payload: true,
                    token: false,
                    log: true,
                },
                rowCollectionOnDone: true,
                database: this.config.databaseName,
                encrypt: true,
                requestTimeout: 30000,
                connectTimeout: 30000,
            },
        };
        const connection = new tedious.Connection(config);
        return new Promise((resolve, reject) => {
            connection.on("connect", (err) => {
                if (err) {
                    reject(err);
                }
                const request = new tedious.Request(cmd, (err) => {
                    if (err) {
                        reject(err);
                    }
                });
                let res;
                request.on("doneInProc", function (rowCount, more, rows) {
                    res = rows;
                });
                request.on("requestCompleted", () => {
                    connection.close();
                    resolve(res);
                });
                request.on("error", (error) => {
                    reject(error);
                });
                connection.execSql(request);
            });
            connection.on("error", (err) => {
                reject(err);
            });
        });
    }
    static isFireWallError(error) {
        var _a;
        if ((error === null || error === void 0 ? void 0 : error.code) === "ELOGIN" && ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.match(errors_1.ErrorMessage.FirewallErrorReg))) {
            return true;
        }
        return false;
    }
}
exports.SqlClient = SqlClient;
//# sourceMappingURL=sqlClient.js.map