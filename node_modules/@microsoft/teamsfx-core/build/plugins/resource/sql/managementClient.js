"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagementClient = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_sql_1 = require("@azure/arm-sql");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const results_1 = require("./results");
class ManagementClient {
    constructor(ctx, config, client) {
        this.totalFirewallRuleCount = 0;
        this.ctx = ctx;
        this.config = config;
        this.client = client;
    }
    static async create(ctx, config) {
        const credential = await ctx.azureAccountProvider.getAccountCredentialAsync();
        const client = new arm_sql_1.SqlManagementClient(credential, config.azureSubscriptionId);
        return new ManagementClient(ctx, config, client);
    }
    async createAzureSQL() {
        const model = {
            location: this.config.location,
            administratorLogin: this.config.admin,
            administratorLoginPassword: this.config.adminPassword,
        };
        try {
            await this.client.servers.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCreateError.name, errors_1.ErrorMessage.SqlCreateError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async existAzureSQL() {
        try {
            const result = await this.client.servers.checkNameAvailability({
                name: this.config.sqlServer,
            });
            if (result.available) {
                return false;
            }
            else if (result.reason === "Invalid") {
                throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlEndpointError.name, errors_1.ErrorMessage.SqlEndpointError.message(this.config.sqlEndpoint));
            }
            else {
                return true;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlCheckError.name, errors_1.ErrorMessage.SqlCheckError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async existAadAdmin() {
        try {
            const result = await this.client.serverAzureADAdministrators.listByServer(this.config.resourceGroup, this.config.sqlServer);
            if (result.find((item) => item.login === this.config.aadAdmin)) {
                return true;
            }
            else {
                return false;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCheckAdminError.name, errors_1.ErrorMessage.SqlCheckAdminError.message(this.config.identity, error.message), error);
        }
    }
    async createDatabase() {
        const sku = {
            name: "Basic",
        };
        const model = {
            location: this.config.location,
            sku: sku,
        };
        try {
            await this.client.databases.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, this.config.databaseName, model);
            // when the request returned, the instance of database may not be ready. Let's wait a moment
            await this.delay(10);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseCreateError.name, errors_1.ErrorMessage.DatabaseCreateError.message(this.config.databaseName, error.message), error);
        }
    }
    async existDatabase() {
        try {
            const result = await this.client.databases.listByServer(this.config.resourceGroup, this.config.sqlServer);
            if (result.find((item) => item.name === this.config.databaseName)) {
                return true;
            }
            else {
                return false;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCheckDBError.name, errors_1.ErrorMessage.SqlCheckDBError.message(this.config.databaseName, error.message), error);
        }
    }
    async addAADadmin() {
        let model = {
            tenantId: this.config.tenantId,
            sid: this.config.aadAdminObjectId,
            login: this.config.aadAdmin,
        };
        const tmp = model;
        tmp.administratorType = constants_1.Constants.sqlAdministratorType;
        model = tmp;
        try {
            await this.client.serverAzureADAdministrators.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlAddAdminError.name, errors_1.ErrorMessage.SqlAddAdminError.message(this.config.aadAdmin, error.message), error);
        }
    }
    async addAzureFirewallRule() {
        const model = {
            startIpAddress: constants_1.Constants.firewall.azureIp,
            endIpAddress: constants_1.Constants.firewall.azureIp,
        };
        try {
            await this.client.firewallRules.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, constants_1.Constants.firewall.azureRule, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlAzureFirwallError.name, errors_1.ErrorMessage.SqlAzureFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async addLocalFirewallRule() {
        const response = await axios_1.default.get(constants_1.Constants.echoIpAddress);
        const localIp = response.data;
        const partials = localIp.split(".");
        partials[2] = constants_1.Constants.ipBeginToken;
        partials[3] = constants_1.Constants.ipBeginToken;
        const startIp = partials.join(".");
        partials[2] = constants_1.Constants.ipEndToken;
        partials[3] = constants_1.Constants.ipEndToken;
        const endIp = partials.join(".");
        const model = {
            startIpAddress: startIp,
            endIpAddress: endIp,
        };
        const ruleName = this.getRuleName(this.totalFirewallRuleCount);
        try {
            await this.client.firewallRules.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, ruleName, model);
            this.totalFirewallRuleCount++;
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlLocalFirwallError.name, errors_1.ErrorMessage.SqlLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async deleteLocalFirewallRule() {
        try {
            for (let i = 0; i < this.totalFirewallRuleCount; i++) {
                const ruleName = this.getRuleName(i);
                await this.client.firewallRules.deleteMethod(this.config.resourceGroup, this.config.sqlServer, ruleName);
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlDeleteLocalFirwallError.name, errors_1.ErrorMessage.SqlDeleteLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    getRuleName(suffix) {
        return constants_1.Constants.firewall.localRule + suffix;
    }
    async delay(s) {
        return new Promise((resolve) => setTimeout(resolve, s * 1000));
    }
}
exports.ManagementClient = ManagementClient;
//# sourceMappingURL=managementClient.js.map