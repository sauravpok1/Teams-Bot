import { HookContext } from "@feathersjs/hooks";
import { CoreCallbackEvent, CoreCallbackFunc, Func, FunctionRouter, FxError, Inputs, Json, LogProvider, ProjectConfig, ProjectSettings, QTreeNode, Result, Solution, SolutionContext, Stage, TelemetryReporter, Tools, v2, v3, Void } from "@microsoft/teamsfx-api";
import { getQuestionsForAddModule, getQuestionsForAddResource, getQuestionsForCreateProjectV2, getQuestionsForCreateProjectV3, getQuestionsForDeploy, getQuestionsForInit, getQuestionsForLocalProvision, getQuestionsForMigrateV1Project, getQuestionsForProvision, getQuestionsForPublish, getQuestionsForScaffold, getQuestionsForUserTaskV2, getQuestionsV2 } from "./middleware/questionModel";
export interface CoreHookContext extends HookContext {
    projectSettings?: ProjectSettings;
    solutionContext?: SolutionContext;
    solution?: Solution;
    contextV2?: v2.Context;
    solutionV2?: v2.SolutionPlugin;
    envInfoV2?: v2.EnvInfoV2;
    localSettings?: Json;
    envInfoV3?: v3.EnvInfoV3;
    solutionV3?: v3.ISolution;
}
export declare function isV3(): boolean;
export declare function isVsCallingCli(): boolean;
export declare let Logger: LogProvider;
export declare let telemetryReporter: TelemetryReporter | undefined;
export declare let currentStage: Stage;
export declare let TOOLS: Tools;
export declare function setTools(tools: Tools): void;
export declare class FxCore implements v3.ICore {
    tools: Tools;
    isFromSample?: boolean;
    settingsVersion?: string;
    constructor(tools: Tools);
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event: CoreCallbackEvent, callback: CoreCallbackFunc): void;
    createProject(inputs: Inputs): Promise<Result<string, FxError>>;
    createProjectV2(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string, FxError>>;
    createProjectV3(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string, FxError>>;
    migrateV1Project(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string, FxError>>;
    archive(projectPath: string): Promise<Result<Void, FxError>>;
    /**
     * switch to different versions of provisionResources
     */
    provisionResources(inputs: Inputs): Promise<Result<Void, FxError>>;
    provisionResourcesV2(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    provisionResourcesV3(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    deployArtifacts(inputs: Inputs): Promise<Result<Void, FxError>>;
    deployArtifactsV2(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    deployArtifactsV3(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    localDebug(inputs: Inputs): Promise<Result<Void, FxError>>;
    localDebugV2(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    localDebugV3(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _setEnvInfoV2(ctx?: CoreHookContext): void;
    publishApplication(inputs: Inputs): Promise<Result<Void, FxError>>;
    publishApplicationV2(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    publishApplicationV3(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    executeUserTask(func: Func, inputs: Inputs, ctx?: CoreHookContext): Promise<Result<unknown, FxError>>;
    getQuestions(stage: Stage, inputs: Inputs, ctx?: CoreHookContext): Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForUserTask(func: FunctionRouter, inputs: Inputs, ctx?: CoreHookContext): Promise<Result<QTreeNode | undefined, FxError>>;
    getProjectConfig(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<ProjectConfig | undefined, FxError>>;
    grantPermission(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<any, FxError>>;
    checkPermission(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<any, FxError>>;
    listCollaborator(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<any, FxError>>;
    listAllCollaborators(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<any, FxError>>;
    getSelectedEnv(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string | undefined, FxError>>;
    encrypt(plaintext: string, inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string, FxError>>;
    decrypt(ciphertext: string, inputs: Inputs, ctx?: CoreHookContext): Promise<Result<string, FxError>>;
    buildArtifacts(inputs: Inputs): Promise<Result<Void, FxError>>;
    createEnv(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    createEnvWithName(targetEnvName: string, projectSettings: ProjectSettings, inputs: Inputs): Promise<Result<Void, FxError>>;
    createEnvCopy(targetEnvName: string, sourceEnvName: string, inputs: Inputs, core: FxCore): Promise<Result<Void, FxError>>;
    activateEnv(inputs: Inputs, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _init(inputs: v2.InputsWithProjectPath & {
        solution?: string;
    }, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    init(inputs: v2.InputsWithProjectPath & {
        solution?: string;
    }, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _addModule(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    addModule(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    scaffold(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _scaffold(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    addResource(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _addResource(inputs: v2.InputsWithProjectPath, ctx?: CoreHookContext): Promise<Result<Void, FxError>>;
    _getQuestionsForCreateProjectV2: typeof getQuestionsForCreateProjectV2;
    _getQuestionsForCreateProjectV3: typeof getQuestionsForCreateProjectV3;
    _getQuestionsForUserTask: typeof getQuestionsForUserTaskV2;
    _getQuestions: typeof getQuestionsV2;
    _getQuestionsForMigrateV1Project: typeof getQuestionsForMigrateV1Project;
    _getQuestionsForScaffold: typeof getQuestionsForScaffold;
    _getQuestionsForAddModule: typeof getQuestionsForAddModule;
    _getQuestionsForAddResource: typeof getQuestionsForAddResource;
    _getQuestionsForProvision: typeof getQuestionsForProvision;
    _getQuestionsForDeploy: typeof getQuestionsForDeploy;
    _getQuestionsForLocalProvision: typeof getQuestionsForLocalProvision;
    _getQuestionsForPublish: typeof getQuestionsForPublish;
    _getQuestionsForInit: typeof getQuestionsForInit;
}
export declare function createBasicFolderStructure(inputs: Inputs): Promise<Result<null, FxError>>;
export declare function newProjectSettings(): ProjectSettings;
export declare function createV2Context(projectSettings: ProjectSettings): v2.Context;
export declare function undefinedName(objs: any[], names: string[]): string | undefined;
export declare function getProjectSettingsVersion(): string;
export * from "./error";
export * from "./tools";
export * from "./downloadSample";
//# sourceMappingURL=index.d.ts.map