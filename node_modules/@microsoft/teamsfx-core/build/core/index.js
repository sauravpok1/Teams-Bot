"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectSettingsVersion = exports.undefinedName = exports.createV2Context = exports.newProjectSettings = exports.createBasicFolderStructure = exports.FxCore = exports.setTools = exports.TOOLS = exports.currentStage = exports.telemetryReporter = exports.Logger = exports.isVsCallingCli = exports.isV3 = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const uuid = tslib_1.__importStar(require("uuid"));
const __1 = require("..");
const constants_1 = require("../common/constants");
const globalState_1 = require("../common/globalState");
const localSettingsProvider_1 = require("../common/localSettingsProvider");
const tools_1 = require("../common/tools");
const question_1 = require("../plugins/solution/fx-solution/question");
const constants_2 = require("../plugins/solution/fx-solution/v3/constants");
const callback_1 = require("./callback");
const crypto_1 = require("./crypto");
const downloadSample_1 = require("./downloadSample");
const error_1 = require("./error");
const concurrentLocker_1 = require("./middleware/concurrentLocker");
const contextInjector_1 = require("./middleware/contextInjector");
const envInfoLoader_1 = require("./middleware/envInfoLoader");
const envInfoLoaderV3_1 = require("./middleware/envInfoLoaderV3");
const envInfoWriter_1 = require("./middleware/envInfoWriter");
const envInfoWriterV3_1 = require("./middleware/envInfoWriterV3");
const errorHandler_1 = require("./middleware/errorHandler");
const localSettingsLoader_1 = require("./middleware/localSettingsLoader");
const localSettingsWriter_1 = require("./middleware/localSettingsWriter");
const migrateConditionHandler_1 = require("./middleware/migrateConditionHandler");
const projectMigrator_1 = require("./middleware/projectMigrator");
const projectSettingsLoader_1 = require("./middleware/projectSettingsLoader");
const projectSettingsLoaderV3_1 = require("./middleware/projectSettingsLoaderV3");
const projectSettingsWriter_1 = require("./middleware/projectSettingsWriter");
const questionModel_1 = require("./middleware/questionModel");
const solutionLoader_1 = require("./middleware/solutionLoader");
const solutionLoaderV3_1 = require("./middleware/solutionLoaderV3");
const supportV1ConditionHandler_1 = require("./middleware/supportV1ConditionHandler");
const question_2 = require("./question");
const SolutionPluginContainer_1 = require("./SolutionPluginContainer");
const tools_2 = require("./tools");
// TODO: For package.json,
// use require instead of import because of core building/packaging method.
// Using import will cause the build folder structure to change.
const corePackage = require("../../package.json");
function featureFlagEnabled(flagName) {
    const flag = process.env[flagName];
    if (flag !== undefined && flag.toLowerCase() === "true") {
        return true;
    }
    else {
        return false;
    }
}
function isV3() {
    return featureFlagEnabled(constants_1.FeatureFlagName.APIV3);
}
exports.isV3 = isV3;
// On VS calling CLI, interactive questions need to be skipped.
function isVsCallingCli() {
    return featureFlagEnabled(constants_1.FeatureFlagName.VSCallingCLI);
}
exports.isVsCallingCli = isVsCallingCli;
function setTools(tools) {
    exports.TOOLS = tools;
}
exports.setTools = setTools;
class FxCore {
    constructor(tools) {
        //V1,V2 questions
        this._getQuestionsForCreateProjectV2 = questionModel_1.getQuestionsForCreateProjectV2;
        this._getQuestionsForCreateProjectV3 = questionModel_1.getQuestionsForCreateProjectV3;
        this._getQuestionsForUserTask = questionModel_1.getQuestionsForUserTaskV2;
        this._getQuestions = questionModel_1.getQuestionsV2;
        this._getQuestionsForMigrateV1Project = questionModel_1.getQuestionsForMigrateV1Project;
        //v3 questions
        this._getQuestionsForScaffold = questionModel_1.getQuestionsForScaffold;
        this._getQuestionsForAddModule = questionModel_1.getQuestionsForAddModule;
        this._getQuestionsForAddResource = questionModel_1.getQuestionsForAddResource;
        this._getQuestionsForProvision = questionModel_1.getQuestionsForProvision;
        this._getQuestionsForDeploy = questionModel_1.getQuestionsForDeploy;
        this._getQuestionsForLocalProvision = questionModel_1.getQuestionsForLocalProvision;
        this._getQuestionsForPublish = questionModel_1.getQuestionsForPublish;
        this._getQuestionsForInit = questionModel_1.getQuestionsForInit;
        this.tools = tools;
        exports.TOOLS = tools;
        exports.Logger = tools.logProvider;
        exports.telemetryReporter = tools.telemetryReporter;
    }
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event, callback) {
        return callback_1.CallbackRegistry.set(event, callback);
    }
    async createProject(inputs) {
        if (isV3()) {
            return this.createProjectV3(inputs);
        }
        else {
            return this.createProjectV2(inputs);
        }
    }
    async createProjectV2(inputs, ctx) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        exports.currentStage = teamsfx_api_1.Stage.create;
        inputs.stage = teamsfx_api_1.Stage.create;
        let folder = inputs[question_2.QuestionRootFolder.name];
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            folder = tools_1.getRootDirectory();
            try {
                await fs.ensureDir(folder);
            }
            catch (e) {
                throw error_1.ProjectFolderInvalidError(folder);
            }
        }
        const scratch = inputs[question_2.CoreQuestionNames.CreateFromScratch];
        let projectPath;
        let globalStateDescription = "openReadme";
        if (scratch === question_2.ScratchOptionNo.id) {
            // create from sample
            const downloadRes = await downloadSample_1.downloadSample(inputs, ctx);
            if (downloadRes.isErr()) {
                return teamsfx_api_1.err(downloadRes.error);
            }
            projectPath = downloadRes.value;
            globalStateDescription = "openSampleReadme";
        }
        else {
            // create from new
            const appName = inputs[question_2.QuestionAppName.name];
            if (undefined === appName)
                return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_2.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            const folderExist = await fs.pathExists(projectPath);
            if (folderExist) {
                return teamsfx_api_1.err(error_1.ProjectFolderExistError(projectPath));
            }
            await fs.ensureDir(projectPath);
            await fs.ensureDir(path.join(projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
            await fs.ensureDir(path.join(projectPath, path.join("templates", `${teamsfx_api_1.AppPackageFolderName}`)));
            const basicFolderRes = await createBasicFolderStructure(inputs);
            if (basicFolderRes.isErr()) {
                return teamsfx_api_1.err(basicFolderRes.error);
            }
            const projectSettings = {
                appName: appName,
                projectId: inputs.projectId ? inputs.projectId : uuid.v4(),
                solutionSettings: {
                    name: "",
                    version: "1.0.0",
                },
                version: getProjectSettingsVersion(),
                isFromSample: false,
            };
            ctx.projectSettings = projectSettings;
            const createEnvResult = await this.createEnvWithName(__1.environmentManager.getDefaultEnvName(), projectSettings, inputs);
            if (createEnvResult.isErr()) {
                return teamsfx_api_1.err(createEnvResult.error);
            }
            const solution = await SolutionPluginContainer_1.getSolutionPluginV2ByName(inputs[question_2.CoreQuestionNames.Solution]);
            if (!solution) {
                return teamsfx_api_1.err(new error_1.LoadSolutionError());
            }
            ctx.solutionV2 = solution;
            projectSettings.solutionSettings.name = solution.name;
            const contextV2 = createV2Context(projectSettings);
            ctx.contextV2 = contextV2;
            const scaffoldSourceCodeRes = await solution.scaffoldSourceCode(contextV2, inputs);
            if (scaffoldSourceCodeRes.isErr()) {
                return teamsfx_api_1.err(scaffoldSourceCodeRes.error);
            }
            const generateResourceTemplateRes = await solution.generateResourceTemplate(contextV2, inputs);
            if (generateResourceTemplateRes.isErr()) {
                return teamsfx_api_1.err(generateResourceTemplateRes.error);
            }
            // ctx.provisionInputConfig = generateResourceTemplateRes.value;
            if (solution.createEnv) {
                inputs.copy = false;
                const createEnvRes = await solution.createEnv(contextV2, inputs);
                if (createEnvRes.isErr()) {
                    return teamsfx_api_1.err(createEnvRes.error);
                }
            }
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(globalStateDescription, true);
        }
        return teamsfx_api_1.ok(projectPath);
    }
    async createProjectV3(inputs, ctx) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        exports.currentStage = teamsfx_api_1.Stage.create;
        inputs.stage = teamsfx_api_1.Stage.create;
        let folder = inputs[question_2.QuestionRootFolder.name];
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.VS) {
            folder = tools_1.getRootDirectory();
            try {
                await fs.ensureDir(folder);
            }
            catch (e) {
                throw error_1.ProjectFolderInvalidError(folder);
            }
        }
        const scratch = inputs[question_2.CoreQuestionNames.CreateFromScratch];
        let projectPath;
        let globalStateDescription = "openReadme";
        if (scratch === question_2.ScratchOptionNo.id) {
            // create from sample
            const downloadRes = await downloadSample_1.downloadSample(inputs, ctx);
            if (downloadRes.isErr()) {
                return teamsfx_api_1.err(downloadRes.error);
            }
            projectPath = downloadRes.value;
            globalStateDescription = "openSampleReadme";
        }
        else {
            // create from new
            const appName = inputs[question_2.QuestionAppName.name];
            if (undefined === appName)
                return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_2.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            const folderExist = await fs.pathExists(projectPath);
            if (folderExist) {
                return teamsfx_api_1.err(error_1.ProjectFolderExistError(projectPath));
            }
            await fs.ensureDir(projectPath);
            await fs.ensureDir(path.join(projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
            let capabilities = inputs[question_2.CoreQuestionNames.Capabilities];
            let projectType = "";
            if (capabilities.includes(question_2.TabSPFxItem.id))
                projectType = "spfx";
            else if (capabilities.includes(question_2.TabOptionItem.id) && capabilities.length === 1)
                projectType = "tab";
            else if ((capabilities.includes(question_2.BotOptionItem.id) ||
                capabilities.includes(question_1.MessageExtensionItem.id)) &&
                !capabilities.includes(question_2.TabOptionItem.id))
                projectType = "bot";
            else if ((capabilities.includes(question_2.BotOptionItem.id) ||
                capabilities.includes(question_1.MessageExtensionItem.id)) &&
                capabilities.includes(question_2.TabOptionItem.id))
                projectType = "tab+bot";
            const programmingLanguage = inputs[question_2.CoreQuestionNames.ProgrammingLanguage];
            // const solution = capabilities.includes(TabSPFxItem.id)
            //   ? BuiltInSolutionNames.spfx
            //   : BuiltInSolutionNames.azure;
            // init
            const initInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath });
            const initRes = await this._init(initInputs, ctx);
            if (initRes.isErr()) {
                return teamsfx_api_1.err(initRes.error);
            }
            // addModule, scaffold and addResource
            if (inputs.platform === teamsfx_api_1.Platform.VS) {
                // addModule
                const addModuleInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, capabilities: capabilities });
                const addModuleRes = await this._addModule(addModuleInputs, ctx);
                if (addModuleRes.isErr()) {
                    return teamsfx_api_1.err(addModuleRes.error);
                }
                // addResource
                const addResourceInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "0", resource: constants_2.BuiltInResourcePluginNames.webApp });
                const addResourceRes = await this._addResource(addResourceInputs, ctx);
                if (addResourceRes.isErr()) {
                    return teamsfx_api_1.err(addResourceRes.error);
                }
                // scaffold
                let templateName = "";
                if (projectType === "tab")
                    templateName = "BlazorTab";
                else if (projectType === "bot")
                    templateName = "BlazorBot";
                else if (projectType === "tabbot")
                    templateName = "BlazorTabBot";
                const scaffoldInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "0", template: {
                        id: `${constants_2.BuiltInScaffoldPluginNames.blazor}/${templateName}`,
                        label: `${constants_2.BuiltInScaffoldPluginNames.blazor}/${templateName}`,
                        data: {
                            pluginName: constants_2.BuiltInScaffoldPluginNames.blazor,
                            templateName: templateName,
                        },
                    } });
                const scaffoldRes = await this._scaffold(scaffoldInputs, ctx);
                if (scaffoldRes.isErr()) {
                    return teamsfx_api_1.err(scaffoldRes.error);
                }
            }
            else {
                if (capabilities.includes(question_2.TabOptionItem.id) || capabilities.includes(question_2.TabSPFxItem.id)) {
                    const addModuleInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, capabilities: capabilities.includes(question_2.TabOptionItem.id)
                            ? [question_2.TabOptionItem.id]
                            : [question_2.TabSPFxItem.id] });
                    const addModuleRes = await this._addModule(addModuleInputs, ctx);
                    if (addModuleRes.isErr()) {
                        return teamsfx_api_1.err(addModuleRes.error);
                    }
                    // addResource
                    const addResourceInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "0", resource: capabilities.includes(question_2.TabOptionItem.id)
                            ? constants_2.BuiltInResourcePluginNames.storage
                            : constants_2.BuiltInResourcePluginNames.spfx });
                    const addResourceRes = await this._addResource(addResourceInputs, ctx);
                    if (addResourceRes.isErr()) {
                        return teamsfx_api_1.err(addResourceRes.error);
                    }
                    // scaffold
                    const pluginName = capabilities.includes(question_2.TabOptionItem.id)
                        ? constants_2.BuiltInScaffoldPluginNames.tab
                        : constants_2.BuiltInScaffoldPluginNames.spfx;
                    const templateName = capabilities.includes(question_2.TabOptionItem.id)
                        ? programmingLanguage === "javascript"
                            ? "ReactTab_JS"
                            : "ReactTab_TS"
                        : "SPFxTab";
                    const scaffoldInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "0", template: {
                            id: `${pluginName}/${templateName}`,
                            label: `${pluginName}/${templateName}`,
                            data: {
                                pluginName: pluginName,
                                templateName: templateName, //TODO
                            },
                        } });
                    const scaffoldRes = await this._scaffold(scaffoldInputs, ctx);
                    if (scaffoldRes.isErr()) {
                        return teamsfx_api_1.err(scaffoldRes.error);
                    }
                }
                capabilities = capabilities.filter((c) => c !== question_2.TabOptionItem.id && c !== question_2.TabSPFxItem.id);
                if (capabilities.length > 0) {
                    const addModuleInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, capabilities: capabilities });
                    const addModuleRes = await this._addModule(addModuleInputs, ctx);
                    if (addModuleRes.isErr()) {
                        return teamsfx_api_1.err(addModuleRes.error);
                    }
                    // addResource
                    const addResourceInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "1", resource: constants_2.BuiltInResourcePluginNames.bot });
                    const addResourceRes = await this._addResource(addResourceInputs, ctx);
                    if (addResourceRes.isErr()) {
                        return teamsfx_api_1.err(addResourceRes.error);
                    }
                    // scaffold
                    const templateName = programmingLanguage === "javascript" ? "NodejsBot_JS" : "NodejsBot_TS";
                    const scaffoldInputs = Object.assign(Object.assign({}, inputs), { projectPath: projectPath, module: "1", resource: constants_2.BuiltInScaffoldPluginNames.bot, template: {
                            id: `${constants_2.BuiltInScaffoldPluginNames.bot}/${templateName}`,
                            label: `${constants_2.BuiltInScaffoldPluginNames.bot}/${templateName}`,
                            data: {
                                pluginName: constants_2.BuiltInScaffoldPluginNames.bot,
                                templateName: templateName, //TODO
                            },
                        } });
                    const scaffoldRes = await this._scaffold(scaffoldInputs, ctx);
                    if (scaffoldRes.isErr()) {
                        return teamsfx_api_1.err(scaffoldRes.error);
                    }
                }
            }
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(globalStateDescription, true);
        }
        return teamsfx_api_1.ok(projectPath);
    }
    async migrateV1Project(inputs, ctx) {
        var _a;
        exports.currentStage = teamsfx_api_1.Stage.migrateV1;
        inputs.stage = teamsfx_api_1.Stage.migrateV1;
        const globalStateDescription = "openReadme";
        const appName = ((_a = inputs[question_2.DefaultAppNameFunc.name]) !== null && _a !== void 0 ? _a : inputs[question_2.QuestionV1AppName.name]);
        if (undefined === appName)
            return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
        const validateResult = jsonschema.validate(appName, {
            pattern: question_2.ProjectNamePattern,
        });
        if (validateResult.errors && validateResult.errors.length > 0) {
            return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
        }
        const projectPath = inputs.projectPath;
        if (!projectPath || !(await fs.pathExists(projectPath))) {
            return teamsfx_api_1.err(error_1.ProjectFolderNotExistError(projectPath !== null && projectPath !== void 0 ? projectPath : ""));
        }
        const solution = await SolutionPluginContainer_1.getAllSolutionPlugins()[0];
        const projectSettings = {
            appName: appName,
            projectId: uuid.v4(),
            solutionSettings: {
                name: solution.name,
                version: "1.0.0",
                migrateFromV1: true,
            },
        };
        const solutionContext = Object.assign(Object.assign(Object.assign({ projectSettings: projectSettings, envInfo: tools_2.newEnvInfo(), root: projectPath }, this.tools), this.tools.tokenProvider), { answers: inputs, cryptoProvider: new crypto_1.LocalCrypto(projectSettings.projectId) });
        const archiveResult = await this.archive(projectPath);
        if (archiveResult.isErr()) {
            return teamsfx_api_1.err(archiveResult.error);
        }
        await fs.ensureDir(projectPath);
        await fs.ensureDir(path.join(projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
        const createResult = await createBasicFolderStructure(inputs);
        if (createResult.isErr()) {
            return teamsfx_api_1.err(createResult.error);
        }
        if (!solution.migrate) {
            return teamsfx_api_1.err(error_1.MigrateNotImplementError(projectPath));
        }
        const migrateV1Res = await solution.migrate(solutionContext);
        if (migrateV1Res.isErr()) {
            return migrateV1Res;
        }
        ctx.solution = solution;
        ctx.solutionContext = solutionContext;
        ctx.projectSettings = projectSettings;
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(globalStateDescription, true);
        }
        this._setEnvInfoV2(ctx);
        return teamsfx_api_1.ok(projectPath);
    }
    async archive(projectPath) {
        try {
            const archiveFolderPath = path.join(projectPath, teamsfx_api_1.ArchiveFolderName);
            await fs.ensureDir(archiveFolderPath);
            const fileNames = await fs.readdir(projectPath);
            const archiveLog = async (projectPath, message) => {
                await fs.appendFile(path.join(projectPath, teamsfx_api_1.ArchiveLogFileName), `[${new Date().toISOString()}] ${message}\n`);
            };
            await archiveLog(projectPath, `Start to move files into '${teamsfx_api_1.ArchiveFolderName}' folder.`);
            for (const fileName of fileNames) {
                if (fileName === teamsfx_api_1.ArchiveFolderName || fileName === teamsfx_api_1.ArchiveLogFileName) {
                    continue;
                }
                try {
                    await fs.move(path.join(projectPath, fileName), path.join(archiveFolderPath, fileName), {
                        overwrite: true,
                    });
                }
                catch (e) {
                    await archiveLog(projectPath, `Failed to move '${fileName}'. ${e.message}`);
                    return teamsfx_api_1.err(error_1.ArchiveUserFileError(fileName, e.message));
                }
                await archiveLog(projectPath, `'${fileName}' has been moved to '${teamsfx_api_1.ArchiveFolderName}' folder.`);
            }
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.ArchiveProjectError(e.message));
        }
    }
    /**
     * switch to different versions of provisionResources
     */
    async provisionResources(inputs) {
        if (isV3()) {
            return this.provisionResourcesV3(inputs);
        }
        else {
            return this.provisionResourcesV2(inputs);
        }
    }
    async provisionResourcesV2(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.provision;
        inputs.stage = teamsfx_api_1.Stage.provision;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("Provision input stuff"));
        }
        const envInfo = ctx.envInfoV2;
        const result = await ctx.solutionV2.provisionResources(ctx.contextV2, inputs, envInfo, this.tools.tokenProvider);
        if (result.kind === "success") {
            ctx.envInfoV2.state = lodash_1.assign(ctx.envInfoV2.state, result.output);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else if (result.kind === "partialSuccess") {
            ctx.envInfoV2.state = lodash_1.assign(ctx.envInfoV2.state, result.output);
            return teamsfx_api_1.err(result.error);
        }
        else {
            return teamsfx_api_1.err(result.error);
        }
    }
    async provisionResourcesV3(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.provision;
        inputs.stage = teamsfx_api_1.Stage.provision;
        if (ctx &&
            ctx.solutionV3 &&
            ctx.contextV2 &&
            ctx.envInfoV3 &&
            ctx.solutionV3.provisionResources) {
            const res = await ctx.solutionV3.provisionResources(ctx.contextV2, inputs, ctx.envInfoV3, exports.TOOLS.tokenProvider);
            if (res.isOk()) {
                ctx.envInfoV3 = res.value;
            }
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deployArtifacts(inputs) {
        if (isV3())
            return this.deployArtifactsV3(inputs);
        else
            return this.deployArtifactsV2(inputs);
    }
    async deployArtifactsV2(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.deploy;
        inputs.stage = teamsfx_api_1.Stage.deploy;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            const name = undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.contextV2", "ctx.envInfoV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`Deploy input stuff: ${name}`));
        }
        if (ctx.solutionV2.deploy)
            return await ctx.solutionV2.deploy(ctx.contextV2, inputs, ctx.envInfoV2, this.tools.tokenProvider);
        else
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deployArtifactsV3(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.deploy;
        inputs.stage = teamsfx_api_1.Stage.deploy;
        if (ctx && ctx.solutionV3 && ctx.contextV2 && ctx.envInfoV3 && ctx.solutionV3.deploy) {
            const res = await ctx.solutionV3.deploy(ctx.contextV2, inputs, ctx.envInfoV3, exports.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async localDebug(inputs) {
        if (isV3())
            return this.localDebugV3(inputs);
        else
            return this.localDebugV2(inputs);
    }
    async localDebugV2(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.debug;
        inputs.stage = teamsfx_api_1.Stage.debug;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2) {
            const name = undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2], ["ctx", "ctx.solutionV2", "ctx.contextV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`localDebug input stuff (${name})`));
        }
        if (!ctx.localSettings)
            ctx.localSettings = {};
        if (ctx.solutionV2.provisionLocalResource) {
            const res = await ctx.solutionV2.provisionLocalResource(ctx.contextV2, inputs, ctx.localSettings, this.tools.tokenProvider);
            if (res.kind === "success") {
                ctx.localSettings = res.output;
                return teamsfx_api_1.ok(teamsfx_api_1.Void);
            }
            else if (res.kind === "partialSuccess") {
                ctx.localSettings = res.output;
                return teamsfx_api_1.err(res.error);
            }
            else {
                return teamsfx_api_1.err(res.error);
            }
        }
        else {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
    }
    async localDebugV3(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.debug;
        inputs.stage = teamsfx_api_1.Stage.debug;
        if (ctx &&
            ctx.solutionV3 &&
            ctx.contextV2 &&
            ctx.localSettings &&
            ctx.solutionV3.provisionLocalResources) {
            const res = await ctx.solutionV3.provisionLocalResources(ctx.contextV2, inputs, ctx.localSettings, exports.TOOLS.tokenProvider);
            if (res.isOk()) {
                ctx.localSettings = res.value;
            }
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    _setEnvInfoV2(ctx) {
        if (ctx && ctx.solutionContext) {
            //workaround, compatible to api v2
            ctx.envInfoV2 = {
                envName: ctx.solutionContext.envInfo.envName,
                config: ctx.solutionContext.envInfo.config,
                state: {},
            };
            ctx.envInfoV2.state = tools_1.mapToJson(ctx.solutionContext.envInfo.state);
        }
    }
    async publishApplication(inputs) {
        if (isV3())
            return this.publishApplicationV3(inputs);
        else
            return this.publishApplicationV2(inputs);
    }
    async publishApplicationV2(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.publish;
        inputs.stage = teamsfx_api_1.Stage.publish;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            const name = undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.contextV2", "ctx.envInfoV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`publish input stuff: ${name}`));
        }
        return await ctx.solutionV2.publishApplication(ctx.contextV2, inputs, ctx.envInfoV2, this.tools.tokenProvider.appStudioToken);
    }
    async publishApplicationV3(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.publish;
        inputs.stage = teamsfx_api_1.Stage.publish;
        if (ctx &&
            ctx.solutionV3 &&
            ctx.contextV2 &&
            ctx.envInfoV3 &&
            ctx.solutionV3.publishApplication) {
            const res = await ctx.solutionV3.publishApplication(ctx.contextV2, inputs, ctx.envInfoV3, exports.TOOLS.tokenProvider.appStudioToken);
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async executeUserTask(func, inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.userTask;
        inputs.stage = teamsfx_api_1.Stage.userTask;
        const namespace = func.namespace;
        const array = namespace ? namespace.split("/") : [];
        if ("" !== namespace && array.length > 0) {
            if (!ctx || !ctx.solutionV2 || !ctx.envInfoV2) {
                const name = undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.envInfoV2"]);
                return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`executeUserTask input stuff: ${name}`));
            }
            if (!ctx.contextV2)
                ctx.contextV2 = createV2Context(newProjectSettings());
            if (ctx.solutionV2.executeUserTask) {
                if (!ctx.localSettings)
                    ctx.localSettings = {};
                const res = await ctx.solutionV2.executeUserTask(ctx.contextV2, inputs, func, ctx.localSettings, ctx.envInfoV2, this.tools.tokenProvider);
                return res;
            }
            else
                return teamsfx_api_1.err(error_1.FunctionRouterError(func));
        }
        return teamsfx_api_1.err(error_1.FunctionRouterError(func));
    }
    async getQuestions(stage, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getQuestions input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getQuestions;
        exports.currentStage = teamsfx_api_1.Stage.getQuestions;
        if (stage === teamsfx_api_1.Stage.create) {
            delete inputs.projectPath;
            return await this._getQuestionsForCreateProjectV2(inputs);
        }
        else {
            const contextV2 = ctx.contextV2 ? ctx.contextV2 : createV2Context(newProjectSettings());
            const solutionV2 = ctx.solutionV2 ? ctx.solutionV2 : await SolutionPluginContainer_1.getAllSolutionPluginsV2()[0];
            const envInfoV2 = ctx.envInfoV2
                ? ctx.envInfoV2
                : { envName: __1.environmentManager.getDefaultEnvName(), config: {}, state: {} };
            inputs.stage = stage;
            return await this._getQuestions(contextV2, solutionV2, stage, inputs, envInfoV2);
        }
    }
    async getQuestionsForUserTask(func, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getQuestionsForUserTask input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getQuestions;
        exports.currentStage = teamsfx_api_1.Stage.getQuestions;
        const contextV2 = ctx.contextV2 ? ctx.contextV2 : createV2Context(newProjectSettings());
        const solutionV2 = ctx.solutionV2 ? ctx.solutionV2 : await SolutionPluginContainer_1.getAllSolutionPluginsV2()[0];
        const envInfoV2 = ctx.envInfoV2
            ? ctx.envInfoV2
            : { envName: __1.environmentManager.getDefaultEnvName(), config: {}, state: {} };
        return await this._getQuestionsForUserTask(contextV2, solutionV2, func, inputs, envInfoV2);
    }
    async getProjectConfig(inputs, ctx) {
        var _a, _b;
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getProjectConfig input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getProjectConfig;
        exports.currentStage = teamsfx_api_1.Stage.getProjectConfig;
        return teamsfx_api_1.ok({
            settings: ctx.projectSettings,
            config: (_a = ctx.solutionContext) === null || _a === void 0 ? void 0 : _a.envInfo.state,
            localSettings: (_b = ctx.solutionContext) === null || _b === void 0 ? void 0 : _b.localSettings,
        });
    }
    async grantPermission(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.grantPermission;
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.grantPermission(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async checkPermission(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.checkPermission;
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.checkPermission(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async listCollaborator(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.listCollaborator;
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.listCollaborator(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async listAllCollaborators(inputs, ctx) {
        exports.currentStage = teamsfx_api_1.Stage.listAllCollaborators;
        inputs.stage = teamsfx_api_1.Stage.listAllCollaborators;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.listAllCollaborators(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async getSelectedEnv(inputs, ctx) {
        var _a;
        return teamsfx_api_1.ok((_a = ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2) === null || _a === void 0 ? void 0 : _a.envName);
    }
    async encrypt(plaintext, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx"));
        if (!ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.contextV2"));
        return ctx.contextV2.cryptoProvider.encrypt(plaintext);
    }
    async decrypt(ciphertext, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx"));
        if (!ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.contextV2"));
        return ctx.contextV2.cryptoProvider.decrypt(ciphertext);
    }
    async buildArtifacts(inputs) {
        throw new error_1.TaskNotSupportError(teamsfx_api_1.Stage.build);
    }
    async createEnv(inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("createEnv input stuff"));
        const projectSettings = ctx.projectSettings;
        if (!projectSettings) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const core = ctx.self;
        const createEnvCopyInput = await envInfoLoader_1.askNewEnvironment(ctx, inputs);
        if (!createEnvCopyInput ||
            !createEnvCopyInput.targetEnvName ||
            !createEnvCopyInput.sourceEnvName) {
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        }
        const createEnvResult = await this.createEnvCopy(createEnvCopyInput.targetEnvName, createEnvCopyInput.sourceEnvName, inputs, core);
        if (createEnvResult.isErr()) {
            return createEnvResult;
        }
        inputs.sourceEnvName = createEnvCopyInput.sourceEnvName;
        inputs.targetEnvName = createEnvCopyInput.targetEnvName;
        if (!ctx.solutionV2 || !ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.solutionV2, ctx.contextV2"));
        if (ctx.solutionV2.createEnv) {
            inputs.copy = true;
            return await ctx.solutionV2.createEnv(ctx.contextV2, inputs);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async createEnvWithName(targetEnvName, projectSettings, inputs) {
        const appName = projectSettings.appName;
        const newEnvConfig = __1.environmentManager.newEnvConfigData(appName);
        const writeEnvResult = await __1.environmentManager.writeEnvConfig(inputs.projectPath, newEnvConfig, targetEnvName);
        if (writeEnvResult.isErr()) {
            return teamsfx_api_1.err(writeEnvResult.error);
        }
        this.tools.logProvider.debug(`[core] persist ${targetEnvName} env state to path ${writeEnvResult.value}: ${JSON.stringify(newEnvConfig)}`);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async createEnvCopy(targetEnvName, sourceEnvName, inputs, core) {
        // copy env config file
        const targetEnvConfigFilePath = __1.environmentManager.getEnvConfigPath(targetEnvName, inputs.projectPath);
        const sourceEnvConfigFilePath = __1.environmentManager.getEnvConfigPath(sourceEnvName, inputs.projectPath);
        try {
            await fs.copy(sourceEnvConfigFilePath, targetEnvConfigFilePath);
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.CopyFileError(e));
        }
        exports.TOOLS.logProvider.debug(`[core] copy env config file for ${targetEnvName} environment to path ${targetEnvConfigFilePath}`);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    // deprecated
    async activateEnv(inputs, ctx) {
        const env = inputs.env;
        if (!env) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("env"));
        }
        if (!ctx.projectSettings) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const envConfigs = await __1.environmentManager.listEnvConfigs(inputs.projectPath);
        if (envConfigs.isErr()) {
            return envConfigs;
        }
        if (envConfigs.isErr() || envConfigs.value.indexOf(env) < 0) {
            return teamsfx_api_1.err(error_1.NonExistEnvNameError(env));
        }
        const core = ctx.self;
        const solutionContext = await envInfoLoader_1.loadSolutionContext(inputs, ctx.projectSettings, env);
        if (!solutionContext.isErr()) {
            ctx.provisionInputConfig = solutionContext.value.envInfo.config;
            ctx.provisionOutputs = solutionContext.value.envInfo.state;
            ctx.envName = solutionContext.value.envInfo.envName;
        }
        this.tools.ui.showMessage("info", `[${env}] is activated.`, false);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async _init(inputs, ctx) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        const appName = inputs[question_2.QuestionAppName.name];
        const validateResult = jsonschema.validate(appName, {
            pattern: question_2.ProjectNamePattern,
        });
        if (validateResult.errors && validateResult.errors.length > 0) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid app-name", inputs));
        }
        const projectSettings = newProjectSettings();
        projectSettings.appName = appName;
        ctx.projectSettings = projectSettings;
        if (!inputs.solution) {
            return teamsfx_api_1.err(error_1.InvalidInputError("solution is undefined", inputs));
        }
        const createEnvResult = await this.createEnvWithName(__1.environmentManager.getDefaultEnvName(), projectSettings, inputs);
        if (createEnvResult.isErr()) {
            return teamsfx_api_1.err(createEnvResult.error);
        }
        await fs.ensureDir(path.join(inputs.projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
        await fs.ensureDir(path.join(inputs.projectPath, "templates", `${teamsfx_api_1.AppPackageFolderName}`));
        const basicFolderRes = await createBasicFolderStructure(inputs);
        if (basicFolderRes.isErr()) {
            return teamsfx_api_1.err(basicFolderRes.error);
        }
        const solution = typedi_1.Container.get(inputs.solution);
        projectSettings.solutionSettings.name = inputs.solution;
        const context = createV2Context(projectSettings);
        ctx.contextV2 = context;
        ctx.solutionV3 = solution;
        return await solution.init(context, inputs);
    }
    async init(inputs, ctx) {
        return this._init(inputs, ctx);
    }
    async _addModule(inputs, ctx) {
        if (ctx && ctx.solutionV3 && ctx.contextV2) {
            return await ctx.solutionV3.addModule(ctx.contextV2, {}, inputs);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async addModule(inputs, ctx) {
        return this._addModule(inputs, ctx);
    }
    async scaffold(inputs, ctx) {
        return this._scaffold(inputs, ctx);
    }
    async _scaffold(inputs, ctx) {
        if (ctx && ctx.solutionV3 && ctx.contextV2) {
            return await ctx.solutionV3.scaffold(ctx.contextV2, inputs);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async addResource(inputs, ctx) {
        return this._addResource(inputs, ctx);
    }
    async _addResource(inputs, ctx) {
        if (ctx && ctx.solutionV3 && ctx.contextV2) {
            return await ctx.solutionV3.addResource(ctx.contextV2, inputs);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(true),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProjectV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriterV3_1.EnvInfoWriterMW_V3(true),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProjectV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        migrateConditionHandler_1.MigrateConditionHandlerMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(true),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "migrateV1Project", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResourcesV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriterV3_1.EnvInfoWriterMW_V3(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResourcesV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifactsV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriterV3_1.EnvInfoWriterMW_V3(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifactsV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(true),
        localSettingsWriter_1.LocalSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "localDebugV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        localSettingsWriter_1.LocalSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "localDebugV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplicationV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplicationV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "executeUserTask", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getQuestions", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getQuestionsForUserTask", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectConfig", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "grantPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkPermission", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listCollaborator", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listAllCollaborators", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getSelectedEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "encrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "decrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(false),
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        supportV1ConditionHandler_1.SupportV1ConditionMW(true),
        projectMigrator_1.ProjectMigratorMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "activateEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionModel_1.QuestionModelMW, contextInjector_1.ContextInjectorMW, projectSettingsWriter_1.ProjectSettingsWriterMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "init", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addModule", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "scaffold", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        projectSettingsLoaderV3_1.ProjectSettingsLoaderMW_V3,
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addResource", null);
exports.FxCore = FxCore;
async function createBasicFolderStructure(inputs) {
    if (!inputs.projectPath) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
    }
    try {
        const appName = inputs[question_2.QuestionAppName.name];
        if (inputs.platform !== teamsfx_api_1.Platform.VS) {
            await fs.writeFile(path.join(inputs.projectPath, `package.json`), JSON.stringify({
                name: appName,
                version: "0.0.1",
                description: "",
                author: "",
                scripts: {
                    test: 'echo "Error: no test specified" && exit 1',
                },
                devDependencies: {
                    "@microsoft/teamsfx-cli": "0.*",
                },
                license: "MIT",
            }, null, 4));
        }
        await fs.writeFile(path.join(inputs.projectPath, `.gitignore`), [
            "node_modules",
            `.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.InputConfigsFolderName}/${localSettingsProvider_1.localSettingsFileName}`,
            `.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.StatesFolderName}/*.userdata`,
            ".DS_Store",
            `${teamsfx_api_1.ArchiveFolderName}`,
            `${teamsfx_api_1.ArchiveLogFileName}`,
            ".env.teamsfx.local",
            "subscriptionInfo.json",
            teamsfx_api_1.BuildFolderName,
        ].join("\n"));
    }
    catch (e) {
        return teamsfx_api_1.err(error_1.WriteFileError(e));
    }
    return teamsfx_api_1.ok(null);
}
exports.createBasicFolderStructure = createBasicFolderStructure;
function newProjectSettings() {
    const projectSettings = {
        appName: "",
        projectId: uuid.v4(),
        version: getProjectSettingsVersion(),
        solutionSettings: {
            name: "",
        },
    };
    return projectSettings;
}
exports.newProjectSettings = newProjectSettings;
function createV2Context(projectSettings) {
    const context = {
        userInteraction: exports.TOOLS.ui,
        logProvider: exports.TOOLS.logProvider,
        telemetryReporter: exports.TOOLS.telemetryReporter,
        cryptoProvider: new crypto_1.LocalCrypto(projectSettings.projectId),
        permissionRequestProvider: exports.TOOLS.permissionRequest,
        projectSetting: projectSettings,
    };
    return context;
}
exports.createV2Context = createV2Context;
function undefinedName(objs, names) {
    for (let i = 0; i < objs.length; ++i) {
        if (objs[i] === undefined) {
            return names[i];
        }
    }
    return undefined;
}
exports.undefinedName = undefinedName;
function getProjectSettingsVersion() {
    return "2.0.0";
}
exports.getProjectSettingsVersion = getProjectSettingsVersion;
tslib_1.__exportStar(require("./error"), exports);
tslib_1.__exportStar(require("./tools"), exports);
tslib_1.__exportStar(require("./downloadSample"), exports);
//# sourceMappingURL=index.js.map