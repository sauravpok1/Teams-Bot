"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenConfigJson = exports.getLockFolder = exports.newEnvInfoV3 = exports.newEnvInfo = exports.isMigrateFromV1Project = exports.validateV1Project = exports.isValidProject = exports.validateSettings = exports.validateProject = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const constants_2 = require("../plugins/solution/fx-solution/constants");
const environment_1 = require("./environment");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const os = tslib_1.__importStar(require("os"));
function validateProject(solutionContext) {
    const res = validateSettings(solutionContext.projectSettings);
    return res;
}
exports.validateProject = validateProject;
function validateSettings(projectSettings) {
    if (!projectSettings)
        return "empty projectSettings";
    if (!projectSettings.solutionSettings)
        return "empty solutionSettings";
    const solutionSettings = projectSettings.solutionSettings;
    if (solutionSettings.hostType === undefined)
        return "empty solutionSettings.hostType";
    return undefined;
}
exports.validateSettings = validateSettings;
function isValidProject(workspacePath) {
    if (!workspacePath)
        return false;
    try {
        const confFolderPath = path.resolve(workspacePath, `.${teamsfx_api_1.ConfigFolderName}`, "configs");
        const settingsFile = path.resolve(confFolderPath, teamsfx_api_1.ProjectSettingsFileName);
        const projectSettings = fs.readJsonSync(settingsFile);
        if (validateSettings(projectSettings))
            return false;
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidProject = isValidProject;
// TODO: add an async version
async function validateV1Project(workspacePath) {
    if (!workspacePath) {
        return "The workspace path cannot be empty.";
    }
    const v2ConfigFolder = path.resolve(workspacePath, `.${teamsfx_api_1.ConfigFolderName}`);
    if (await fs.pathExists(v2ConfigFolder)) {
        return `Folder '.${teamsfx_api_1.ConfigFolderName}' already exists.`;
    }
    const packageJsonPath = path.resolve(workspacePath, "package.json");
    let packageSettings;
    try {
        packageSettings = await fs.readJson(packageJsonPath);
    }
    catch (error) {
        return `Cannot read 'package.json'. ${error === null || error === void 0 ? void 0 : error.message}`;
    }
    if (!(packageSettings === null || packageSettings === void 0 ? void 0 : packageSettings.msteams)) {
        return "Teams Toolkit V1 settings cannot be found in 'package.json'.";
    }
    const manifestPath = path.resolve(workspacePath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.V1ManifestFileName);
    if (!(await fs.pathExists(manifestPath))) {
        return "The project should be created after version 1.2.0";
    }
    try {
        // Exclude Bot SSO project
        const envFilePath = path.resolve(workspacePath, ".env");
        const envFileContent = await fs.readFile(envFilePath, constants_1.ConstantString.UTF8Encoding);
        if (envFileContent.includes("connectionName")) {
            return `Bot sso project has not been supported.`;
        }
    }
    catch (e) {
        // If the project does not contain a valid .env file, it is still a valid v1 project
    }
    const archiveFolder = path.resolve(workspacePath, teamsfx_api_1.ArchiveFolderName);
    if (await fs.pathExists(archiveFolder)) {
        return `Archive folder '${teamsfx_api_1.ArchiveFolderName}' already exists. Rollback the project or remove '${teamsfx_api_1.ArchiveFolderName}' folder.`;
    }
    return undefined;
}
exports.validateV1Project = validateV1Project;
async function isMigrateFromV1Project(workspacePath) {
    var _a;
    if (!workspacePath)
        return false;
    try {
        const confFolderPath = path.resolve(workspacePath, `.${teamsfx_api_1.ConfigFolderName}`, "configs");
        const settingsFile = path.resolve(confFolderPath, teamsfx_api_1.ProjectSettingsFileName);
        const projectSettings = await fs.readJson(settingsFile);
        if (validateSettings(projectSettings))
            return false;
        return !!((_a = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings) === null || _a === void 0 ? void 0 : _a.migrateFromV1);
    }
    catch (e) {
        return false;
    }
}
exports.isMigrateFromV1Project = isMigrateFromV1Project;
function newEnvInfo(envName, config, state) {
    return {
        envName: envName !== null && envName !== void 0 ? envName : environment_1.environmentManager.getDefaultEnvName(),
        config: config !== null && config !== void 0 ? config : {
            manifest: {
                appName: {
                    short: "teamsfx_app",
                },
            },
        },
        state: state !== null && state !== void 0 ? state : new Map([[constants_2.GLOBAL_CONFIG, new teamsfx_api_1.ConfigMap()]]),
    };
}
exports.newEnvInfo = newEnvInfo;
function newEnvInfoV3(envName, config, state) {
    return {
        envName: envName !== null && envName !== void 0 ? envName : environment_1.environmentManager.getDefaultEnvName(),
        config: config !== null && config !== void 0 ? config : {
            manifest: {
                appName: {
                    short: "teamsfx_app",
                },
            },
        },
        state: state !== null && state !== void 0 ? state : { solution: {} },
    };
}
exports.newEnvInfoV3 = newEnvInfoV3;
function getLockFolder(projectPath) {
    return path.join(os.tmpdir(), `${teamsfx_api_1.ProductName}-${crypto_1.default.createHash("md5").update(projectPath).digest("hex")}`);
}
exports.getLockFolder = getLockFolder;
// flattens output/secrets fields in config map for backward compatibility
// e.g. { "a": { "output": {"b": 1}, "secrets": { "value": 9 } }, "c": 2 } will be converted to
// { "a": { "b": 1, "value": 9 }, "c": 2 }
function flattenConfigJson(configJson) {
    const config = {};
    for (const [k, v] of Object.entries(configJson)) {
        if (v instanceof Object) {
            const value = flattenConfigJson(v);
            if (k === "output" || k === "secrets") {
                for (const [k, v] of Object.entries(value)) {
                    config[k] = v;
                }
            }
            else {
                config[k] = value;
            }
        }
        else {
            config[k] = v;
        }
    }
    return config;
}
exports.flattenConfigJson = flattenConfigJson;
//# sourceMappingURL=tools.js.map