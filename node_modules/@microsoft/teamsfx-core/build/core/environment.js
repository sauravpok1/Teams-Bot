"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.environmentManager = exports.separateSecretDataV3 = exports.envPrefix = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importStar(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const dotenv = tslib_1.__importStar(require("dotenv"));
const __1 = require("..");
const constants_1 = require("../plugins/solution/fx-solution/constants");
const telemetry_1 = require("../common/telemetry");
const common_1 = require("../common");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const draft6MetaSchema = tslib_1.__importStar(require("ajv/dist/refs/json-schema-draft-06.json"));
const envConfigSchema = tslib_1.__importStar(require("@microsoft/teamsfx-api/build/schemas/envConfig.json"));
const constants_2 = require("../common/constants");
exports.envPrefix = "$env.";
class EnvironmentManager {
    constructor() {
        this.envNameRegex = /^[\w\d-_]+$/;
        this.envConfigNameRegex = /^config\.(?<envName>[\w\d-_]+)\.json$/i;
        this.envStateNameRegex = /^state\.(?<envName>[\w\d-_]+)\.json$/i;
        this.defaultEnvName = "dev";
        this.schema = "https://aka.ms/teamsfx-env-config-schema";
        this.envConfigDescription = `You can customize the TeamsFx config for different environments.` +
            ` Visit https://aka.ms/teamsfx-env-config to learn more about this.`;
        this.ajv = new ajv_1.default();
        this.ajv.addMetaSchema(draft6MetaSchema);
    }
    async loadEnvInfo(projectPath, cryptoProvider, envName, isV3 = false) {
        if (!(await fs_extra_1.default.pathExists(projectPath))) {
            return teamsfx_api_1.err(__1.PathNotExistError(projectPath));
        }
        envName = envName !== null && envName !== void 0 ? envName : this.getDefaultEnvName();
        const configResult = await this.loadEnvConfig(projectPath, envName);
        if (configResult.isErr()) {
            return teamsfx_api_1.err(configResult.error);
        }
        const stateResult = await this.loadEnvState(projectPath, envName, cryptoProvider, isV3);
        if (stateResult.isErr()) {
            return teamsfx_api_1.err(stateResult.error);
        }
        if (isV3)
            return teamsfx_api_1.ok({
                envName,
                config: configResult.value,
                state: stateResult.value,
            });
        else
            return teamsfx_api_1.ok({
                envName,
                config: configResult.value,
                state: stateResult.value,
            });
    }
    newEnvConfigData(appName) {
        const envConfig = {
            $schema: this.schema,
            description: this.envConfigDescription,
            manifest: {
                appName: {
                    short: appName,
                    full: `Full name for ${appName}`,
                },
            },
        };
        return envConfig;
    }
    async writeEnvConfig(projectPath, envConfig, envName) {
        if (!(await fs_extra_1.default.pathExists(projectPath))) {
            return teamsfx_api_1.err(__1.PathNotExistError(projectPath));
        }
        const envConfigsFolder = this.getEnvConfigsFolder(projectPath);
        if (!(await fs_extra_1.default.pathExists(envConfigsFolder))) {
            await fs_extra_1.default.ensureDir(envConfigsFolder);
        }
        envName = envName !== null && envName !== void 0 ? envName : this.getDefaultEnvName();
        const envConfigPath = this.getEnvConfigPath(envName, projectPath);
        try {
            await fs_extra_1.default.writeFile(envConfigPath, JSON.stringify(envConfig, null, 4));
        }
        catch (error) {
            return teamsfx_api_1.err(__1.WriteFileError(error));
        }
        return teamsfx_api_1.ok(envConfigPath);
    }
    async writeEnvState(envData, projectPath, cryptoProvider, envName, isV3) {
        if (!(await fs_extra_1.default.pathExists(projectPath))) {
            return teamsfx_api_1.err(__1.PathNotExistError(projectPath));
        }
        const envStatesFolder = this.getEnvStatesFolder(projectPath);
        if (!(await fs_extra_1.default.pathExists(envStatesFolder))) {
            await fs_extra_1.default.ensureDir(envStatesFolder);
        }
        envName = envName !== null && envName !== void 0 ? envName : this.getDefaultEnvName();
        const envFiles = this.getEnvStateFilesPath(envName, projectPath);
        const data = envData instanceof Map ? __1.mapToJson(envData) : envData;
        const secrets = isV3
            ? separateSecretDataV3(data)
            : __1.separateSecretData(data);
        this.encrypt(secrets, cryptoProvider);
        try {
            await fs_extra_1.default.writeFile(envFiles.envState, JSON.stringify(data, null, 4));
            await fs_extra_1.default.writeFile(envFiles.userDataFile, __1.serializeDict(secrets));
        }
        catch (error) {
            return teamsfx_api_1.err(__1.WriteFileError(error));
        }
        return teamsfx_api_1.ok(envFiles.envState);
    }
    async listEnvConfigs(projectPath) {
        if (!(await fs_extra_1.default.pathExists(projectPath))) {
            return teamsfx_api_1.err(__1.PathNotExistError(projectPath));
        }
        const envConfigsFolder = this.getEnvConfigsFolder(projectPath);
        if (!(await fs_extra_1.default.pathExists(envConfigsFolder))) {
            return teamsfx_api_1.ok([]);
        }
        const configFiles = await fs_extra_1.default.readdir(envConfigsFolder);
        const envNames = configFiles
            .map((file) => this.getEnvNameFromPath(file))
            .filter((name) => name !== null);
        return teamsfx_api_1.ok(envNames);
    }
    async checkEnvExist(projectPath, env) {
        var _a;
        const envList = await exports.environmentManager.listEnvConfigs(projectPath);
        if (envList.isErr()) {
            return teamsfx_api_1.err(envList.error);
        }
        if (((_a = envList.value) === null || _a === void 0 ? void 0 : _a.indexOf(env)) >= 0) {
            return teamsfx_api_1.ok(true);
        }
        else {
            return teamsfx_api_1.ok(false);
        }
    }
    isEnvConfig(projectPath, filePath) {
        const fileName = path_1.default.basename(filePath);
        const fileDirname = path_1.default.dirname(filePath);
        const configFolder = this.getEnvConfigsFolder(projectPath);
        const relativeFilePath = path_1.default.relative(configFolder, fileDirname);
        if (relativeFilePath !== "") {
            return false;
        }
        const match = fileName.match(exports.environmentManager.envConfigNameRegex);
        return match !== null;
    }
    getEnvConfigPath(envName, projectPath) {
        const basePath = this.getEnvConfigsFolder(projectPath);
        return path_1.default.resolve(basePath, teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envName));
    }
    getEnvStateFilesPath(envName, projectPath) {
        const basePath = this.getEnvStatesFolder(projectPath);
        const envState = path_1.default.resolve(basePath, teamsfx_api_1.EnvStateFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envName));
        const userDataFile = path_1.default.resolve(basePath, `${envName}.userdata`);
        return { envState: envState, userDataFile };
    }
    async loadEnvConfig(projectPath, envName) {
        const envConfigPath = this.getEnvConfigPath(envName, projectPath);
        if (!(await fs_extra_1.default.pathExists(envConfigPath))) {
            return teamsfx_api_1.err(__1.ProjectEnvNotExistError(envName));
        }
        const validate = this.ajv.compile(envConfigSchema);
        let data;
        try {
            data = await fs_extra_1.default.readFile(envConfigPath, constants_2.ConstantString.UTF8Encoding);
            // resolve environment variables
            data = this.expandEnvironmentVariables(data);
            data = JSON.parse(data);
        }
        catch (error) {
            return teamsfx_api_1.err(__1.InvalidEnvConfigError(envName, `Failed to read env config JSON: ${error}`));
        }
        if (validate(data)) {
            return teamsfx_api_1.ok(data);
        }
        return teamsfx_api_1.err(__1.InvalidEnvConfigError(envName, JSON.stringify(validate.errors)));
    }
    async loadEnvState(projectPath, envName, cryptoProvider, isV3 = false) {
        const envFiles = this.getEnvStateFilesPath(envName, projectPath);
        const userDataResult = await this.loadUserData(envFiles.userDataFile, cryptoProvider);
        if (userDataResult.isErr()) {
            return teamsfx_api_1.err(userDataResult.error);
        }
        const userData = userDataResult.value;
        if (!(await fs_extra_1.default.pathExists(envFiles.envState))) {
            const data = new Map([[constants_1.GLOBAL_CONFIG, new teamsfx_api_1.ConfigMap()]]);
            return teamsfx_api_1.ok(data);
        }
        const template = await fs_extra_1.default.readFile(envFiles.envState, { encoding: "utf-8" });
        const result = __1.replaceTemplateWithUserData(template, userData);
        const resultJson = JSON.parse(result);
        if (isV3)
            return teamsfx_api_1.ok(resultJson);
        const data = __1.objectToMap(resultJson);
        return teamsfx_api_1.ok(data);
    }
    expandEnvironmentVariables(templateContent) {
        if (!templateContent) {
            return templateContent;
        }
        return common_1.compileHandlebarsTemplateString(templateContent, { $env: process.env });
    }
    getEnvNameFromPath(filePath) {
        const match = this.envConfigNameRegex.exec(filePath);
        if (match != null && match.groups != null) {
            return match.groups.envName;
        }
        return null;
    }
    getConfigFolder(projectPath) {
        return path_1.default.resolve(projectPath, `.${teamsfx_api_1.ConfigFolderName}`);
    }
    getStatesFolder(projectPath) {
        return path_1.default.resolve(this.getConfigFolder(projectPath), teamsfx_api_1.StatesFolderName);
    }
    getEnvStatesFolder(projectPath) {
        return this.getStatesFolder(projectPath);
    }
    getEnvConfigsFolder(projectPath) {
        return path_1.default.resolve(this.getConfigFolder(projectPath), teamsfx_api_1.InputConfigsFolderName);
    }
    async loadUserData(userDataPath, cryptoProvider) {
        if (!(await fs_extra_1.default.pathExists(userDataPath))) {
            return teamsfx_api_1.ok({});
        }
        const content = await fs_extra_1.default.readFile(userDataPath, "UTF-8");
        const secrets = dotenv.parse(content);
        const res = this.decrypt(secrets, cryptoProvider);
        if (res.isErr()) {
            const fxError = res.error;
            const fileName = path_1.basename(userDataPath);
            fxError.message = `Project update failed because of ${fxError.name}(file:${fileName}):${fxError.message}, if your local file '*.userdata' is not modified, please report to us by click 'Report Issue' button.`;
            fxError.userData = `file: ${fileName}\n------------FILE START--------\n${content}\n------------FILE END----------`;
            telemetry_1.sendTelemetryErrorEvent(telemetry_1.Component.core, telemetry_1.TelemetryEvent.DecryptUserdata, fxError);
        }
        return res;
    }
    encrypt(secrets, cryptoProvider) {
        for (const secretKey of Object.keys(secrets)) {
            if (!__1.dataNeedEncryption(secretKey)) {
                continue;
            }
            const encryptedSecret = cryptoProvider.encrypt(secrets[secretKey]);
            // always success
            if (encryptedSecret.isOk()) {
                secrets[secretKey] = encryptedSecret.value;
            }
        }
        return teamsfx_api_1.ok(secrets);
    }
    decrypt(secrets, cryptoProvider) {
        for (const secretKey of Object.keys(secrets)) {
            if (!__1.dataNeedEncryption(secretKey)) {
                continue;
            }
            const secretValue = secrets[secretKey];
            const plaintext = cryptoProvider.decrypt(secretValue);
            if (plaintext.isErr()) {
                return teamsfx_api_1.err(plaintext.error);
            }
            secrets[secretKey] = plaintext.value;
        }
        return teamsfx_api_1.ok(secrets);
    }
    getDefaultEnvName() {
        return this.defaultEnvName;
    }
}
function separateSecretDataV3(envState) {
    const res = {};
    for (const key of Object.keys(envState)) {
        const config = envState[key];
        if (config.secretFields && config.secretFields.length > 0) {
            config.secretFields.forEach((f) => {
                const keyName = `${key}.${f}`;
                res[keyName] = config[f];
                config[f] = `{{${keyName}}}`;
            });
        }
    }
    return res;
}
exports.separateSecretDataV3 = separateSecretDataV3;
exports.environmentManager = new EnvironmentManager();
//# sourceMappingURL=environment.js.map