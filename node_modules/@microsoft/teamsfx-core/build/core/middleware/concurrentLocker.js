// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrentLockerMW = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const proper_lockfile_1 = require("proper-lockfile");
const __1 = require("..");
const __2 = require("../..");
const telemetry_1 = require("../../common/telemetry");
const callback_1 = require("../callback");
const error_1 = require("../error");
const tools_1 = require("../tools");
const projectSettingsLoader_1 = require("./projectSettingsLoader");
let doingTask = undefined;
const ConcurrentLockerMW = async (ctx, next) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const ignoreLock = projectSettingsLoader_1.shouldIgnored(ctx);
    if (ignoreLock) {
        await next();
        return;
    }
    if (!inputs.projectPath) {
        ctx.result = teamsfx_api_1.err(error_1.NoProjectOpenedError());
        return;
    }
    if (!(await fs.pathExists(inputs.projectPath))) {
        ctx.result = teamsfx_api_1.err(error_1.PathNotExistError(inputs.projectPath));
        return;
    }
    const configFolder = path.join(inputs.projectPath, `.${teamsfx_api_1.ConfigFolderName}`);
    if (!(await fs.pathExists(configFolder))) {
        ctx.result = teamsfx_api_1.err(error_1.InvalidProjectError());
        return;
    }
    const lockFileDir = tools_1.getLockFolder(inputs.projectPath);
    const lockfilePath = path.join(lockFileDir, `${teamsfx_api_1.ConfigFolderName}.lock`);
    await fs.ensureDir(lockFileDir);
    const taskName = `${ctx.method} ${ctx.method === "executeUserTask" ? ctx.arguments[0].method : ""}`;
    let acquired = false;
    let retryNum = 0;
    for (let i = 0; i < 10; ++i) {
        try {
            await proper_lockfile_1.lock(configFolder, { lockfilePath: lockfilePath });
            acquired = true;
            __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.debug(`[core] success to acquire lock for task ${taskName} on: ${configFolder}`);
            for (const f of callback_1.CallbackRegistry.get(teamsfx_api_1.CoreCallbackEvent.lock)) {
                f();
            }
            try {
                doingTask = taskName;
                if (retryNum > 0) {
                    // failed for some try and finally success
                    telemetry_1.sendTelemetryErrorEvent(error_1.CoreSource, "concurrent-operation", new teamsfx_api_1.ConcurrentError(error_1.CoreSource), { retry: retryNum + "", acquired: "true", doing: doingTask, todo: taskName });
                }
                await next();
            }
            finally {
                await proper_lockfile_1.unlock(configFolder, { lockfilePath: lockfilePath });
                for (const f of callback_1.CallbackRegistry.get(teamsfx_api_1.CoreCallbackEvent.unlock)) {
                    f();
                }
                __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.debug(`[core] lock released on ${configFolder}`);
                doingTask = undefined;
            }
            break;
        }
        catch (e) {
            if (e["code"] === "ELOCKED") {
                await __2.waitSeconds(1);
                ++retryNum;
                continue;
            }
            throw e;
        }
    }
    if (!acquired) {
        __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.error(`[core] failed to acquire lock for task ${taskName} on: ${configFolder}`);
        // failed for 10 times and finally failed
        telemetry_1.sendTelemetryErrorEvent(error_1.CoreSource, "concurrent-operation", new teamsfx_api_1.ConcurrentError(error_1.CoreSource), {
            retry: retryNum + "",
            acquired: "false",
            doing: doingTask || "",
            todo: taskName,
        });
        ctx.result = teamsfx_api_1.err(new teamsfx_api_1.ConcurrentError(error_1.CoreSource));
    }
};
exports.ConcurrentLockerMW = ConcurrentLockerMW;
//# sourceMappingURL=concurrentLocker.js.map