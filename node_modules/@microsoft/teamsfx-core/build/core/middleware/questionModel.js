"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsForMigrateV1Project = exports.getQuestionsV2 = exports.getQuestionsForUserTaskV2 = exports.getQuestionsForCreateProjectV2 = exports.getQuestionsForCreateProjectV3 = exports.getQuestionsForInit = exports.getQuestionsForPublish = exports.getQuestionsForLocalProvision = exports.getQuestionsForDeploy = exports.getQuestionsForProvision = exports.getQuestionsForAddResource = exports.getQuestionsForAddModule = exports.getQuestionsForScaffold = exports.traverseToCollectPasswordNodes = exports.desensitize = exports.QuestionModelMW = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const __1 = require("..");
const common_1 = require("../../common");
const question_1 = require("../question");
const SolutionPluginContainer_1 = require("../SolutionPluginContainer");
const projectSettingsLoader_1 = require("./projectSettingsLoader");
const projectSettingsLoaderV3_1 = require("./projectSettingsLoaderV3");
/**
 * This middleware will help to collect input from question flow
 */
const QuestionModelMW = async (ctx, next) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const method = ctx.method;
    const core = ctx.self;
    let getQuestionRes = teamsfx_api_1.ok(undefined);
    if (method === "createProjectV2") {
        getQuestionRes = await core._getQuestionsForCreateProjectV2(inputs);
    }
    else if (method === "createProjectV3") {
        getQuestionRes = await core._getQuestionsForCreateProjectV3(inputs);
    }
    else if (method === "migrateV1Project") {
        const res = await (__1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.ui.showMessage("warn", "We will update your project to make it compatible with the latest Teams Toolkit. We recommend to use git for better tracking file changes before migration. Your original project files will be archived to the .archive folder. You can refer to .archive.log which provides detailed information about the archive process.", true, "OK"));
        const answer = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
        if (!answer || answer != "OK") {
            __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.info(`[core] V1 project migration was canceled.`);
            ctx.result = teamsfx_api_1.ok(null);
            return;
        }
        getQuestionRes = await core._getQuestionsForMigrateV1Project(inputs);
    }
    else if (method === "init" || method === "_init") {
        getQuestionRes = await core._getQuestionsForInit(inputs);
    }
    else if ([
        "addModule",
        "scaffold",
        "addResource",
        "provisionResourcesV3",
        "localDebugV3",
        "deployArtifactsV3",
        "publishApplicationV3",
    ].includes(method || "")) {
        const solutionV3 = ctx.solutionV3;
        const contextV2 = ctx.contextV2;
        if (solutionV3 && contextV2) {
            if (method === "addModule") {
                getQuestionRes = await core._getQuestionsForAddModule(inputs, solutionV3, contextV2);
            }
            else if (method === "scaffold") {
                getQuestionRes = await core._getQuestionsForScaffold(inputs, solutionV3, contextV2);
            }
            else if (method === "addResource") {
                getQuestionRes = await core._getQuestionsForAddResource(inputs, solutionV3, contextV2);
            }
            else if (method === "provisionResourcesV3") {
                getQuestionRes = await core._getQuestionsForProvision(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
            else if (method === "localDebugV3") {
                getQuestionRes = await core._getQuestionsForLocalProvision(inputs, solutionV3, contextV2, ctx.localSettings);
            }
            else if (method === "deployArtifactsV3") {
                getQuestionRes = await core._getQuestionsForDeploy(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
            else if (method === "publishApplicationV3") {
                getQuestionRes = await core._getQuestionsForPublish(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
        }
    }
    else {
        if (ctx.solutionV2 && ctx.contextV2) {
            const solution = ctx.solutionV2;
            const context = ctx.contextV2;
            if (solution && context) {
                if (method === "provisionResources" || method === "provisionResourcesV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.provision, inputs, ctx.envInfoV2);
                }
                else if (method === "localDebug" || method === "localDebugV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.debug, inputs, ctx.envInfoV2);
                }
                else if (method === "deployArtifacts" || method === "deployArtifactsV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.deploy, inputs, ctx.envInfoV2);
                }
                else if (method === "publishApplication" || method === "publishApplicationV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.publish, inputs, ctx.envInfoV2);
                }
                else if (method === "executeUserTask") {
                    const func = ctx.arguments[0];
                    getQuestionRes = await core._getQuestionsForUserTask(context, solution, func, inputs, ctx.envInfoV2);
                }
                else if (method === "grantPermission") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.grantPermission, inputs, ctx.envInfoV2);
                }
            }
        }
    }
    if (getQuestionRes.isErr()) {
        __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.error(`[core] failed to get questions for ${method}: ${getQuestionRes.error.message}`);
        ctx.result = teamsfx_api_1.err(getQuestionRes.error);
        return;
    }
    __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.debug(`[core] success to get questions for ${method}`);
    const node = getQuestionRes.value;
    if (node) {
        const res = await teamsfx_api_1.traverse(node, inputs, __1.TOOLS.ui, __1.TOOLS.telemetryReporter);
        if (res.isErr()) {
            __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.debug(`[core] failed to run question model for ${method}`);
            ctx.result = teamsfx_api_1.err(res.error);
            return;
        }
        const desensitized = desensitize(node, inputs);
        __1.TOOLS === null || __1.TOOLS === void 0 ? void 0 : __1.TOOLS.logProvider.info(`[core] success to run question model for ${method}, answers:${JSON.stringify(desensitized)}`);
    }
    await next();
};
exports.QuestionModelMW = QuestionModelMW;
function desensitize(node, input) {
    const copy = common_1.deepCopy(input);
    const names = new Set();
    traverseToCollectPasswordNodes(node, names);
    for (const name of names) {
        copy[name] = "******";
    }
    return copy;
}
exports.desensitize = desensitize;
function traverseToCollectPasswordNodes(node, names) {
    if (node.data.type === "text" && node.data.password === true) {
        names.add(node.data.name);
    }
    for (const child of node.children || []) {
        traverseToCollectPasswordNodes(child, names);
    }
}
exports.traverseToCollectPasswordNodes = traverseToCollectPasswordNodes;
//////V3 questions
async function getQuestionsForScaffold(inputs, solution, context) {
    if (solution.getQuestionsForScaffold) {
        const res = await solution.getQuestionsForScaffold(context, inputs);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForScaffold = getQuestionsForScaffold;
async function getQuestionsForAddModule(inputs, solution, context) {
    if (solution.getQuestionsForAddModule) {
        const res = await solution.getQuestionsForAddModule(context, inputs);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForAddModule = getQuestionsForAddModule;
async function getQuestionsForAddResource(inputs, solution, context) {
    if (solution.getQuestionsForAddResource) {
        const res = await solution.getQuestionsForAddResource(context, inputs);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForAddResource = getQuestionsForAddResource;
async function getQuestionsForProvision(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForProvision) {
        const res = await solution.getQuestionsForProvision(context, inputs, __1.TOOLS.tokenProvider, envInfo);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForProvision = getQuestionsForProvision;
async function getQuestionsForDeploy(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForDeploy) {
        const res = await solution.getQuestionsForDeploy(context, inputs, envInfo, __1.TOOLS.tokenProvider);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForDeploy = getQuestionsForDeploy;
async function getQuestionsForLocalProvision(inputs, solution, context, localSettings) {
    if (solution.getQuestionsForLocalProvision) {
        const res = await solution.getQuestionsForLocalProvision(context, inputs, __1.TOOLS.tokenProvider, localSettings);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForLocalProvision = getQuestionsForLocalProvision;
async function getQuestionsForPublish(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForPublish) {
        const res = await solution.getQuestionsForPublish(context, inputs, envInfo, __1.TOOLS.tokenProvider.appStudioToken);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForPublish = getQuestionsForPublish;
async function getQuestionsForInit(inputs) {
    if (inputs.projectPath) {
        const projectSettingsPath = projectSettingsLoaderV3_1.getProjectSettingsPath(inputs.projectPath);
        if (await fs_extra_1.default.pathExists(projectSettingsPath)) {
            const res = await __1.TOOLS.ui.showMessage("warn", "projectSettings.json already exists, 'init' operation will replace it, please confirm!", true, "Confirm");
            if (!(res.isOk() && res.value === "Confirm")) {
                return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
            }
        }
    }
    const node = new teamsfx_api_1.QTreeNode({ type: "group" });
    const globalSolutions = SolutionPluginContainer_1.getGlobalSolutionsV3();
    const capQuestion = question_1.createCapabilityQuestion();
    const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    node.addChild(capNode);
    const context = __1.createV2Context(__1.newProjectSettings());
    for (const solution of globalSolutions) {
        if (solution.getQuestionsForInit) {
            const res = await solution.getQuestionsForInit(context, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const solutionNode = res.value;
                if (solutionNode.data)
                    capNode.addChild(solutionNode);
            }
        }
    }
    node.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionAppName));
    return teamsfx_api_1.ok(node.trim());
}
exports.getQuestionsForInit = getQuestionsForInit;
async function getQuestionsForCreateProjectV3(inputs) {
    const node = new teamsfx_api_1.QTreeNode(question_1.getCreateNewOrFromSampleQuestion(inputs.platform));
    // create new
    const createNew = new teamsfx_api_1.QTreeNode({ type: "group" });
    node.addChild(createNew);
    createNew.condition = { equals: question_1.ScratchOptionYes.id };
    // capabilities
    const capQuestion = question_1.createCapabilityQuestion();
    const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    createNew.addChild(capNode);
    const globalSolutions = SolutionPluginContainer_1.getGlobalSolutionsV3();
    const context = __1.createV2Context(__1.newProjectSettings());
    for (const solution of globalSolutions) {
        if (solution.getQuestionsForInit) {
            const res = await solution.getQuestionsForInit(context, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const solutionNode = res.value;
                if (solutionNode.data)
                    capNode.addChild(solutionNode);
            }
        }
    }
    // Language
    const programmingLanguage = new teamsfx_api_1.QTreeNode(question_1.ProgrammingLanguageQuestion);
    programmingLanguage.condition = { minItems: 1 };
    createNew.addChild(programmingLanguage);
    // only CLI need folder input
    if (inputs.platform === teamsfx_api_1.Platform.CLI) {
        createNew.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionRootFolder));
    }
    createNew.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionAppName));
    // create from sample
    const sampleNode = new teamsfx_api_1.QTreeNode(question_1.SampleSelect);
    node.addChild(sampleNode);
    sampleNode.condition = { equals: question_1.ScratchOptionNo.id };
    if (inputs.platform !== teamsfx_api_1.Platform.VSCode) {
        sampleNode.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionRootFolder));
    }
    return teamsfx_api_1.ok(node.trim());
}
exports.getQuestionsForCreateProjectV3 = getQuestionsForCreateProjectV3;
//////V2 questions
async function getQuestionsForCreateProjectV2(inputs) {
    const node = new teamsfx_api_1.QTreeNode(question_1.getCreateNewOrFromSampleQuestion(inputs.platform));
    // create new
    const createNew = new teamsfx_api_1.QTreeNode({ type: "group" });
    node.addChild(createNew);
    createNew.condition = { equals: question_1.ScratchOptionYes.id };
    // capabilities
    const capQuestion = question_1.createCapabilityQuestion();
    const capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    createNew.addChild(capNode);
    const globalSolutions = await SolutionPluginContainer_1.getAllSolutionPluginsV2();
    const context = __1.createV2Context(__1.newProjectSettings());
    for (const solutionPlugin of globalSolutions) {
        let res = teamsfx_api_1.ok(undefined);
        const v2plugin = solutionPlugin;
        res = v2plugin.getQuestionsForScaffolding
            ? await v2plugin.getQuestionsForScaffolding(context, inputs)
            : teamsfx_api_1.ok(undefined);
        if (res.isErr())
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(res.error, __1.CoreSource, "QuestionModelFail"));
        if (res.value) {
            const solutionNode = Array.isArray(res.value)
                ? res.value
                : [res.value];
            for (const node of solutionNode) {
                if (node.data)
                    capNode.addChild(node);
            }
        }
    }
    // Language
    const programmingLanguage = new teamsfx_api_1.QTreeNode(question_1.ProgrammingLanguageQuestion);
    programmingLanguage.condition = { minItems: 1 };
    createNew.addChild(programmingLanguage);
    // only CLI need folder input
    if (teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
        createNew.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionRootFolder));
    }
    createNew.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionAppName));
    // create from sample
    const sampleNode = new teamsfx_api_1.QTreeNode(question_1.SampleSelect);
    node.addChild(sampleNode);
    sampleNode.condition = { equals: question_1.ScratchOptionNo.id };
    if (inputs.platform !== teamsfx_api_1.Platform.VSCode) {
        sampleNode.addChild(new teamsfx_api_1.QTreeNode(question_1.QuestionRootFolder));
    }
    return teamsfx_api_1.ok(node.trim());
}
exports.getQuestionsForCreateProjectV2 = getQuestionsForCreateProjectV2;
async function getQuestionsForUserTaskV2(ctx, solution, func, inputs, envInfo) {
    const namespace = func.namespace;
    const array = namespace ? namespace.split("/") : [];
    if (namespace && "" !== namespace && array.length > 0) {
        let res = teamsfx_api_1.ok(undefined);
        const solutionV2 = solution;
        if (solutionV2.getQuestionsForUserTask) {
            res = await solutionV2.getQuestionsForUserTask(ctx, inputs, func, envInfo, __1.TOOLS.tokenProvider);
        }
        if (res.isOk()) {
            if (res.value) {
                const node = res.value.trim();
                return teamsfx_api_1.ok(node);
            }
        }
        return res;
    }
    return teamsfx_api_1.err(__1.FunctionRouterError(func));
}
exports.getQuestionsForUserTaskV2 = getQuestionsForUserTaskV2;
async function getQuestionsV2(ctx, solution, stage, inputs, envInfo) {
    if (stage !== teamsfx_api_1.Stage.create) {
        let res = teamsfx_api_1.ok(undefined);
        const solutionV2 = solution;
        if (solutionV2.getQuestions) {
            inputs.stage = stage;
            res = await solutionV2.getQuestions(ctx, inputs, envInfo, __1.TOOLS.tokenProvider);
        }
        if (res.isErr())
            return res;
        if (res.value) {
            const node = res.value;
            if (node.data) {
                return teamsfx_api_1.ok(node.trim());
            }
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsV2 = getQuestionsV2;
async function getQuestionsForMigrateV1Project(inputs) {
    const node = new teamsfx_api_1.QTreeNode({ type: "group" });
    const globalSolutions = await SolutionPluginContainer_1.getAllSolutionPlugins();
    const solutionContext = await projectSettingsLoader_1.newSolutionContext(__1.TOOLS, inputs);
    for (const v of globalSolutions) {
        if (v.getQuestions) {
            const res = await v.getQuestions(teamsfx_api_1.Stage.migrateV1, solutionContext);
            if (res.isErr())
                return res;
            if (res.value) {
                const solutionNode = res.value;
                solutionNode.condition = { equals: v.name };
                if (solutionNode.data)
                    node.addChild(solutionNode);
            }
        }
    }
    const defaultAppNameFunc = new teamsfx_api_1.QTreeNode(question_1.DefaultAppNameFunc);
    node.addChild(defaultAppNameFunc);
    const appNameQuestion = new teamsfx_api_1.QTreeNode(question_1.QuestionV1AppName);
    appNameQuestion.condition = {
        validFunc: (input) => (!input ? undefined : "App name is auto generated."),
    };
    defaultAppNameFunc.addChild(appNameQuestion);
    return teamsfx_api_1.ok(node.trim());
}
exports.getQuestionsForMigrateV1Project = getQuestionsForMigrateV1Project;
//# sourceMappingURL=questionModel.js.map