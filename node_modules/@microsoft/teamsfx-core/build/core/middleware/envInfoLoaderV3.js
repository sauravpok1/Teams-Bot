"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvInfoLoaderMW_V3 = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const __1 = require("..");
const crypto_1 = require("../crypto");
const environment_1 = require("../environment");
const error_1 = require("../error");
const envInfoLoader_1 = require("./envInfoLoader");
const projectSettingsLoader_1 = require("./projectSettingsLoader");
function EnvInfoLoaderMW_V3(skip) {
    return async (ctx, next) => {
        if (projectSettingsLoader_1.shouldIgnored(ctx)) {
            await next();
            return;
        }
        const inputs = ctx.arguments[ctx.arguments.length - 1];
        if (!ctx.projectSettings) {
            ctx.result = teamsfx_api_1.err(error_1.ProjectSettingsUndefinedError());
            return;
        }
        if (!inputs.projectPath) {
            ctx.result = teamsfx_api_1.err(error_1.NoProjectOpenedError());
            return;
        }
        // make sure inputs.env always has value so telemetry can use it.
        const envRes = await envInfoLoader_1.getTargetEnvName(skip, inputs, ctx);
        if (envRes.isErr()) {
            ctx.result = teamsfx_api_1.err(envRes.error);
            return;
        }
        inputs.env = envRes.value;
        const result = await loadEnvInfoV3(inputs, ctx.projectSettings, inputs.env, skip || inputs.ignoreEnvInfo);
        if (result.isErr()) {
            ctx.result = teamsfx_api_1.err(result.error);
            return;
        }
        ctx.envInfoV3 = result.value;
        await next();
    };
}
exports.EnvInfoLoaderMW_V3 = EnvInfoLoaderMW_V3;
async function loadEnvInfoV3(inputs, projectSettings, targetEnvName, ignoreEnvInfo = false) {
    const cryptoProvider = new crypto_1.LocalCrypto(projectSettings.projectId);
    let envInfo;
    // in pre-multi-env case, envInfo is always loaded.
    if (ignoreEnvInfo) {
        envInfo = __1.newEnvInfoV3();
    }
    else {
        // ensure backwards compatibility:
        // project id will be generated for previous TeamsFx project.
        // Decrypting the secrets in *.userdata with generated project id works because secrets doesn't have prefix.
        const envDataResult = await environment_1.environmentManager.loadEnvInfo(inputs.projectPath, cryptoProvider, targetEnvName, true);
        if (envDataResult.isErr()) {
            return teamsfx_api_1.err(envDataResult.error);
        }
        envInfo = envDataResult.value;
    }
    return teamsfx_api_1.ok(envInfo);
}
//# sourceMappingURL=envInfoLoaderV3.js.map