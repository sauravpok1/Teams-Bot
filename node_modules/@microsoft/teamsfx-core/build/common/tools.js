"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllowedAppIds = exports.redactObject = exports.IsSimpleAuthEnabled = exports.getHashedEnv = exports.isSPFxProject = exports.getUuid = exports.waitSeconds = exports.parseFromResourceId = exports.getSubscriptionIdFromResourceId = exports.getResourceGroupNameFromResourceId = exports.getSiteNameFromResourceId = exports.getStorageAccountNameFromResourceId = exports.copyFiles = exports.getAppStudioEndpoint = exports.getAppDirectory = exports.compileHandlebarsTemplateString = exports.generateBicepFromFile = exports.getRootDirectory = exports.isRemoteCollaborateEnabled = exports.isBicepEnvCheckerEnabled = exports.isArmSupportEnabled = exports.isMultiEnvEnabled = exports.isFeatureFlagEnabled = exports.getResourceGroupInPortal = exports.askSubscription = exports.isCheckAccountError = exports.isUserCancelError = exports.getStrings = exports.deepCopy = exports.serializeDict = exports.replaceTemplateWithUserData = exports.convertDotenvToEmbeddedJson = exports.separateSecretData = exports.dataNeedEncryption = exports.AzurePortalUrl = exports.CryptoDataMatchers = exports.objectToConfigMap = exports.objectToMap = exports.mapToJson = exports.ensureUniqueFolder = exports.npmInstall = exports.Executor = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const child_process_1 = require("child_process");
const fs = tslib_1.__importStar(require("fs-extra"));
const Handlebars = tslib_1.__importStar(require("handlebars"));
const path = tslib_1.__importStar(require("path"));
const util_1 = require("util");
const uuid = tslib_1.__importStar(require("uuid"));
const folder_1 = require("../folder");
const constants_1 = require("./constants");
const crypto = tslib_1.__importStar(require("crypto"));
const os = tslib_1.__importStar(require("os"));
const error_1 = require("../core/error");
const constants_2 = require("../plugins/solution/fx-solution/constants");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
Handlebars.registerHelper("contains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) > -1 ? this : "";
});
Handlebars.registerHelper("notContains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) == -1 ? this : "";
});
exports.Executor = {
    async execCommandAsync(command, options) {
        const execAsync = util_1.promisify(child_process_1.exec);
        return await execAsync(command, options);
    },
};
async function npmInstall(path) {
    await exports.Executor.execCommandAsync("npm install", {
        cwd: path,
    });
}
exports.npmInstall = npmInstall;
async function ensureUniqueFolder(folderPath) {
    let folderId = 1;
    let testFolder = folderPath;
    let pathExists = await fs.pathExists(testFolder);
    while (pathExists) {
        testFolder = `${folderPath}${folderId}`;
        folderId++;
        pathExists = await fs.pathExists(testFolder);
    }
    return testFolder;
}
exports.ensureUniqueFolder = ensureUniqueFolder;
/**
 * Convert a `Map` to a Json recursively.
 * @param {Map} map to convert.
 * @returns {Json} converted Json.
 */
function mapToJson(map) {
    if (!map)
        return {};
    const out = {};
    for (const entry of map.entries()) {
        if (entry[1] instanceof Map) {
            out[entry[0]] = mapToJson(entry[1]);
        }
        else {
            out[entry[0]] = entry[1];
        }
    }
    return out;
}
exports.mapToJson = mapToJson;
/**
 * Convert an `Object` to a Map recursively
 * @param {Json} Json to convert.
 * @returns {Map} converted Json.
 */
function objectToMap(o) {
    const m = new Map();
    for (const entry of Object.entries(o)) {
        if (entry[1] instanceof Array) {
            m.set(entry[0], entry[1]);
        }
        else if (entry[1] instanceof Object) {
            m.set(entry[0], objectToConfigMap(entry[1]));
        }
        else {
            m.set(entry[0], entry[1]);
        }
    }
    return m;
}
exports.objectToMap = objectToMap;
/**
 * @param {Json} Json to convert.
 * @returns {Map} converted Json.
 */
function objectToConfigMap(o) {
    const m = new teamsfx_api_1.ConfigMap();
    if (o) {
        for (const entry of Object.entries(o)) {
            {
                m.set(entry[0], entry[1]);
            }
        }
    }
    return m;
}
exports.objectToConfigMap = objectToConfigMap;
const SecretDataMatchers = [
    "fx-resource-aad-app-for-teams.clientSecret",
    "fx-resource-simple-auth.filePath",
    "fx-resource-simple-auth.environmentVariableParams",
    "fx-resource-local-debug.*",
    "fx-resource-bot.botPassword",
    "fx-resource-apim.apimClientAADClientSecret",
    "fx-resource-azure-sql.adminPassword",
];
exports.CryptoDataMatchers = new Set([
    "fx-resource-aad-app-for-teams.clientSecret",
    "fx-resource-aad-app-for-teams.local_clientSecret",
    "fx-resource-simple-auth.environmentVariableParams",
    "fx-resource-bot.botPassword",
    "fx-resource-bot.localBotPassword",
    "fx-resource-apim.apimClientAADClientSecret",
    "fx-resource-azure-sql.adminPassword",
]);
exports.AzurePortalUrl = "https://portal.azure.com";
/**
 * Only data related to secrets need encryption.
 * @param key - the key name of data in user data file
 * @returns whether it needs encryption
 */
function dataNeedEncryption(key) {
    return exports.CryptoDataMatchers.has(key);
}
exports.dataNeedEncryption = dataNeedEncryption;
function separateSecretData(configJson) {
    const res = {};
    for (const matcher of SecretDataMatchers) {
        const splits = matcher.split(".");
        const resourceId = splits[0];
        const item = splits[1];
        const resourceConfig = configJson[resourceId];
        if (!resourceConfig)
            continue;
        if ("*" !== item) {
            const configValue = resourceConfig[item];
            if (configValue) {
                const keyName = `${resourceId}.${item}`;
                res[keyName] = configValue;
                resourceConfig[item] = `{{${keyName}}}`;
            }
        }
        else {
            for (const itemName of Object.keys(resourceConfig)) {
                const configValue = resourceConfig[itemName];
                if (configValue !== undefined) {
                    const keyName = `${resourceId}.${itemName}`;
                    res[keyName] = configValue;
                    resourceConfig[itemName] = `{{${keyName}}}`;
                }
            }
        }
    }
    return res;
}
exports.separateSecretData = separateSecretData;
function convertDotenvToEmbeddedJson(dict) {
    const result = {};
    for (const key of Object.keys(dict)) {
        const array = key.split(".");
        let obj = result;
        for (let i = 0; i < array.length - 1; ++i) {
            const subKey = array[i];
            let subObj = obj[subKey];
            if (!subObj) {
                subObj = {};
                obj[subKey] = subObj;
            }
            obj = subObj;
        }
        obj[array[array.length - 1]] = dict[key];
    }
    return result;
}
exports.convertDotenvToEmbeddedJson = convertDotenvToEmbeddedJson;
function replaceTemplateWithUserData(template, userData) {
    const view = convertDotenvToEmbeddedJson(userData);
    mustache_1.default.escape = (t) => {
        if (!t) {
            return t;
        }
        const str = JSON.stringify(t);
        return str.substr(1, str.length - 2);
        // return t;
    };
    const result = mustache_1.default.render(template, view);
    return result;
}
exports.replaceTemplateWithUserData = replaceTemplateWithUserData;
function serializeDict(dict) {
    const array = [];
    for (const key of Object.keys(dict)) {
        const value = dict[key];
        array.push(`${key}=${value}`);
    }
    return array.join("\n");
}
exports.serializeDict = serializeDict;
const deepCopy = (target) => {
    if (target === null) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach((v) => {
            cp.push(v);
        });
        return cp.map((n) => exports.deepCopy(n));
    }
    if (typeof target === "object" && target !== {}) {
        const cp = Object.assign({}, target);
        Object.keys(cp).forEach((k) => {
            cp[k] = exports.deepCopy(cp[k]);
        });
        return cp;
    }
    return target;
};
exports.deepCopy = deepCopy;
function getStrings() {
    const filepath = path.resolve(folder_1.getResourceFolder(), "strings.json");
    return fs.readJSONSync(filepath);
}
exports.getStrings = getStrings;
function isUserCancelError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === "User Cancel" ||
        errorName === getStrings().solution.CancelProvision ||
        errorName === "UserCancel");
}
exports.isUserCancelError = isUserCancelError;
function isCheckAccountError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === constants_2.SolutionError.TeamsAppTenantIdNotRight ||
        errorName === constants_2.SolutionError.SubscriptionNotFound);
}
exports.isCheckAccountError = isCheckAccountError;
async function askSubscription(azureAccountProvider, ui, activeSubscriptionId) {
    const subscriptions = await azureAccountProvider.listSubscriptions();
    if (subscriptions.length === 0) {
        return teamsfx_api_1.err(teamsfx_api_1.returnUserError(new Error("Failed to find a subscription."), "Core", "NoSubscriptionFound"));
    }
    let resultSub = subscriptions.find((sub) => sub.subscriptionId === activeSubscriptionId);
    if (activeSubscriptionId === undefined || resultSub === undefined) {
        let selectedSub = undefined;
        if (subscriptions.length === 1) {
            selectedSub = subscriptions[0];
        }
        else {
            const options = subscriptions.map((sub) => {
                return {
                    id: sub.subscriptionId,
                    label: sub.subscriptionName,
                    data: sub.tenantId,
                };
            });
            const askRes = await ui.selectOption({
                name: "subscription",
                title: "Select a subscription",
                options: options,
                returnObject: true,
            });
            if (askRes.isErr())
                return teamsfx_api_1.err(askRes.error);
            const subItem = askRes.value.result;
            selectedSub = {
                subscriptionId: subItem.id,
                subscriptionName: subItem.label,
                tenantId: subItem.data,
            };
        }
        if (selectedSub === undefined) {
            return teamsfx_api_1.err(teamsfx_api_1.returnSystemError(new Error("Subscription not found"), "Core", "NoSubscriptionFound"));
        }
        resultSub = selectedSub;
    }
    return teamsfx_api_1.ok(resultSub);
}
exports.askSubscription = askSubscription;
function getResourceGroupInPortal(subscriptionId, tenantId, resourceGroupName) {
    if (subscriptionId && tenantId && resourceGroupName) {
        return `${exports.AzurePortalUrl}/#@${tenantId}/resource/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}`;
    }
    else {
        return undefined;
    }
}
exports.getResourceGroupInPortal = getResourceGroupInPortal;
// Determine whether feature flag is enabled based on environment variable setting
function isFeatureFlagEnabled(featureFlagName, defaultValue = false) {
    const flag = process.env[featureFlagName];
    if (flag === undefined) {
        return defaultValue; // allows consumer to set a default value when environment variable not set
    }
    else {
        return flag === "1" || flag.toLowerCase() === "true"; // can enable feature flag by set environment variable value to "1" or "true"
    }
}
exports.isFeatureFlagEnabled = isFeatureFlagEnabled;
/**
 * @deprecated Please DO NOT use this method any more, it will be removed in near future.
 */
function isMultiEnvEnabled() {
    return true;
}
exports.isMultiEnvEnabled = isMultiEnvEnabled;
/**
 * @deprecated Please DO NOT use this method any more, it will be removed in near future.
 */
function isArmSupportEnabled() {
    return isFeatureFlagEnabled(constants_1.FeatureFlagName.InsiderPreview, true);
}
exports.isArmSupportEnabled = isArmSupportEnabled;
function isBicepEnvCheckerEnabled() {
    return isFeatureFlagEnabled(constants_1.FeatureFlagName.BicepEnvCheckerEnable, true);
}
exports.isBicepEnvCheckerEnabled = isBicepEnvCheckerEnabled;
/**
 * @deprecated Please DO NOT use this method any more, it will be removed in near future.
 */
function isRemoteCollaborateEnabled() {
    return isFeatureFlagEnabled(constants_1.FeatureFlagName.InsiderPreview, true);
}
exports.isRemoteCollaborateEnabled = isRemoteCollaborateEnabled;
function getRootDirectory() {
    const root = process.env[constants_1.FeatureFlagName.rootDirectory];
    if (root === undefined || root === "") {
        return path.join(os.homedir(), constants_1.ConstantString.rootFolder);
    }
    else {
        return path.resolve(root.replace("${homeDir}", os.homedir()));
    }
}
exports.getRootDirectory = getRootDirectory;
async function generateBicepFromFile(templateFilePath, context) {
    try {
        const templateString = await fs.readFile(templateFilePath, constants_1.ConstantString.UTF8Encoding);
        const updatedBicepFile = compileHandlebarsTemplateString(templateString, context);
        return updatedBicepFile;
    }
    catch (error) {
        throw teamsfx_api_1.returnSystemError(new Error(`Failed to generate bicep file ${templateFilePath}. Reason: ${error.message}`), "Core", "BicepGenerationError");
    }
}
exports.generateBicepFromFile = generateBicepFromFile;
function compileHandlebarsTemplateString(templateString, context) {
    const template = Handlebars.compile(templateString);
    return template(context);
}
exports.compileHandlebarsTemplateString = compileHandlebarsTemplateString;
async function getAppDirectory(projectRoot) {
    const REMOTE_MANIFEST = "manifest.source.json";
    const MANIFEST_TEMPLATE = "manifest.remote.template.json";
    const MANIFEST_LOCAL = "manifest.local.template.json";
    const appDirNewLocForMultiEnv = `${projectRoot}/templates/${teamsfx_api_1.AppPackageFolderName}`;
    const appDirNewLoc = `${projectRoot}/${teamsfx_api_1.AppPackageFolderName}`;
    const appDirOldLoc = `${projectRoot}/.${teamsfx_api_1.ConfigFolderName}`;
    if ((await fs.pathExists(`${appDirNewLocForMultiEnv}/${MANIFEST_TEMPLATE}`)) ||
        (await fs.pathExists(`${appDirNewLocForMultiEnv}/${MANIFEST_LOCAL}`))) {
        return appDirNewLocForMultiEnv;
    }
    else if (await fs.pathExists(`${appDirNewLoc}/${REMOTE_MANIFEST}`)) {
        return appDirNewLoc;
    }
    else {
        return appDirOldLoc;
    }
}
exports.getAppDirectory = getAppDirectory;
/**
 * Get app studio endpoint for prod/int environment, mainly for ux e2e test
 */
function getAppStudioEndpoint() {
    if (process.env.APP_STUDIO_ENV && process.env.APP_STUDIO_ENV === "int") {
        return "https://dev-int.teams.microsoft.com";
    }
    else {
        return "https://dev.teams.microsoft.com";
    }
}
exports.getAppStudioEndpoint = getAppStudioEndpoint;
async function copyFiles(srcPath, distPath, excludeFileList = []) {
    await fs.ensureDir(distPath);
    const excludeFileNames = excludeFileList.map((file) => file.fileName);
    const recursiveExcludeFileNames = excludeFileList
        .filter((file) => file.recursive)
        .map((file) => file.fileName);
    const fileNames = await fs.readdir(srcPath);
    for (const fileName of fileNames) {
        if (excludeFileNames.includes(fileName)) {
            continue;
        }
        await fs.copy(path.join(srcPath, fileName), path.join(distPath, fileName), {
            overwrite: false,
            errorOnExist: true,
            filter: (src, dest) => !recursiveExcludeFileNames.includes(path.basename(src)),
        });
    }
}
exports.copyFiles = copyFiles;
function getStorageAccountNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/providers\/Microsoft.Storage\/storageAccounts\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("storage accounts name", resourceId);
    }
    return result;
}
exports.getStorageAccountNameFromResourceId = getStorageAccountNameFromResourceId;
function getSiteNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/providers\/Microsoft.Web\/sites\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("site name", resourceId);
    }
    return result;
}
exports.getSiteNameFromResourceId = getSiteNameFromResourceId;
function getResourceGroupNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/\/resourceGroups\/([^\/]*)\//i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("resource group name", resourceId);
    }
    return result;
}
exports.getResourceGroupNameFromResourceId = getResourceGroupNameFromResourceId;
function getSubscriptionIdFromResourceId(resourceId) {
    const result = parseFromResourceId(/\/subscriptions\/([^\/]*)\//i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("subscription id", resourceId);
    }
    return result;
}
exports.getSubscriptionIdFromResourceId = getSubscriptionIdFromResourceId;
function parseFromResourceId(pattern, resourceId) {
    const result = resourceId.match(pattern);
    return result ? result[1].trim() : "";
}
exports.parseFromResourceId = parseFromResourceId;
async function waitSeconds(second) {
    return new Promise((resolve) => setTimeout(resolve, second * 1000));
}
exports.waitSeconds = waitSeconds;
function getUuid() {
    return uuid.v4();
}
exports.getUuid = getUuid;
function isSPFxProject(projectSettings) {
    const solutionSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings;
    if (solutionSettings) {
        const selectedPlugins = solutionSettings.activeResourcePlugins;
        return selectedPlugins && selectedPlugins.indexOf("fx-resource-spfx") !== -1;
    }
    return false;
}
exports.isSPFxProject = isSPFxProject;
function getHashedEnv(envName) {
    return crypto.createHash("sha256").update(envName).digest("hex");
}
exports.getHashedEnv = getHashedEnv;
function IsSimpleAuthEnabled(projectSettings) {
    var _a;
    const solutionSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings;
    return (_a = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins) === null || _a === void 0 ? void 0 : _a.includes(constants_1.ResourcePlugins.SimpleAuth);
}
exports.IsSimpleAuthEnabled = IsSimpleAuthEnabled;
function isBasicJsonSchema(jsonSchema) {
    if (!jsonSchema || typeof jsonSchema !== "object") {
        return false;
    }
    return typeof jsonSchema["type"] === "string";
}
function _redactObject(obj, jsonSchema, maxRecursionDepth = 8, depth = 0) {
    if (depth >= maxRecursionDepth) {
        // prevent stack overflow if anything bad happens
        return null;
    }
    if (!obj || !isBasicJsonSchema(jsonSchema)) {
        return null;
    }
    if (!(jsonSchema.type === "object" &&
        jsonSchema.properties &&
        typeof jsonSchema.properties === "object")) {
        // non-object types including unsupported types
        return null;
    }
    const newObj = {};
    const objAny = obj;
    for (const key in jsonSchema.properties) {
        if (key in objAny && objAny[key] !== undefined) {
            const filteredObj = _redactObject(objAny[key], jsonSchema.properties[key], maxRecursionDepth, depth + 1);
            newObj[key] = filteredObj;
        }
    }
    return newObj;
}
/** Redact user content in "obj";
 *
 * DFS "obj" and "jsonSchema" together to redact the following things:
 * - properties that is not defined in jsonSchema
 * - the value of properties that is defined in jsonSchema, but the keys will remain
 *
 * Example:
 * Input:
 * ```
 *  obj = {
 *    "name": "some name",
 *    "user defined property": {
 *      "key1": "value1"
 *    }
 *  }
 *  jsonSchema = {
 *    "type": "object",
 *    "properties": {
 *      "name": { "type": "string" }
 *    }
 *  }
 * ```
 * Output:
 * ```
 *  {"name": null}
 * ```
 **/
function redactObject(obj, jsonSchema, maxRecursionDepth = 8) {
    return _redactObject(obj, jsonSchema, maxRecursionDepth, 0);
}
exports.redactObject = redactObject;
function getAllowedAppIds() {
    return [
        constants_1.TeamsClientId.MobileDesktop,
        constants_1.TeamsClientId.Web,
        constants_1.OfficeClientId.Web1,
        constants_1.OfficeClientId.Web2,
        constants_1.OutlookClientId.Desktop,
        constants_1.OutlookClientId.Web,
    ];
}
exports.getAllowedAppIds = getAllowedAppIds;
//# sourceMappingURL=tools.js.map