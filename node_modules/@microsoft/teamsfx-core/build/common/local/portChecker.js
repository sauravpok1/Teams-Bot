// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPortsInUse = void 0;
const tslib_1 = require("tslib");
const net = tslib_1.__importStar(require("net"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("./constants");
const packageJsonHelper_1 = require("./packageJsonHelper");
const projectSettingsHelper_1 = require("./projectSettingsHelper");
const allAddressIPv4 = "0.0.0.0";
const allAddressIPv6 = "::";
const loopbackAddressIPv4 = "127.0.0.1";
const loopbackAddressIPv6 = "::1";
const hosts = [allAddressIPv4, loopbackAddressIPv4, allAddressIPv6, loopbackAddressIPv6];
const frontendPortsV1 = [[3000, hosts]];
const frontendPorts = [[53000, hosts]];
const simpleAuthPorts = [[55000, hosts]];
const backendDebugPortRegex = /--inspect[\s]*=[\s"']*9229/im;
const backendDebugPorts = [[9229, hosts]];
const backendServicePortRegex = /--port[\s"']*7071/im;
const backendServicePorts = [[7071, hosts]];
const botDebugPortRegex = /--inspect[\s]*=[\s"']*9239/im;
const botDebugPorts = [[9239, hosts]];
const botServicePorts = [[3978, hosts]];
async function detectPortListeningOnHosts(port, hosts) {
    for (const host of hosts) {
        if (await detectPortListening(port, host)) {
            return true;
        }
    }
    return false;
}
async function detectPortListening(port, host) {
    return new Promise((resolve, _reject) => {
        try {
            const server = net.createServer();
            server
                .once("error", (err) => {
                if (err.message.includes("EADDRINUSE")) {
                    resolve(true);
                }
                else {
                    resolve(false);
                }
            })
                .once("listening", () => {
                server.close();
            })
                .once("close", () => {
                resolve(false);
            })
                .listen(port, host);
        }
        catch (err) {
            // ignore any error to not block debugging
            resolve(false);
        }
    });
}
async function getPortsInUse(projectPath, projectSettings, ignoreDebugPort) {
    const ports = [];
    const includeFrontend = projectSettingsHelper_1.ProjectSettingsHelper.includeFrontend(projectSettings);
    if (includeFrontend) {
        const migrateFromV1 = projectSettingsHelper_1.ProjectSettingsHelper.isMigrateFromV1(projectSettings);
        if (!migrateFromV1) {
            ports.push(...frontendPorts);
            ports.push(...simpleAuthPorts);
        }
        else {
            ports.push(...frontendPortsV1);
        }
    }
    const includeBackend = projectSettingsHelper_1.ProjectSettingsHelper.includeBackend(projectSettings);
    if (includeBackend) {
        ports.push(...backendServicePorts);
        if (!(ignoreDebugPort === true)) {
            const backendDevScript = await packageJsonHelper_1.loadTeamsFxDevScript(path.join(projectPath, constants_1.FolderName.Function));
            if (backendDevScript === undefined || backendDebugPortRegex.test(backendDevScript)) {
                ports.push(...backendDebugPorts);
            }
        }
    }
    const includeBot = projectSettingsHelper_1.ProjectSettingsHelper.includeBot(projectSettings);
    if (includeBot) {
        ports.push(...botServicePorts);
        if (!(ignoreDebugPort === true)) {
            const botDevScript = await packageJsonHelper_1.loadTeamsFxDevScript(path.join(projectPath, constants_1.FolderName.Bot));
            if (botDevScript === undefined || botDebugPortRegex.test(botDevScript)) {
                ports.push(...botDebugPorts);
            }
        }
    }
    const portsInUse = [];
    for (const port of ports) {
        if (await detectPortListeningOnHosts(port[0], port[1])) {
            portsInUse.push(port[0]);
        }
    }
    return portsInUse;
}
exports.getPortsInUse = getPortsInUse;
//# sourceMappingURL=portChecker.js.map