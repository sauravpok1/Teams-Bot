"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionNodeChecker = exports.AzureNodeChecker = exports.SPFxNodeChecker = exports.NodeChecker = void 0;
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const telemetry_1 = require("../constant/telemetry");
const message_1 = require("../constant/message");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const helpLink_1 = require("../constant/helpLink");
const NodeName = "Node.js";
class NodeVersion {
    constructor(version, majorVersion) {
        this.version = version;
        this.majorVersion = majorVersion;
    }
}
class NodeChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async isInstalled() {
        const supportedVersions = await this.getSupportedVersions();
        this._logger.debug(`NodeChecker checking for supported versions: '${JSON.stringify(supportedVersions)}'`);
        const currentVersion = await getInstalledNodeVersion();
        if (currentVersion === null) {
            this._telemetry.sendUserErrorEvent(telemetry_1.DepsCheckerEvent.nodeNotFound, "Node.js can't be found.");
            throw new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound, this._nodeNotFoundHelpLink);
        }
        if (!NodeChecker.isVersionSupported(supportedVersions, currentVersion)) {
            const supportedVersionsString = supportedVersions.map((v) => "v" + v).join(" ,");
            this._telemetry.sendUserErrorEvent(this._nodeNotSupportedEvent, `Node.js ${currentVersion.version} is not supported.`);
            throw new depsError_1.NodeNotSupportedError(message_1.Messages.NodeNotSupported.split("@CurrentVersion")
                .join(currentVersion.version)
                .split("@SupportedVersions")
                .join(supportedVersionsString), await this.getNodeNotSupportedHelpLink());
        }
        return true;
    }
    async resolve() {
        try {
            if (!(await this.isInstalled())) {
                await this.install();
            }
        }
        catch (error) {
            await this._logger.printDetailLog();
            await this._logger.error(`${error.message}, error = '${error}'`);
            if (error instanceof depsError_1.DepsCheckerError) {
                return teamsfx_api_1.err(error);
            }
            return teamsfx_api_1.err(new depsError_1.DepsCheckerError(error.message, helpLink_1.nodeNotFoundHelpLink));
        }
        finally {
            this._logger.cleanup();
        }
        return teamsfx_api_1.ok(true);
    }
    async install() {
        return Promise.resolve();
    }
    async getDepsInfo() {
        return {
            name: NodeName,
            isLinuxSupported: true,
            supportedVersions: await this.getSupportedVersions(),
            details: new Map(),
        };
    }
    static isVersionSupported(supportedVersion, version) {
        return supportedVersion.includes(version.majorVersion);
    }
    async command() {
        return "node";
    }
}
exports.NodeChecker = NodeChecker;
async function getInstalledNodeVersion() {
    try {
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, undefined, undefined, "node", "--version");
        return getNodeVersion(output);
    }
    catch (error) {
        return null;
    }
}
function getNodeVersion(output) {
    var _a;
    const regex = /v(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        return null;
    }
    const majorVersion = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version;
    if (!majorVersion) {
        return null;
    }
    return new NodeVersion(match[0], majorVersion);
}
class SPFxNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForSPFx;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForSPFxHelpLink;
    }
    async getSupportedVersions() {
        return ["10", "12", "14"];
    }
}
exports.SPFxNodeChecker = SPFxNodeChecker;
class AzureNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForAzure;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForAzureHelpLink;
    }
    async getSupportedVersions() {
        return ["10", "12", "14", "16"];
    }
}
exports.AzureNodeChecker = AzureNodeChecker;
class FunctionNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForAzure;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForFunctionsHelpLink;
    }
    async getSupportedVersions() {
        return ["10", "12", "14"];
    }
}
exports.FunctionNodeChecker = FunctionNodeChecker;
//# sourceMappingURL=nodeChecker.js.map