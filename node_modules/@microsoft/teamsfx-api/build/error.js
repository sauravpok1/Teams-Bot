"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidOperationError = exports.InvalidObjectError = exports.InvalidProjectError = exports.InvalidInputError = exports.ConcurrentError = exports.NoProjectOpenedError = exports.ReadFileError = exports.WriteFileError = exports.NotImplementedError = exports.UndefinedError = exports.ObjectNotExistError = exports.ObjectAlreadyExistsError = exports.PathNotExistError = exports.PathAlreadyExistsError = exports.EmptyOptionError = exports.UserCancelError = exports.UnknownError = exports.assembleError = exports.returnSystemError = exports.returnUserError = exports.SystemError = exports.UserError = void 0;
/**
 * Users can recover by themselves, e.g., users input invalid app names.
 */
class UserError extends Error {
    constructor(param1, param2, param3, param4, param5, innerError, notificationMessage) {
        let option;
        let stack;
        if (typeof param1 === "string") {
            option = {
                name: param1,
                message: param2,
                source: param3,
                helpLink: param5,
                notificationMessage: notificationMessage,
                error: innerError instanceof Error ? innerError : undefined,
            };
            if (innerError instanceof Error) {
                stack = innerError.stack;
            }
        }
        else if (param1 instanceof Error) {
            option = {
                error: param1,
                name: param3,
                source: param2,
                helpLink: param4,
                notificationMessage: param5,
            };
            stack = param1.stack;
        }
        else {
            option = param1;
        }
        // message
        const messages = new Set();
        if (option.message)
            messages.add(option.message);
        if (option.error && option.error.message)
            messages.add(option.error.message);
        const message = Array.from(messages).join(", ") || "";
        super(message);
        //name
        this.name = option.name || (option.error && option.error.name) || new.target.name;
        //source
        this.source = option.source || "unknown";
        //stack
        if (stack) {
            this.stack = stack;
        }
        else {
            Error.captureStackTrace(this, new.target);
        }
        //prototype
        Object.setPrototypeOf(this, new.target.prototype);
        //innerError
        if (typeof param1 === "string") {
            this.innerError = innerError;
        }
        else if (param1 instanceof Error) {
            this.innerError = param1;
        }
        //other fields
        this.helpLink = option.helpLink;
        this.userData = option.userData;
        this.notificationMessage = option.notificationMessage;
        this.timestamp = new Date();
    }
}
exports.UserError = UserError;
/**
 * Users cannot handle it by themselves.
 */
class SystemError extends Error {
    constructor(param1, param2, param3, param4, param5, innerError, notificationMessage) {
        let option;
        let stack;
        if (typeof param1 === "string") {
            option = {
                name: param1,
                message: param2,
                source: param3,
                issueLink: param5,
                notificationMessage: notificationMessage,
                error: innerError instanceof Error ? innerError : undefined,
            };
            if (innerError instanceof Error) {
                stack = innerError.stack;
            }
        }
        else if (param1 instanceof Error) {
            option = {
                error: param1,
                name: param3,
                source: param2,
                issueLink: param4,
                notificationMessage: param5,
            };
            stack = param1.stack;
        }
        else {
            option = param1;
        }
        // message
        const messages = new Set();
        if (option.message)
            messages.add(option.message);
        if (option.error && option.error.message)
            messages.add(option.error.message);
        const message = Array.from(messages).join(", ") || "";
        super(message);
        //name
        this.name = option.name || (option.error && option.error.name) || new.target.name;
        //source
        this.source = option.source || "unknown";
        //stack
        if (stack) {
            this.stack = stack;
        }
        else {
            Error.captureStackTrace(this, new.target);
        }
        //prototype
        Object.setPrototypeOf(this, new.target.prototype);
        //innerError
        if (typeof param1 === "string") {
            this.innerError = innerError;
        }
        else if (param1 instanceof Error) {
            this.innerError = param1;
        }
        //other fields
        this.issueLink = option.issueLink;
        this.userData = option.userData;
        this.notificationMessage = option.notificationMessage;
        this.timestamp = new Date();
    }
}
exports.SystemError = SystemError;
/**
 *
 * @param e Original error
 * @param source Source name of error. (plugin name, eg: tab-scaffhold-plugin)
 * @param name Name of error. (error name, eg: Dependency not found)
 * @param helpLink A wiki website that shows mapping relationship between error names, descriptions, and fix solutions.
 * @param innerError Custom error details.
 *
 * @returns UserError.
 */
function returnUserError(e, source, name, helpLink, innerError) {
    return new UserError(e, source, name, helpLink);
}
exports.returnUserError = returnUserError;
/**
 *
 * @param e Original error
 * @param source Source name of error. (plugin name, eg: tab-scaffhold-plugin)
 * @param name Name of error. (error name, eg: Dependency not found)
 * @param issueLink A github issue page where users can submit a new issue.
 * @param innerError Custom error details.
 *
 * @returns SystemError.
 */
function returnSystemError(e, source, name, issueLink, innerError) {
    return new SystemError(e, source, name, issueLink);
}
exports.returnSystemError = returnSystemError;
function assembleError(e, source) {
    if (e instanceof UserError || e instanceof SystemError)
        return e;
    if (!source)
        source = "unknown";
    const type = typeof e;
    if (type === "string") {
        return new UnknownError(source, e);
    }
    else if (e instanceof Error) {
        const err = e;
        const fxError = new SystemError(err, source);
        fxError.stack = err.stack;
        return fxError;
    }
    else {
        return new UnknownError(source, JSON.stringify(e));
    }
}
exports.assembleError = assembleError;
class UnknownError extends SystemError {
    constructor(source, message) {
        super({ source: source || "API", message: message });
    }
}
exports.UnknownError = UnknownError;
exports.UserCancelError = new UserError("UserCancel", "UserCancel", "UI");
class EmptyOptionError extends SystemError {
    constructor(source) {
        super({ source: source || "API" });
    }
}
exports.EmptyOptionError = EmptyOptionError;
class PathAlreadyExistsError extends UserError {
    constructor(source, path) {
        super({ source: source, message: `Path ${path} already exists.` });
    }
}
exports.PathAlreadyExistsError = PathAlreadyExistsError;
class PathNotExistError extends UserError {
    constructor(source, path) {
        super({ source: source, message: `Path ${path} does not exist.` });
    }
}
exports.PathNotExistError = PathNotExistError;
class ObjectAlreadyExistsError extends UserError {
    constructor(source, name) {
        super({ source: source, message: `${name} already exists.` });
    }
}
exports.ObjectAlreadyExistsError = ObjectAlreadyExistsError;
class ObjectNotExistError extends UserError {
    constructor(source, name) {
        super({ source: source, message: `${name} does not exist.` });
    }
}
exports.ObjectNotExistError = ObjectNotExistError;
class UndefinedError extends SystemError {
    constructor(source, name) {
        super({ source: source, message: `${name} is undefined, which is not expected` });
    }
}
exports.UndefinedError = UndefinedError;
class NotImplementedError extends SystemError {
    constructor(source, method) {
        super({ source: source, message: `Method not implemented:${method}` });
    }
}
exports.NotImplementedError = NotImplementedError;
class WriteFileError extends SystemError {
    constructor(source, e) {
        super({ source: source, error: e, name: "WriteFileError" });
    }
}
exports.WriteFileError = WriteFileError;
class ReadFileError extends SystemError {
    constructor(source, e) {
        super({ source: source, error: e, name: "ReadFileError" });
    }
}
exports.ReadFileError = ReadFileError;
class NoProjectOpenedError extends UserError {
    constructor(source) {
        super({
            source: source,
            message: "No project opened, you can create a new project or open an existing one.",
        });
    }
}
exports.NoProjectOpenedError = NoProjectOpenedError;
class ConcurrentError extends UserError {
    constructor(source) {
        super({
            source: source,
            message: "Previous task is still running. Please wait util your previous task to finish and try again.",
        });
    }
}
exports.ConcurrentError = ConcurrentError;
class InvalidInputError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `Input '${name}' is invalid: ${reason}` });
    }
}
exports.InvalidInputError = InvalidInputError;
class InvalidProjectError extends UserError {
    constructor(source, msg) {
        super({
            source: source,
            message: `The command only works for project created by Teams Toolkit. ${msg ? ": " + msg : ""}`,
        });
    }
}
exports.InvalidProjectError = InvalidProjectError;
class InvalidObjectError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `${name} is invalid: ${reason}` });
    }
}
exports.InvalidObjectError = InvalidObjectError;
class InvalidOperationError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `Invalid operation: ${name} ${reason}` });
    }
}
exports.InvalidOperationError = InvalidOperationError;
//# sourceMappingURL=error.js.map